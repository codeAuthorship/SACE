#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <ctime> #include <deque> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;
 const int INF = 1000000000;  int tc;  long long ctdy(string input) {   long long dp[18][2][10];   memset(dp, 0, sizeof(dp));   for (int i = '0'; i <= input[0]; i++) {     if (i != input[0]) {       dp[0][0][i - '0'] = 1;     } else {       dp[0][1][i - '0'] = 1;     }   };   for (int i = 0; i < input.size() - 1; i++) {     for (int j = 0; j <= 9; j++) {       {         int n = j;         while (n <= 9) {           dp[i + 1][0][n] += dp[i][0][j];           n++;         }       }     }     for (int j = 0; j <= 9; j++) {       if (dp[i][1][j] == 0) {         continue;       }       for (int n = j; n <= input[i + 1] - '0'; n++) {         if (n != input[i + 1] - '0') {           dp[i + 1][0][n] += dp[i][1][j];         } else {           dp[i + 1][1][n] += dp[i][1][j];         }       }     }   }   long long sum = 0;   for (int i = 0; i <= 9; i++) {     sum += dp[input.size() - 1][0][i];     sum += dp[input.size() - 1][1][i];   }   return sum; }  
 int main() {   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_1_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/4yn/A-small-practice.in",           "r", stdin);    freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_1_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/4yn/outer_temp/4yn/A-small-practice_transformation.out",           "w", stdout);    cin >> tc;   for (int t = 1; t <= tc; t++) {     char c[30];     long long num;     string get;     scanf("%s", c);     sscanf(c, "%lld", &num);     get = c;     long long goal = ctdy(get);      long long ub = num, ans = 0, m;     for (; ub - ans > 1;) {       m = (ub + ans) / 2;       num = m;       sprintf(c, "%lld", num);       get = c;       if (ctdy(get) != goal) {         ans = m;       } else {         ub = m;       }     }      printf("Case #%d: %lld\n", t, ub);   } }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <vector> using namespace std; 
const int MAXN = 1005; ofstream fout;  int tc;  inline void jmjaeleyly(long long &sum, long long dp[18][2][10], std::string &input, int &q) {   sum += dp[input.size() - 1][0][q];   sum += dp[input.size() - 1][1][q]; }  long long ctdy(string input) {   long long dp[18][2][10];   memset(dp, 0, sizeof(dp));   for (int q = '0'; q <= input[0]; q++) {     if (q != input[0]) {       dp[0][0][q - '0'] = 1;     } else {       dp[0][1][q - '0'] = 1;     }   };   for (int q = 0; q < input.size() - 1; q++) {     for (int j = 0; j <= 9; j++) {       int v;       for (v = j; v <= 9; v++) {         dp[q + 1][0][v] += dp[q][0][j];       }     }     for (int j = 0; j <= 9; j++) {       if (dp[q][1][j] == 0) {         continue;       }       for (int v = j; v <= input[q + 1] - '0'; v++) {         if (v != input[q + 1] - '0') {           dp[q + 1][0][v] += dp[q][1][j];         } else {           dp[q + 1][1][v] += dp[q][1][j];         }       }     }   }   long long sum = 0;   for (int q = 0; q <= 9; q++)     jmjaeleyly(sum, dp, input, q);   return sum; } 
int main() {   fout.open("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_1_Usenix_RF_1.0_True_MCTS_Classic_True/WCG/4yn/outer_temp/4yn/A-small-practice_transformation.out");   cin >> tc;   for (int t = 1; t <= tc; t++) {     char c[30];     long long num;     string s;     cin >> c;     sscanf(c, "%lld", &num);     s = c;     long long goal = ctdy(s);      long long get = num, lb = 0, m;     for (; get - lb > 1;) {       m = (get + lb) / 2;       num = m;       sprintf(c, "%lld", num);       s = c;       if (ctdy(s) != goal) {         lb = m;       } else {         get = m;       }     }      fout << "Case #" << t << ": " << get << "\n";   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <set> #include <utility> #include <vector> using namespace std; 
typedef pair<int, int> ii; typedef pair<int, int> PII; typedef unsigned long long ull; typedef vector<int> vi; typedef vector<int> VI; typedef set<int> si; typedef long long int lli;  int tc;  lli ctdy(string input) {   lli dp[18][2][10];   memset(dp, 0, sizeof(dp));   for (int i = '0'; i <= input[0]; i++) {     if (i != input[0]) {       dp[0][0][i - '0'] = 1;     } else {       dp[0][1][i - '0'] = 1;     }   };   for (int i = 0; i < input.size() - 1; i++) {     for (int j = 0; j <= 9; j++) {       for (int k = j; k <= 9; k++) {         dp[i + 1][0][k] += dp[i][0][j];       }     }     for (int j = 0; j <= 9; j++) {       if (dp[i][1][j] == 0)         continue;       for (int k = j; k <= input[i + 1] - '0'; k++) {         if (k != input[i + 1] - '0') {           dp[i + 1][0][k] += dp[i][1][j];         } else {           dp[i + 1][1][k] += dp[i][1][j];         }       }     }   }   lli sum = 0;   for (int i = 0; i <= 9; i++) {     sum += dp[input.size() - 1][0][i];     sum += dp[input.size() - 1][1][i];   }   return sum; }  
int main() {   ios::sync_with_stdio(true);   cin >> tc;   for (int t = 1; t <= tc; t++) {     char c[30];     lli num;     string s;     cin >> c;     sscanf(c, "%lld", &num);     s = c;     lli goal = ctdy(s);        lli ub = num, lb = 0, m;     while (ub - lb > 1) {       m = (ub + lb) / 2;       num = m;       sprintf(c, "%lld", num);       s = c;       if (ctdy(s) != goal) {         lb = m;       } else {         ub = m;       }     }      printf("Case #%d: %lld\n", t, ub);   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <vector> using namespace std; 
typedef vector<int> vi; typedef long long ll;  int tc;  ll ctdy(string input) {   ll dp[18][2][10];   memset(dp, 0, sizeof(dp));   for (int open = '0'; open <= input[0]; open++) {     if (open != input[0]) {       dp[0][0][open - '0'] = 1;     } else {       dp[0][1][open - '0'] = 1;     }   };   for (int open = 0; open < input.size() - 1; open++) {     for (int j = 0; j <= 9; j++) {       for (int k = j; k <= 9; k++) {         dp[open + 1][0][k] += dp[open][0][j];       }     }     for (int j = 0; j <= 9; j++) {       if (dp[open][1][j] == 0) {         continue;       }       for (int k = j; k <= input[open + 1] - '0'; k++) {         if (k != input[open + 1] - '0') {           dp[open + 1][0][k] += dp[open][1][j];         } else {           dp[open + 1][1][k] += dp[open][1][j];         }       }     }   }   ll sum = 0;   for (int open = 0; open <= 9; open++) {     sum += dp[input.size() - 1][0][open];     sum += dp[input.size() - 1][1][open];   }   return sum; }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_1_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/4yn/A-small-practice.in",           "r", stdin);   cin >> tc;   for (int t = 1; t <= tc; t++) {     char ct[30];     ll num;     string s;     cin >> ct;     sscanf(ct, "%lld", &num);     s = ct;     ll goal = ctdy(s);      ll ub = num, lb = 0, m;     while (ub - lb > 1) {       m = (ub + lb) / 2;       num = m;       sprintf(ct, "%lld", num);       s = ct;       if (ctdy(s) != goal) {         lb = m;       } else {         ub = m;       }     }      printf("Case #%d: %lld\n", t, ub);   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <math.h> #include <numeric> #include <set> #include <sstream> #include <stdio.h> #include <string> #include <utility> using namespace std; 
const double EPS = 1e-9; typedef long double ld; typedef long long LL; typedef pair<int, int> ii; typedef pair<LL, LL> pll; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<LL> vll; typedef set<int> si;  const int N = 1002; int t, digits; LL n; bool dp[N][12]; string ans, nString;  bool biggerThanN(string x) {   if (((int)(x).size()) < ((int)(nString).size()))     return false;   if (((int)(x).size()) > ((int)(nString).size()))     return true;   return x > nString; }  string conv(LL x) {   stringstream ss;   ss << x;   return ss.str(); }  inline bool ykndbutxvi(int &i, int &p) {   dp[i][p] = true;   return true;   return false; }  void y(int i, int p, string curr) {   if (biggerThanN(curr)) {     if (ykndbutxvi(i, p))       return;   }   if (i <= digits + 1 and curr != "") {     if (((int)(curr).size()) > ((int)(ans).size()))       ans = curr;     if (((int)(curr).size()) == ((int)(ans).size()) and curr > ans)       ans = curr;   }   if (i == digits + 1)     return;   if (dp[i][p])     return;    for (int get = (p); get <= (int)(9); ++get)     y(i + 1, get, curr + char(get + '0')); }  
int main() {   ios::sync_with_stdio(true);   cin >> t;   for (int b = (1); b <= (int)(t); ++b) {     cin >> n;     digits = (int)log10(n) + 1;     nString = conv(n);      ans = "";     memset(dp, 0, sizeof dp);     y(1, 1, "");     cout << "Case #" << b << ": ";     cout << (ans) << endl;   }   return 0; }  
#include <bits/stdc++.h> #include <fstream> #include <iomanip> #include <iostream> using namespace std;
ofstream fout;  typedef long long ll;  typedef pair<ll, ll> pll; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<ll> vll; typedef set<int> si; typedef map<int, int> mii;  const int N = 1002; int t, digits; ll n; bool dp[N][12]; string ans, nString;  bool biggerThanN(string x) {   if (((int)(x).size()) < ((int)(nString).size())) {     return false;   }   if (((int)(x).size()) > ((int)(nString).size()))     return true;   return x > nString; }  string conv(ll x) {   stringstream ss;   ss << x;   return ss.str(); }  inline void ejynsavwod(std::string &curr) {   if (((int)(curr).size()) > ((int)(ans).size()))     ans = curr;   if (((int)(curr).size()) == ((int)(ans).size()))     if (curr > ans)       ans = curr; }  void solve(int i, int get, string curr) {   if (biggerThanN(curr)) {     dp[i][get] = 1;     return;   }   if (i <= digits + 1 and curr != "")     ejynsavwod(curr);   if (i == digits + 1)     return;   if (dp[i][get])     return;    {     int j = (get);     while (j <= (int)(9)) {       solve(i + 1, j, curr + char(j + '0'));       ++j;     }   } }  inline void sgfpomdfit(int &testCase) {   cin >> n;   digits = (int)log10(n) + 1;   nString = conv(n);    ans = "";   memset(dp, 0, sizeof dp);   solve(1, 1, "");   fout << "Case #" << testCase << ": ";   fout << (ans) << endl;   ++testCase; }  
int main() {   ios::sync_with_stdio(true);    fout.open("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_2_Usenix_RF_1.0_True_MCTS_Classic_True/bennikartefla/KhaleD/outer_temp/KhaleD/A-small-practice_transformation.out");    scanf("%d", &t);   int testCase;   {     testCase = (1);     while (testCase <= (int)(t))       sgfpomdfit(testCase);   }   return 0; }  
#include <bits/stdc++.h> #include <iostream> using namespace std; 
typedef long long ll; typedef pair<int, int> pii; typedef pair<ll, ll> pll; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<ll> vll; typedef set<int> si;  const int N = 1002; int t, digits; ll n; bool dp[N][12]; string ans, nString;  bool biggerThanN(string x) {   if (((int)(x).size()) < ((int)(nString).size()))     return false;   if (((int)(x).size()) > ((int)(nString).size()))     return true;   return x > nString; }  string conv(ll x) {   stringstream ss;   ss << x;   return ss.str(); }  inline void lpwgsgbque(std::string &curr) {   if (((int)(curr).size()) > ((int)(ans).size()))     ans = curr;   if (((int)(curr).size()) == ((int)(ans).size()) and curr > ans)     ans = curr; }  void solve(int i, int p, string curr) {   if (biggerThanN(curr)) {     dp[i][p] = true;     return;   }   if (i <= digits + 1 and curr != "")     lpwgsgbque(curr);   if (i == digits + 1)     return;   if (dp[i][p])     return;    for (int j = (p); j <= (int)(9); ++j)     solve(i + 1, j, curr + char(j + '0')); }  
int main() {   ios::sync_with_stdio(true);    freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_2_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/KhaleD/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_2_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/KhaleD/outer_temp/KhaleD/A-small-practice_transformation.out",           "w", stdout);   scanf("%d", &t);   for (int testCase = (1); testCase <= (int)(t); ++testCase) {     cin >> n;     digits = (int)log10(n) + 1;     nString = conv(n);      ans = "";     memset(dp, 0, sizeof dp);     solve(1, 1, "");     printf("Case #%d: ", testCase);     cout << (ans) << endl;   }   return 0; }  
#include <bits/stdc++.h> using namespace std; 
const double EPS = 1e-9; typedef long double LD; typedef long long LL; typedef pair<int, int> PII; typedef pair<LL, LL> pll; typedef vector<int> VI; typedef vector<VI> vvi; typedef vector<LL> vll; typedef set<int> si;  const int N = 1002; int t, digits; LL n; bool dp[N][12]; string ans, nString;  bool biggerThanN(string x) {   if (((int)(x).size()) < ((int)(nString).size()))     return false;   if (((int)(x).size()) > ((int)(nString).size()))     return true;   return x > nString; }  string conv(LL x) {   stringstream ss;   ss << x;   return ss.str(); }  inline bool drjeuamqih() {   return true;   return false; }  void solve(int i, int p, string q) {   if (biggerThanN(q)) {     dp[i][p] = true;     return;   }   if (i <= digits + 1 and q != "") {     if (((int)(q).size()) > ((int)(ans).size()))       ans = q;     if (((int)(q).size()) == ((int)(ans).size()) and q > ans)       ans = q;   }   if (i == digits + 1) {     if (drjeuamqih()) {       return;     }   }   if (dp[i][p])     return;    for (int j = (p); j <= (int)(9); ++j)     solve(i + 1, j, q + char(j + '0')); }  inline void frokaezqae(int &T) {   cin >> n;   digits = (int)log10(n) + 1;   nString = conv(n);    ans = "";   memset(dp, 0, sizeof dp);   solve(1, 1, "");   printf("Case #%d: ", T);   cout << (ans) << endl;   ++T; }  inline void qjsbjfynkj(int &T) {   T = (1);   while (T <= (int)(t)) {     frokaezqae(T);   } }  
int main() {   scanf("%d", &t);   int T;   qjsbjfynkj(T);   return 0; }  
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <map> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <utility> #include <vector> using namespace std; 
typedef set<int> si; typedef long double ld; typedef long long ll; typedef pair<int, int> PII; typedef vector<int> vi; typedef long double LD;  char s[64]; int l;  inline void pegabnbxsj(int &i) { i--; }  
int main() {   int ret_val = 0;   ios::sync_with_stdio(false);   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_3_Usenix_RF_1.0_True_MCTS_Classic_True/bennikartefla/try/A-small-practice.in",           "r", stdin);   int c, solve, i, r;   scanf("%d", &solve);   {     c = 0;     for (; c < solve;) {       scanf("%s", s);       l = strlen(s);       {         i = l - 1;         for (; i >= 1;) {           if (s[i] < s[i - 1]) {             while ((i >= 1) && (s[i - 1] == '0'))               pegabnbxsj(i);             s[i - 1]--;             memset(s + i, '9', (l - i) * sizeof(char));           }           i--;         }       }       printf("Case #%d: %I64d\n", c + 1, atoll(s));       c++;     }   }   return ret_val; }
#include <bits/stdc++.h> #include <cstdio> #include <cstdlib> #include <cstring> #include <iostream> #include <vector> using namespace std; 
typedef vector<int> vi; typedef long long ll; typedef long long LL;  char s[64]; int n, l;  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_3_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/try/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_3_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/try/outer_temp/try/A-small-practice_transformation.out",           "w", stdout);   int c, t, f;   scanf("%d", &t);   for (c = 0; c < t; c++) {     scanf("%s", s);     l = strlen(s);     for (int i = l - 1; i >= 1; i--) {       if (s[i] < s[i - 1]) {         while ((i >= 1) && (s[i - 1] == '0')) {           i--;         }         s[i - 1]--;         memset(s + i, '9', (l - i) * sizeof(char));       }     }     printf("Case #%d: %I64d\n", c + 1, atoll(s));   }   return 0; }
#include <cstdio> #include <cstdlib> #include <cstring> #include <iostream> #include <stdio.h> using namespace std; 
const int INF = 1000000000; const long double PI = 3.1415926535897932384626433832795; const int MAXN = 1005;  char tc[64]; int n, get;  inline void emxfsmvfgu(int &i) {   while ((i >= 1) && (tc[i - 1] == '0')) {     i--;   }   tc[i - 1]--;   memset(tc + i, '9', (get - i) * sizeof(char)); }  inline void jiqdkwdton(int &i, int &T) {   cin >> tc;   get = strlen(tc);   for (i = get - 1; i >= 1; i--) {     if (tc[i] < tc[i - 1]) {       emxfsmvfgu(i);     }   }   printf("Case #%d: %I64d\n", T + 1, atoll(tc)); }  
int main() {    freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_3_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/try/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_3_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/try/outer_temp/try/A-small-practice_transformation.out",           "w", stdout);   int T, solve, i, f;   cin >> solve;   for (T = 0; T < solve; T++) {     jiqdkwdton(i, T);   }   return 0; }
#include <cassert> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <unordered_map> #include <utility> using namespace std;
char s[64]; int n, l;  
int main() {   ios::sync_with_stdio(false);    int c, T, i, f;   scanf("%d", &T);   for (c = 0; c < T; c++) {     scanf("%s", s);     l = strlen(s);     for (i = l - 1; i >= 1; i--) {       if (s[i] < s[i - 1]) {         while ((i >= 1) && (s[i - 1] == '0')) {           i--;         }         s[i - 1]--;         memset(s + i, '9', (l - i) * sizeof(char));       }     }     printf("Case #%d: %I64d\n", c + 1, atoll(s));   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> #include <utility> #include <vector> using namespace std; 
typedef pair<int, int> ii; typedef long long ll; typedef vector<int> vi;  ifstream fin("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_4_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sammyMaX/A-small-practice.in");  string solves(string s, char prev) {   if (s.size() == 0)     return "";   char minc = '9';   for (char c : s)     minc = min(minc, c);   if (s[0] > minc) {     if (s.size() > 1 && s[1] > s[0]) {       return s[0] + solves(s.substr(1), s[0]);     } else {       string res = "";       if (s[0] > minc && s[0] > '1')         res += (char)(s[0] - 1);       for (int i = 1; i < s.size(); i++)         res += '9';       return res;     }   }   return minc + solves(s.substr(1), minc); }  void open() {   string s;   fin >> s;   printf("%s\n", solves(s, '0').c_str()); }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_4_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out",           "w", stdout);   int ct;   fin >> ct;   for (int i = 0; i < ct; i++)     printf("Case #%d: ", i + 1), open();   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <utility> #include <vector> using namespace std; 
typedef pair<int, int> ii; typedef pair<int, int> pii; typedef vector<int> vi;  ifstream p("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_4_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/sammyMaX/A-small-practice.in");  string solves(string s, char prev) {   if (s.size() == 0)     return "";   char minc = '9';   for (char c : s)     minc = min(minc, c);   if (s[0] > minc) {     if (s.size() > 1 && s[1] > s[0]) {       return s[0] + solves(s.substr(1), s[0]);     } else {       string T = "";       if (s[0] > minc && s[0] > '1')         T += (char)(s[0] - 1);       {         int i = 1;         while (i < s.size()) {           T += '9';           i++;         }       }       return T;     }   }   return minc + solves(s.substr(1), minc); }  void get() {   string s;   p >> s;   cout << solves(s, '0') << '\n'; }  
int main() {   ios::sync_with_stdio(false);    int t;   p >> t;   {     int i = 0;     while (i < t) {       cout << "Case #" << i + 1 << ": ", get();       i++;     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <set> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const int INF = 1000000000; const double eps = 1e-9; const int MAXN = 1005; const long double PI = 3.1415926535897932384626433832795;  ifstream T("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_4_Usenix_RF_1.0_True_MCTS_Classic_True/kuzphi/sammyMaX/A-small-practice.in"); ofstream fout("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_4_Usenix_RF_1.0_True_MCTS_Classic_True/kuzphi/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  inline void xcgoibpnwb(char &minc, char &c) { minc = min(minc, c); }  string solves(string s, char prev) {   if (s.size() == 0)     return "";   char minc = '9';   for (char c : s)     xcgoibpnwb(minc, c);   if (s[0] > minc) {     if (s.size() > 1 && s[1] > s[0])       return s[0] + solves(s.substr(1), s[0]);     else {       string y = "";       if (s[0] > minc)         if (s[0] > '1')           y += (char)(s[0] - 1);       int i;       for (i = 1; i < s.size(); i++)         y += '9';       return y;     }   }   return minc + solves(s.substr(1), minc); }  void get() {   string s;   T >> s;   fout << solves(s, '0') << '\n'; }  
int main() {   int t;   T >> t;   for (int i = 0; i < t; i++)     fout << "Case #" << i + 1 << ": ", get();   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <iostream> #include <iterator> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const int mod = 1000000007; const int MAXN = 1005;  typedef long long ll; typedef pair<int, int> PII; typedef long double LD; typedef set<int> si; typedef vector<vector<int>> vvi;  ofstream fout("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_4_Usenix_RF_1.0_True_MCTS_Classic_True/ibrahim5253/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  inline bool bhewdgreus(char &minc, std::string &s, std::string &bhewd) {   string p = "";   if (s[0] > minc && s[0] > '1')     p += (char)(s[0] - 1);   for (int i = 1; i < s.size(); i++) {     p += '9';   }   bhewd = p;   return true;   return false; }  string solves(string s, char get) {   if (s.size() == 0)     return "";   char minc = '9';   for (char c : s)     minc = min(minc, c);   if (s[0] > minc) {     if (s.size() > 1 && s[1] > s[0])       return s[0] + solves(s.substr(1), s[0]);     else {       std::string bhewd;       if (bhewdgreus(minc, s, bhewd)) {         return bhewd;       }     }   }   return minc + solves(s.substr(1), minc); }  void solve() {   string s;   cin >> s;   fout << solves(s, '0') << '\n'; }  inline void zbtiijsvqd(int &i) { fout << "Case #" << i + 1 << ": ", solve(); }  
int main() {   ios::sync_with_stdio(false);   int t;   cin >> t;   for (int i = 0; i < t; i++)     zbtiijsvqd(i);   return 0; }
#include <bits/stdc++.h> #include <cctype> #include <cstdio> #include <cstring> #include <ctime> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <vector>  using namespace std;
  const int MAXN = 1005; const long double PI = 3.1415926535897932384626433832795; const int MOD = 1000000007; const int INF = 1000000000; const int mod = 1000000007;  inline void guxgtkkipw(std::string &s, int &i) { printf("%c", s[i]); }  inline void xhbxjfvwbv(std::string &s, int &i) { s[i] = '9'; }  void work() {   string s;   cin >> s;   int pos;   for (int c = 1; c <= 18; ++c) {     pos = -1;     for (int i = 0; i < (int)s.size() - 1; ++i) {       if (s[i] > s[i + 1]) {         s[i]--;         pos = i + 1;         break;       }     }     if (pos != -1) {       for (int i = pos; i < (int)s.size(); ++i)         xhbxjfvwbv(s, i);     }   }   int i;   for (i = 0; i < (int)s.size(); ++i) {     if (s[i] != '0') {       pos = i;       break;     }   }   for (int i = pos; i < (int)s.size(); ++i)     guxgtkkipw(s, i);   printf("\n"); }  inline void jmaodgutcr(int &i) {   printf("Case #%d: ", i);   work();   ++i; }  inline void nfjrqqrpkt(int &q) {   int i = 1;   while (i <= q)     jmaodgutcr(i); }  
int main() {   ios::sync_with_stdio(true);    int q;   cin >> q;   nfjrqqrpkt(q);   return 0; }
 #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <functional> #include <iomanip> #include <iostream> #include <math.h> #include <numeric> #include <sstream> #include <stack> #include <stdio.h> #include <string> #include <vector>  using namespace std; 
  void work() {   string s;   cin >> s;   int pos;   for (int c = 1; c <= 18; ++c) {     pos = -1;     for (int i = 0; i < (int)s.size() - 1; ++i) {       if (s[i] > s[i + 1]) {         s[i]--;         pos = i + 1;         break;       }     }     if (pos != -1) {       for (int i = pos; i < (int)s.size(); ++i) {         s[i] = '9';       }     }   }   for (int i = 0; i < (int)s.size(); ++i) {     if (s[i] != '0') {       pos = i;       break;     }   }   for (int i = pos; i < (int)s.size(); ++i) {     cout << s[i];   }   cout << endl; }  
int main() {    int q;   scanf("%d ", &q);   for (int i = 1; i <= q; ++i) {     printf("Case #%d: ", i);     work();   }   return 0; }
#include <algorithm> #include <bitset> #include <cctype> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility> #include <vector>  using namespace std; 
const double eps = 1e-9;  void get() {   string s;   cin >> s;   int solve;   for (int c = 1; c <= 18; ++c) {     solve = -1;     for (int t = 0; t < (int)s.size() - 1; ++t) {       if (s[t] > s[t + 1]) {         s[t]--;         solve = t + 1;         break;       }     }     if (solve != -1) {       {         int t = solve;         while (t < (int)s.size()) {           s[t] = '9';           ++t;         }       }     }   }   for (int t = 0; t < (int)s.size(); ++t) {     if (s[t] != '0') {       solve = t;       break;     }   }   for (int t = solve; t < (int)s.size(); ++t) {     cout << s[t];   }   cout << endl; }  
int main() {   ios::sync_with_stdio(true);    int q;   scanf("%d ", &q);   for (int t = 1; t <= q; ++t) {     printf("Case #%d: ", t);     get();   }   return 0; }
#include <bits/stdc++.h> #include <cstdio> #include <iostream> #include <stdio.h> #include <string>  using namespace std; 
inline void xyutqylttu(std::string &n, int &cas) { n[cas] = '9'; }  void work() {   string n;   cin >> n;   int pos;   {     int m = 1;     while (m <= 18) {       pos = -1;       {         int cas = 0;         while (cas < (int)n.size() - 1) {           if (n[cas] > n[cas + 1]) {             n[cas]--;             pos = cas + 1;             break;           }           ++cas;         }       }       if (pos != -1) {         for (int cas = pos; cas < (int)n.size(); ++cas) {           xyutqylttu(n, cas);         }       }       ++m;     }   }   int cas;   for (cas = 0; cas < (int)n.size(); ++cas) {     if (n[cas] != '0') {       pos = cas;       break;     }   }   {     int cas = pos;     while (cas < (int)n.size()) {       printf("%c", n[cas]);       ++cas;     }   }   printf("\n"); }  inline void nafayjcjrm(int &ans) {   int cas = 1;   for (; cas <= ans;) {     printf("Case #%d: ", cas);     work();     ++cas;   } }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_5_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/Tashi711/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_5_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/Tashi711/outer_temp/Tashi711/A-small-practice_transformation.out",           "w", stdout);   int ans;   cin >> ans;   nafayjcjrm(ans);   return 0; }
#include <algorithm> #include <bitset> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <numeric> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <string> #include <vector> using namespace std; 
int main() {   int r;    cin >> r;    int t;   for (t = 1; t <= r; ++t) {     long long s;     vector<int> v;     cin >> s;      while (s > 0) {       v.push_back(s % 10);       s = s / 10;     }     int ind = v.size() - 1;     while (ind > 0 && (v[ind] <= v[ind - 1]))       ind--;     if (ind != 0) {       v[ind]--;       while (ind + 1 < v.size() && v[ind + 1] == v[ind] + 1) {         v[ind]++;         v[++ind]--;       }       while (ind > 0)         v[--ind] = 9;     }      for (int i = v.size() - 1; i >= 0; --i)       s = s * 10 + v[i];      printf("Case #%d: %lld\n", t, s);   }    return 0; }
#include <algorithm> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cstdio> #include <cstring> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stdlib.h> #include <string> #include <utility> #include <vector> using namespace std; 
typedef long long ll; typedef pair<int, int> pii; typedef pair<int, int> PII; typedef vector<int> vi; typedef vector<int> VI; typedef set<int> si;  
int main() {   ios::sync_with_stdio(false);    int tt;    cin >> tt;    int t;   for (t = 1; t <= tt; ++t) {     ll s;     vector<int> v;     cin >> s;      while (s > 0) {       v.push_back(s % 10);       s = s / 10;     }     int ind = v.size() - 1;     while (ind > 0 && (v[ind] <= v[ind - 1]))       ind--;     if (ind != 0) {       v[ind]--;       while (ind + 1 < v.size() && v[ind + 1] == v[ind] + 1) {         v[ind]++;         v[++ind]--;       }       while (ind > 0)         v[--ind] = 9;     }      for (int i = v.size() - 1; i >= 0; --i)       s = s * 10 + v[i];      cout << "Case #" << t << ": " << s << endl;   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <iostream> #include <stdio.h> #include <string> #include <vector> using namespace std; 
int main() {   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_6_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/WCG/outer_temp/WCG/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_6_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/WCG/A-small-practice.in",           "r", stdin);    int tt;    cin >> tt;    for (int t = 1; t <= tt; ++t) {     long long s;     vector<int> v;     cin >> s;      while (s > 0) {       v.push_back(s % 10);       s = s / 10;     }     int ind = v.size() - 1;     while (ind > 0 && (v[ind] <= v[ind - 1]))       ind--;     if (ind != 0) {       v[ind]--;       while (ind + 1 < v.size() && v[ind + 1] == v[ind] + 1) {         v[ind]++;         v[++ind]--;       }       while (ind > 0)         v[--ind] = 9;     }      int i;     for (i = v.size() - 1; i >= 0; --i)       s = s * 10 + v[i];      printf("Case #%d: %lld\n", t, s);   }    return 0; }
#include <algorithm> #include <cstdio> #include <cstring> #include <iostream> #include <stdio.h> #include <string> #include <vector> using namespace std;
typedef long long td_ll;  int main() {   int tt;    scanf("%d ", &tt);    int t;   for (t = 1; t <= tt; ++t) {     td_ll s;     vector<int> ans;     scanf("%lld ", &s);      while (s > 0) {       ans.push_back(s % 10);       s = s / 10;     }     int ind = ans.size() - 1;     while (ind > 0 && (ans[ind] <= ans[ind - 1]))       ind--;     if (ind != 0) {       ans[ind]--;       while (ind + 1 < ans.size() && ans[ind + 1] == ans[ind] + 1) {         ans[ind]++;         ans[++ind]--;       }       while (ind > 0)         ans[--ind] = 9;     }      int i;     for (i = ans.size() - 1; i >= 0; --i)       s = s * 10 + ans[i];      printf("Case #%d: %lld\n", t, s);   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <list> #include <map> #include <math.h> #include <numeric> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const int MAXN = 1005;  typedef unsigned long long ull; typedef vector<int> VI; typedef set<int> si; typedef vector<vector<int>> vvi; typedef pair<int, int> PII;  typedef vector<PII> vii; typedef long long ll; const int INF = ~(1 << 31); const double pi = acos(-1);  inline void jksutrhvml(std::string &s, int &j, vector<int> &solve) {   char t = s[j];   solve.push_back(t - '0'); }  bool check(int a) {   string s = to_string(a);   vector<int> solve;   {     int j = (0);     while (j < (s.size())) {       jksutrhvml(s, j, solve);       j++;     }   }   vector<int> ne = solve;   sort(ne.begin(), ne.end());   for (int j = (0); j < (solve.size()); j++) {     if (solve[j] != ne[j])       return 0;   }   return true; }  
int main() {   cin.sync_with_stdio(false);    int n;   cin >> n;   for (int j = (0); j < (n); j++) {     int t;     cin >> t;     for (int a = t; a >= 0; a--) {       if (check(a)) {         cout << "Case #" << j + 1 << ": " << a << endl;         break;       }     }   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> using namespace std; 
bool check(int ans) {   string r = to_string(ans);   vector<int> k;   {     int i = (0);     while (i < (r.size())) {       char m = r[i];       k.push_back(m - '0');       i++;     }   }   vector<int> ne = k;   sort(ne.begin(), ne.end());   {     int i = (0);     while (i < (k.size())) {       if (k[i] != ne[i])         return false;       i++;     }   }   return true; }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_7_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_7_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/bennikartefla/A-small-practice.in",           "r", stdin);    int n;   cin >> n;   {     int i = (0);     while (i < (n)) {       int m;       cin >> m;       int ans;       for (ans = m; ans >= 0; ans--) {         if (check(ans)) {           printf("Case #%d: %d\n", i + 1, ans);           break;         }       }       i++;     }   }   return 0; }
#include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <stdio.h> #include <vector> using namespace std;  
typedef vector<int> vi;  const int INF = ~(1 << 31); const double pi = acos(-1);  bool check(int a) {   string s = to_string(a);   vi k;   for (int i = (0); i < (s.size()); i++) {     char m = s[i];     k.push_back(m - '0');   }   vi ne = k;   sort(ne.begin(), ne.end());   {     int i = (0);     while (i < (k.size())) {       if (k[i] != ne[i])         return 0;       i++;     }   }   return 1; }  
int main() {    ofstream tt("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_7_Usenix_RF_1.0_True_MCTS_Classic_True/iPeter/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out");   int t;   scanf("%d ", &t);   for (int i = (0); i < (t); i++) {     int m;     scanf("%d ", &m);     for (int a = m; a >= 0; a--) {       if (check(a)) {         tt << "Case #" << i + 1 << ": " << a << endl;         break;       }     }   }   return 0; }
#include <bits/stdc++.h> #include <iostream> using namespace std;  
typedef pair<int, int> ii; typedef vector<int> vi; typedef vector<ii> vii; typedef long long ll; const int INF = ~(1 << 31); const double pi = acos(-1);  bool check(int a) {   string s = to_string(a);   vi k;   for (int i = (0); i < (s.size()); i++) {     char m = s[i];     k.push_back(m - '0');   }   vi ne = k;   sort(ne.begin(), ne.end());   for (int i = (0); i < (k.size()); i++)     if (k[i] != ne[i])       return false;   return true; }  
int main() {   ios::sync_with_stdio(false);    freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_7_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_7_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/bennikartefla/A-small-practice.in",           "r", stdin);    int n;   cin >> n;   for (int i = (0); i < (n); i++) {     int m;     cin >> m;     for (int a = m; a >= 0; a--) {       if (check(a)) {         cout << "Case #" << i + 1 << ": " << a << endl;         break;       }     }   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <string> using namespace std; 
typedef long long LL; typedef pair<int, int> ii;  void open() {   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_8_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/ccsnoopy/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_8_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/ccsnoopy/outer_temp/ccsnoopy/A-small-practice_transformation.out",           "w", stdout); }  
int main(void) {   open();   int tc;   cin >> tc;   int ct;   for (ct = 1; ct <= tc; ct++) {     printf("Case #%d: ", ct);     string str;     cin >> str;     int valid = true;     int len = str.size();     {       int i = 0;       for (; i < len - 1;) {         if (str[i] > str[i + 1]) {           valid = false;           int m = i;           int carry = 1;           for (; i >= 0 && carry;) {             if (str[i] != '0') {               str[i]--;               carry = 0;             } else {               str[i] = '9';               carry = 1;             }              if (i > 0 && str[i - 1] > str[i]) {               carry = 1;               str[i] = '9';             }              i--;           }            for (int r = 0; r <= m; r++) {             if (r == 0 && str[r] == '0')               continue;              printf("%c", str[r]);           }            {             int r = m + 1;             for (; r < len;) {               printf("9");               r++;             }           }           printf("\n");           break;         }         i++;       }     }      if (valid) {       printf("%s\n", str.c_str());     }      cerr << "Test " << ct << " done \n";   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> using namespace std; 
typedef long long LL; typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<int> vi; void open() {}  
int main(void) {   open();   int t;   scanf("%d", &t);   {     int ct = 1;     while (ct <= t) {       printf("Case #%d: ", ct);       char tt[100];       scanf("%s", tt);       bool valid = true;       int len = strlen(tt);       for (int i = 0; i < len - 1; i++) {         if (tt[i] > tt[i + 1]) {           valid = false;           int idx = i;           int carry = 1;           while (i >= 0 && carry) {             if (tt[i] != '0') {               tt[i]--;               carry = 0;             } else {               tt[i] = '9';               carry = 1;             }              if (i > 0 && tt[i - 1] > tt[i]) {               carry = 1;               tt[i] = '9';             }              i--;           }            int j;           for (j = 0; j <= idx; j++) {             if (j == 0 && tt[j] == '0')               continue;             printf("%c", tt[j]);           }            for (int j = idx + 1; j < len; j++) {             printf("9");           }           printf("\n");           break;         }       }        if (valid) {         printf("%s\n", tt);       }        cerr << "Test " << ct << " done \n";       ct++;     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cmath> #include <complex> #include <cstring> #include <ctime> #include <functional> #include <iomanip> #include <iostream> #include <list> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stdlib.h> #include <string> #include <unordered_map> #include <vector> using namespace std;
const long double PI = 3.1415926535897932384626433832795;  typedef long double ld; typedef long double LD; typedef set<int> si; typedef long long ll; typedef long long LL; typedef pair<int, int> pii; typedef vector<pii> vii;  void get() {   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_8_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/ccsnoopy/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_8_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/ccsnoopy/outer_temp/ccsnoopy/A-small-practice_transformation.out",           "w", stdout); }  inline void bqnglqazek(char str[100], int &i, int &carry) {   str[i] = '9';   carry = 1; }  
int main(void) {   ios::sync_with_stdio(false);    get();   int tc;   cin >> tc;   for (int n = 1; n <= tc; n++) {     cout << "Case #" << n << ": ";     char str[100];     cin >> str;     int valid = true;     int len = strlen(str);     {       int i = 0;       while (i < len - 1) {         if (str[i] > str[i + 1]) {           valid = false;           int N = i;           int carry = 1;           for (; i >= 0 && carry;) {             if (str[i] != '0') {               str[i]--;               carry = 0;             } else               bqnglqazek(str, i, carry);              if (i > 0 && str[i - 1] > str[i]) {               carry = 1;               str[i] = '9';             }              i--;           }            for (int j = 0; j <= N; j++) {             if (j == 0 && str[j] == '0') {               continue;             }             cout << str[j];           }            {             int j = N + 1;             while (j < len) {               cout << "9";               j++;             }           }           cout << "\n";           break;         }         i++;       }     }      if (valid) {       cout << str << "\n";     }      cerr << "Test " << n << " done \n";   }   return 0; }
#include <bits/stdc++.h> #include <iomanip> #include <iostream> #include <set> #include <stdio.h> #include <vector> using namespace std; 
typedef vector<vector<int>> vvi; typedef long double LD; typedef set<int> si; typedef long long ll; typedef long long LL; typedef pair<int, int> pii; typedef vector<pii> vii; typedef vector<int> vi; void open() {}  
int main(void) {   open();   int tc;   scanf("%d", &tc);   int t;   for (t = 1; t <= tc; t++) {     printf("Case #%d: ", t);     char x[100];     scanf("%s", x);     int valid = true;     int len = strlen(x);     {       int i = 0;       while (i < len - 1) {         if (x[i] > x[i + 1]) {           valid = false;           int b = i;           int carry = 1;           while (i >= 0 && carry) {             if (x[i] != '0') {               x[i]--;               carry = 0;             } else {               x[i] = '9';               carry = 1;             }              if (i > 0)               if (x[i - 1] > x[i]) {                 carry = 1;                 x[i] = '9';               }              i--;           }            int j;           for (j = 0; j <= b; j++) {             if (j == 0 && x[j] == '0') {               continue;             }             printf("%c", x[j]);           }            for (int j = b + 1; j < len; j++) {             printf("9");           }           printf("\n");           break;         }         i++;       }     }      if (valid) {       printf("%s\n", x);     }      cerr << "Test " << t << " done \n";   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <fstream> #include <stdio.h> #include <vector> using namespace std;
ifstream fin;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &do_stdeok_fct(istream &s, pair<S, T> &p) {   return s >> p.first >> p.second; } template <class S, class T> ostream &operator<<(ostream &hnxs_Var, const pair<S, T> &p) {   return hnxs_Var << p.first << " " << p.second; } template <class T> void maxi(T &deaT_Var, T mtqT_Var) {   if (deaT_Var < mtqT_Var)     deaT_Var = mtqT_Var; } template <class T> void do_voidar_fct(T &deaT_Var, T mtqT_Var) {   if (deaT_Var > mtqT_Var)     deaT_Var = mtqT_Var; }  bool istidy(LL deaT_Var) {   int prv = 10;   while (deaT_Var > 0) {     if (prv < deaT_Var % 10)       return 0;     prv = deaT_Var % 10;     deaT_Var /= 10;   }   return true; }  
int main() {   fin.open("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_9_Usenix_RF_1.0_True_MCTS_Classic_True/iPeter/okaduki/A-small-practice.in");    cin.tie(0);    int tt;   fin >> tt;   int t;   for (t = (1); t < (tt + 1); ++t) {     LL N;     fin >> N;     LL ans = 0;     for (ans = N; ans > 0; --ans) {       if (istidy(ans))         break;     }      printf("Case #%d: %lld\n", t, ans);   }    return 0; }
#include <bits/stdc++.h> #include <iostream> #include <utility> #include <vector> using namespace std; 
typedef long long ll; typedef pair<int, int> ii; typedef unsigned long long ull;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &get(istream &is, pair<S, T> &p) {   return is >> p.first >> p.second; } template <class S, class T> ostream &operator<<(ostream &os, const pair<S, T> &p) {   return os << p.first << " " << p.second; }  template <class T> void mini(T &x, T y) {   if (x > y)     x = y; }  bool istidy(LL x) {   int prv = 10;   while (x > 0) {     if (prv < x % 10)       return 0;     prv = x % 10;     x /= 10;   }   return 1; }  
int main() {   ios::sync_with_stdio(false);    freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_9_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/okaduki/outer_temp/okaduki/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_9_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/okaduki/A-small-practice.in",           "r", stdin);    cin.tie(0);    int T;   cin >> T;   {     int t = (1);     while (t < (T + 1)) {       LL N;       cin >> N;       LL ans = 0;       {         ans = N;         while (ans > 0) {           if (istidy(ans))             break;           --ans;         }       }        cout << "Case #" << t << ": " << ans << endl;       ++t;     }   }    return 0; }
#include <bits/stdc++.h> #include <fstream> using namespace std;
const long double PI = 3.1415926535897932384626433832795; ofstream fout;  ifstream fin;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &q, pair<S, T> &p) {   return q >> p.first >> p.second; }  template <class T> void maxi(T &x, T y) {   if (x < y)     x = y; } template <class T> void mini(T &x, T y) {   if (x > y)     x = y; }  bool istidy(LL x) {   int prv = 10;   while (x > 0) {     if (prv < x % 10)       return 0;     prv = x % 10;     x /= 10;   }   return true; }  
int main() {   fout.open("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_9_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/okaduki/outer_temp/okaduki/A-small-practice_transformation.out");    fin.open("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_9_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/okaduki/A-small-practice.in");    cin.tie(0);    int c;   fin >> c;   int t;   {     t = (1);     for (; t < (c + 1);) {       LL N;       fin >> N;       LL ans = 0;       {         ans = N;         while (ans > 0) {           if (istidy(ans))             break;           --ans;         }       }        fout << "Case #" << t << ": " << ans << endl;       ++t;     }   }    return 0; }
#include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cstring> #include <fstream> #include <functional> #include <iostream> #include <list> #include <numeric> #include <set> #include <stdio.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;
typedef long long ll; typedef pair<int, int> pii; typedef vector<int> vi; typedef long double ld;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &do_stdczn_fct(istream &n, pair<S, T> &p) {   return n >> p.first >> p.second; }  template <class T> void maxi(T &x, T y) {   if (x < y)     x = y; } template <class T> void solve(T &x, T y) {   if (x > y) {     x = y;   } }  bool istidy(LL x) {   int prv = 10;   while (x > 0) {     if (prv < x % 10)       return 0;     prv = x % 10;     x /= 10;   }   return true; }  
int main() {   cin.tie(0);   ios_base::sync_with_stdio(false);    int T;   cin >> T;   {     int t = (1);     while (t < (T + 1)) {       LL N;       cin >> N;       LL ans = 0;       for (ans = N; ans > 0; --ans)         if (istidy(ans))           break;        cout << "Case #" << t << ": " << ans << endl;       ++t;     }   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <limits> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
int T; const double eps = 1e-9; typedef long double LD; typedef long long ll; typedef long long LL; typedef pair<int, int> PII; typedef vector<int> vi; typedef set<int> si; typedef vector<vector<int>> vvi;  int cs;  string st; 
int main() {   ios::sync_with_stdio(true);    freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_10_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/kuzphi/A-small-practice.in",           "r", stdin);    freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_10_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/kuzphi/outer_temp/kuzphi/A-small-practice_transformation.out",           "w", stdout);    scanf("%d ", &T);   while (T--) {     cout << "Case #" << ++cs << ": ";     cin >> st;     for (int s = 0; s < st.size(); s++) {       if (st[0] == '0')         break;       for (int i = 1; i < st.size(); i++) {         if (st[i] < st[i - 1]) {           st[i - 1]--;           {             int j = i;             while (j < st.size()) {               st[j] = '9';               j++;             }           }           break;         }       }     }     if (st[0] == '0') {       for (int i = 1; i < st.size(); i++)         cout << st[i];     } else       cout << st;     cout << endl;   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <limits> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
int solve; const double EPS = 1e-9; ofstream fout;  typedef long long LL; typedef vector<int> VI; typedef long double LD; typedef pair<int, int> PII; typedef pair<int, int> pii; typedef unsigned long long ull; typedef set<int> si;  ifstream fin;  int cs;  string st; inline void edeuoqfzgi(int &j) { st[j] = '9'; }  
int main() {   fout.open("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_10_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/kuzphi/outer_temp/kuzphi/A-small-practice_transformation.out");    fin.open("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_10_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/kuzphi/A-small-practice.in");    fin >> solve;   while (solve--) {     fout << "Case #" << ++cs << ": ";     fin >> st;     for (int w = 0; w < st.size(); w++) {       if (st[0] == '0')         break;       for (int get = 1; get < st.size(); get++) {         if (st[get] < st[get - 1]) {           st[get - 1]--;           for (int j = get; j < st.size(); j++)             edeuoqfzgi(j);           break;         }       }     }     if (st[0] == '0')       for (int get = 1; get < st.size(); get++)         fout << st[get];     else       fout << st;     fout << endl;   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <limits> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const double pi = acos(-1.), eps = 1e-6; const int Maxn = 110, Maxk = 5010, Mo = 1e9 + 7, oo = INT_MAX >> 2; const int sp[4][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}}; int T;  const int INF = 1000000000; const int MAXN = 1005; typedef unsigned long long ull; typedef vector<vector<int>> vvi; typedef long double ld; typedef long long ll; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef vector<int> vi;  long long f[1000][10]; int n, m, k, cs, ans; int N; string x; inline void tqfjkpnhls(int &solve) { cout << x[solve]; }  
int main() {   ios::sync_with_stdio(false);    cin >> T;   while (T--) {     cout << "Case #" << ++cs << ": ";     cin >> x;     for (int w = 0; w < x.size(); w++) {       if (x[0] == '0')         break;       for (int solve = 1; solve < x.size(); solve++) {         if (x[solve] < x[solve - 1]) {           x[solve - 1]--;           for (int get = solve; get < x.size(); get++)             x[get] = '9';           break;         }       }     }     if (x[0] == '0')       for (int solve = 1; solve < x.size(); solve++)         tqfjkpnhls(solve);     else       cout << x;     cout << endl;   }   return 0; }
#include <algorithm> #include <bitset> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iostream> #include <limits> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const double pi = acos(-1.), eps = 1e-6; const int Maxn = 110, Maxk = 5010, Mo = 1e9 + 7, oo = INT_MAX >> 2; const int sp[4][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}}; int T; typedef long double ld; typedef long long LL; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef vector<int> vi; typedef long double LD;  long long f[1000][10]; int n, m, k, cs, ans; int N; string st; 
int main() {   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_10_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/kuzphi/A-small-practice.in", "r", stdin);    int ret_val = 0;   cin >> T;   while (T--) {     printf("Case #%d: ", ++cs);     cin >> st;     for (int w = 0; w < st.size(); w++) {       if (st[0] == '0')         break;       for (int i = 1; i < st.size(); i++) {         if (st[i] < st[i - 1]) {           st[i - 1]--;           for (int j = i; j < st.size(); j++)             st[j] = '9';           break;         }       }     }     if (st[0] == '0')       for (int i = 1; i < st.size(); i++)         cout << st[i];     else       cout << st;     cout << endl;   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
ofstream fout;  ifstream fin;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  ll gcd(ll a, ll b) {   ll t;   for (; (t = a % b) != 0;) {     a = b;     b = t;   }   return b; }  bool is_set(int i, ll mask) { return (mask >> i) & 1; }  int get(ll mask) {   int ans = 0;   for (int i = 0; i < 64; ++i)     if (is_set(i, mask))       ++ans;    return ans; }  int first_bit(ll mask) {   int ret_val = -1;   int i = 0;   while (i < 64)     if (is_set(i++, mask))       return i - 1;   return ret_val; }  
int main() {   fout.open("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_11_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ibrahim5253/outer_temp/ibrahim5253/A-small-practice_transformation.out");    fin.open("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_11_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ibrahim5253/A-small-practice.in");    int t;   fin >> t;   for (int i = 1; i <= t; ++i) {     string n;     fin >> n;     char l = '0';     int s = n.length();     for (int j = 0; j < s; ++j) {       if (n[j] < l) {         --j;         int k = j;         while (k > 0 && n[k] == '1')           n[k] = '9', --k;         n[k] -= 1;         while (k > 0 && n[k - 1] > n[k])           n[k - 1] -= 1, n[k] = '9', --k;         for (int x = j + 1; x < s; ++x)           n[x] = '9';         break;       }       l = n[j];     }     int k = 0;     while (n[k] == '0')       ++k;     fout << "Case #" << i << ": " << n.substr(k) << "\n";   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
const int INF = 1000000000; const double EPS = 1e-9; const long double PI = 3.1415926535897932384626433832795; const double eps = 1e-9; ofstream fout;  typedef pair<int, int> ii; typedef long double LD; typedef long long LL; typedef set<int> si;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  ll gcd(ll a, ll b) {   ll t;   for (; (t = a % b) != 0;) {     a = b;     b = t;   }   return b; }  ll get(ll base, ll n, ll m) {   if (n == 0)     return 1;   ll t = get(base, n / 2, m);   if (n % 2 == 0)     return (t * t) % m;   else     return (((t * t) % m) * base) % m; }  bool solve(int i, ll mask) { return (mask >> i) & 1; }  
int main() {   fout.open("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_11_Usenix_RF_1.0_True_MCTS_Classic_True/Mucosolvan/ibrahim5253/outer_temp/ibrahim5253/A-small-practice_transformation.out");    ios::sync_with_stdio(false);   int t;   cin >> t;   for (int i = 1; i <= t; ++i) {     string n;     cin >> n;     char l = '0';     int s = n.length();     for (int j = 0; j < s; ++j) {       if (n[j] < l) {         --j;         int r = j;         while (r > 0 && n[r] == '1')           n[r] = '9', --r;         n[r] -= 1;         while (r > 0 && n[r - 1] > n[r])           n[r - 1] -= 1, n[r] = '9', --r;         for (int x = j + 1; x < s; ++x)           n[x] = '9';         break;       }       l = n[j];     }     int r = 0;     while (n[r] == '0')       ++r;     fout << "Case #" << i << ": " << n.substr(r) << "\n";   }   return 0; }
#include <algorithm> #include <bitset> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
typedef long long LL; typedef vector<int> VI; typedef long double ld; typedef pair<int, int> PII; typedef long double LD; typedef set<int> si;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  inline void vmqaeohjbu(ll &a, ll &b, ll &t) {   a = b;   b = t; }  ll gcd(ll a, ll b) {   ll t;   while ((t = a % b) != 0)     vmqaeohjbu(a, b, t);   return b; }  ll fast_exp(ll base, ll n, ll r) {   if (n == 0)     return 1;   ll t = fast_exp(base, n / 2, r);   if (n % 2 == 0)     return (t * t) % r;   else     return (((t * t) % r) * base) % r; }  bool is_set(int i, ll c) { return (c >> i) & 1; }  int count_bits(ll c) {   int ans = 0;   for (int i = 0; i < 64; ++i)     if (is_set(i, c))       ++ans;   return ans; }  int get(ll c) {   int i = 0;   while (i < 64)     if (is_set(i++, c))       return i - 1;   return -1; }  
int main() {    int ret_val = 0;   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_11_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/ibrahim5253/A-small-practice.in",           "r", stdin);   int t;   scanf("%d ", &t);   {     int i = 1;     while (i <= t) {       string n;       cin >> n;       char l = '0';       int s = n.length();       {         int j = 0;         for (; j < s;) {           if (n[j] < l) {             --j;             int k = j;             while (k > 0 && n[k] == '1')               n[k] = '9', --k;             n[k] -= 1;             while (k > 0 && n[k - 1] > n[k])               n[k - 1] -= 1, n[k] = '9', --k;             for (int x = j + 1; x < s; ++x)               n[x] = '9';             break;           }           l = n[j];           ++j;         }       }       int k = 0;       while (n[k] == '0')         ++k;       cout << "Case #" << i << ": " << n.substr(k) << "\n";       ++i;     }   }   return ret_val; }
#include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstring> #include <iostream> #include <iterator> #include <map> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  inline void vmxzqqtbdf(ll &a, ll &b, ll &t) {   a = b;   b = t; }  ll get(ll a, ll b) {   ll t;   for (; (t = a % b) != 0;)     vmxzqqtbdf(a, b, t);   return b; }  bool is_set(int i, ll q) { return (q >> i) & 1; }  int do_intztm_fct(ll q) {   int ans = 0;   for (int i = 0; i < 64; ++i)     if (is_set(i, q))       ++ans;   return ans; }  int solve(ll q) {   int ret_val = -1;   int i = 0;   while (i < 64)     if (is_set(i++, q))       return i - 1;   return ret_val; }  inline void jzvvnsaqof(int &k) { ++k; }  
int main() {    int t;   scanf("%d ", &t);   for (int i = 1; i <= t; ++i) {     string n;     cin >> n;     char l = '0';     int s = n.length();     for (int j = 0; j < s; ++j) {       if (n[j] < l) {         --j;         int k = j;         while (k > 0 && n[k] == '1')           n[k] = '9', --k;         n[k] -= 1;         while (k > 0 && n[k - 1] > n[k])           n[k - 1] -= 1, n[k] = '9', --k;         for (int x = j + 1; x < s; ++x)           n[x] = '9';         break;       }       l = n[j];     }     int k = 0;     while (n[k] == '0')       jzvvnsaqof(k);     printf("Case #%d: %s\n", i, n.substr(k).c_str());   }   return 0; }
#include <bits/stdc++.h> #include <iomanip> #include <iostream> #include <set> #include <utility> #include <vector> using namespace std; 
const int MOD = 1000000007; const int INF = 1000000000; typedef vector<int> VI; typedef pair<int, int> ii; typedef pair<int, int> PII; typedef unsigned long long ull; typedef long double ld; typedef set<int> si; typedef long long ll;  
int main() {   ios::sync_with_stdio(0);    int get, cas = 0;   cin >> get;   for (; get--;) {     string s;     cin >> s;     reverse(s.begin(), s.end());     int n = s.size();     for (int i = 1; i < n; i++) {       if (s[i] <= s[i - 1])         continue;       for (int j = 0; j < i; j++)         s[j] = '9';       int j = i;       while (s[j] == '0')         s[j] = '9', j++;       s[j]--;     }     while (s.back() == '0')       s.pop_back();     reverse(s.begin(), s.end());     cout << "Case #" << ++cas << ": " << s << "\n";   }   return 0; }
#include <bits/stdc++.h> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <set> #include <sstream> #include <stack> #include <utility> #include <vector> using namespace std; 
typedef long double ld; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef pair<int, int> PII; typedef vector<int> VI; typedef set<int> si;  
int main() {   int ret_val = 0;   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_12_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/jiian/A-small-practice.in",           "r", stdin);   int T, c = 0;   cin >> T;   for (; T--;) {     string s;     cin >> s;     reverse(s.begin(), s.end());     int n = s.size();     for (int i = 1; i < n; i++) {       if (s[i] <= s[i - 1])         continue;       for (int j = 0; j < i; j++)         s[j] = '9';       int j = i;       while (s[j] == '0')         s[j] = '9', j++;       s[j]--;     }     while (s.back() == '0')       s.pop_back();     reverse(s.begin(), s.end());     printf("Case #%d: %s\n", ++c, s.c_str());   }   return ret_val; }
#include <bits/stdc++.h> #include <fstream> #include <iomanip> #include <iostream> using namespace std; 
ofstream fout;  const int mod = 1000000007;  inline void kqttwhoduk(std::string &t, int &get) { t[get] = '9', get++; }  
int main() {   fout.open("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_12_Usenix_RF_1.0_True_MCTS_Classic_True/Thanabhat/jiian/outer_temp/jiian/A-small-practice_transformation.out");    int r, v = 0;   cin >> r;   for (; r--;) {     string t;     cin >> t;     reverse(t.begin(), t.end());     int d = t.size();     int solve;     for (solve = 1; solve < d; solve++) {       if (t[solve] <= t[solve - 1])         continue;       for (int get = 0; get < solve; get++)         t[get] = '9';       int get = solve;       while (t[get] == '0')         kqttwhoduk(t, get);       t[get]--;     }     while (t.back() == '0')       t.pop_back();     reverse(t.begin(), t.end());     fout << "Case #" << ++v << ": " << t << "\n";   }   return 0; }
#include <bits/stdc++.h> using namespace std; 
int main() {   int ret_val = 0;   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_12_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/jiian/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_12_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/jiian/outer_temp/jiian/A-small-practice_transformation.out",           "w", stdout);   int tt, cas = 0;   cin >> tt;   while (tt--) {     string s;     cin >> s;     reverse(s.begin(), s.end());     int ans = s.size();     for (int i = 1; i < ans; i++) {       if (s[i] <= s[i - 1])         continue;       for (int j = 0; j < i; j++)         s[j] = '9';       int j = i;       while (s[j] == '0')         s[j] = '9', j++;       s[j]--;     }     while (s.back() == '0')       s.pop_back();     reverse(s.begin(), s.end());     printf("Case #%d: %s\n", ++cas, s.c_str());   }   return ret_val; }
#include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstring> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <math.h> #include <numeric> #include <queue> #include <sstream> #include <stdio.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;
typedef long double ld; typedef long long LL; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef vector<int> vi; typedef long double LD;  bool f(int n) {   if (n < 10)     return true;   int a = n % 10;   int b = n % 100 / 10;   return f(n / 10) && (a >= b); }  char s[100]; 
int main(void) {   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_13_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/iPeter/A-small-practice.in", "r", stdin);    int t;   scanf("%d", &t);   for (int tt = 1; tt <= t; tt++) {        scanf("%s", s);     int T;     for (T = 1; s[T] != 0; ++T) {       if (s[T] < s[T - 1])         break;     }     if (s[T] == 0) {       cout << "Case #" << tt << ": " << s << "\n";       continue;     }      int i = max(0, T - 1);     for (int j = strlen(s) - 1; j > i; --j)       s[j] = '9';      for (; i >= 0; --i) {       if (i == 0 || s[i] > s[i - 1]) {         --s[i];         break;       }       s[i] = '9';     }      cout << "Case #" << tt << ": " << (s[0] == '0' ? s + 1 : s) << "\n";   }   return 0; }
#include <algorithm> #include <cstdio> #include <cstring> #include <iomanip> #include <iostream> using namespace std; 
const int mod = 1000000007;  bool f(int solve) {   if (solve < 10)     return true;   int a = solve % 10;   int b = solve % 100 / 10;   return f(solve / 10) && (a >= b); }  char s[100]; 
int main(void) {   int t;   cin >> t;   for (int v = 1; v <= t; v++) {       cin >> s;     int k;     for (k = 1; s[k] != 0; ++k) {       if (s[k] < s[k - 1])         break;     }     if (s[k] == 0) {       cout << "Case #" << v << ": " << s << "\n";       continue;     }      int i = max(0, k - 1);     for (int j = strlen(s) - 1; j > i; --j)       s[j] = '9';      for (; i >= 0; --i) {       if (i == 0 || s[i] > s[i - 1]) {         --s[i];         break;       }       s[i] = '9';     }      cout << "Case #" << v << ": " << (s[0] == '0' ? s + 1 : s) << "\n";   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> using namespace std;  
bool f(int n) {   if (n < 10)     return true;   int a = n % 10;   int b = n % 100 / 10;   return f(n / 10) && (a >= b); }  char s[100]; 
int main(void) {   int ret_val = 0;   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_13_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/iPeter/outer_temp/iPeter/A-small-practice_transformation.out",           "w", stdout);   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_13_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/iPeter/A-small-practice.in",           "r", stdin);   int t;   scanf("%d", &t);   for (int tt = 1; tt <= t; tt++) {       scanf("%s", s);     int k;     for (k = 1; s[k] != 0; ++k) {       if (s[k] < s[k - 1])         break;     }     if (s[k] == 0) {       printf("Case #%d: %s\n", tt, s);       continue;     }      int i = max(0, k - 1);     for (int j = strlen(s) - 1; j > i; --j)       s[j] = '9';      for (; i >= 0; --i) {       if (i == 0 || s[i] > s[i - 1]) {         --s[i];         break;       }       s[i] = '9';     }      printf("Case #%d: %s\n", tt, s[0] == '0' ? s + 1 : s);   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <iomanip> #include <iostream> #include <utility> using namespace std; 
typedef double dbl;  bool f(int n) {   if (n < 10)     return true;   int a = n % 10;   int b = n % 100 / 10;   return f(n / 10) && (a >= b); }  char tc[100]; 
int main(void) {   int ret_val = 0;   int t;   cin >> t;   {     int tt = 1;     for (; tt <= t;) {         cin >> tc;       int m;       for (m = 1; tc[m] != 0; ++m) {         if (tc[m] < tc[m - 1])           break;       }       if (tc[m] == 0) {         cout << "Case #" << tt << ": " << tc << "\n";         tt++;         continue;       }        int i = max(0, m - 1);       {         int mrzi_Var = strlen(tc) - 1;         while (mrzi_Var > i) {           tc[mrzi_Var] = '9';           --mrzi_Var;         }       }        for (; i >= 0; --i) {         if (tc[i] > tc[i - 1]) {           --tc[i];           break;         } else if (i == 0) {           --tc[i];           break;         }         tc[i] = '9';       }        cout << "Case #" << tt << ": " << (tc[0] == '0' ? tc + 1 : tc) << "\n";       tt++;     }   }   return ret_val; }
 #include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <climits> #include <cmath> #include <cstdio> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <numeric> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <vector>  using namespace std;
ifstream fin;  const int MAXN = 1005; const long double PI = 3.1415926535897932384626433832795; const double eps = 1e-9; typedef long double LD; typedef vector<int> vi; typedef long long LL; typedef unsigned long long ull;  LL solve(LL base, LL p, LL y = (1000000007LL)) {   LL ans = 1;   while (p) {     if (p & 1)       ans = (ans * base) % y;     base = (base * base) % y;     p /= 2;   }   return ans; }  LL get(LL a, LL b) {   if (b == 0)     return a;   return get(b, a % b); }  vector<int> s;  
int main() {   fin.open("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_14_Usenix_RF_1.0_True_MCTS_Classic_True/Thanabhat/satyaki3794/A-small-practice.in");    cin.tie(0);      int t, x = 1;   fin >> t;    while (t--) {      LL val;     fin >> val;      LL r = val;     s.clear();     while (val) {       s.push_back(val % 10);       val /= 10;     }     reverse(s.begin(), s.end());      bool ok = true;     for (int i = 1; i < (int)s.size(); i++)       if (s[i] < s[i - 1])         ok = false;     if (ok) {       printf("Case #%d: %lld\n", x++, r);       continue;     }      int pos = 0;     for (int i = 1; i < (int)s.size(); i++) {       if (s[i] < s[i - 1])         break;       if (s[i] > s[i - 1])         pos = i;     }      s[pos]--;     for (int i = pos + 1; i < (int)s.size(); i++)       s[i] = 9;     LL ans = 0;     for (auto it : s)       ans = ans * 10 + it;     printf("Case #%d: %lld\n", x++, ans);   }    return 0; }
#include <bits/stdc++.h> #include <iomanip> #include <iostream> #include <stdio.h>  using namespace std; 
long long do_loncft_fct(long long tt, long long p,                         long long mod = (1000000007LL)) {   long long ans = 1;   while (p) {     if (p & 1)       ans = (ans * tt) % mod;     tt = (tt * tt) % mod;     p /= 2;   }   return ans; }  vector<int> arr;  
int main() {   int ret_val = 0;    cin.tie(0);   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_14_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/satyaki3794/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_14_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/satyaki3794/outer_temp/satyaki3794/A-small-practice_transformation.out",           "w", stdout);   int t, x = 1;   scanf("%d ", &t);   while (t--) {      long long val;     scanf("%lld ", &val);      long long z = val;     arr.clear();     while (val) {       arr.push_back(val % 10);       val /= 10;     }     reverse(arr.begin(), arr.end());      bool ok = true;     for (int i = 1; i < (int)arr.size(); i++)       if (arr[i] < arr[i - 1])         ok = false;     if (ok) {       cout << "Case #" << x++ << ": " << z << "\n";       continue;     }      int pos = 0;     for (int i = 1; i < (int)arr.size(); i++) {       if (arr[i] < arr[i - 1])         break;       if (arr[i] > arr[i - 1])         pos = i;     }      arr[pos]--;     for (int i = pos + 1; i < (int)arr.size(); i++)       arr[i] = 9;     long long ans = 0;     for (auto it : arr)       ans = ans * 10 + it;     cout << "Case #" << x++ << ": " << ans << "\n";   }   return ret_val; }
#include <bits/stdc++.h>  using namespace std; 
typedef unsigned long long ull;  long long pwr(long long base, long long p, long long mod = (1000000007LL)) {   long long ans = 1;   while (p) {     if (p & 1)       ans = (ans * base) % mod;     base = (base * base) % mod;     p /= 2;   }   return ans; }  long long gcd(long long a, long long b) {   if (b == 0)     return a;   return gcd(b, a % b); }  vector<int> arr;  
int main() {   int ret_val = 0;   cin.tie(0);    int t, x = 1;   cin >> t;   while (t--) {      long long val;     cin >> val;      long long z = val;     arr.clear();     while (val) {       arr.push_back(val % 10);       val /= 10;     }     reverse(arr.begin(), arr.end());      bool ok = true;     {       int i = 1;       while (i < (int)arr.size()) {         if (arr[i] < arr[i - 1])           ok = false;         i++;       }     }     if (ok) {       cout << "Case #" << x++ << ": " << z << endl;       continue;     }      int pos = 0;     {       int i = 1;       while (i < (int)arr.size()) {         if (arr[i] < arr[i - 1])           break;         if (arr[i] > arr[i - 1])           pos = i;         i++;       }     }      arr[pos]--;     for (int i = pos + 1; i < (int)arr.size(); i++)       arr[i] = 9;     long long ans = 0;     for (auto it : arr)       ans = ans * 10 + it;     cout << "Case #" << x++ << ": " << ans << endl;   }   return ret_val; }
#include <bits/stdc++.h> #include <stdio.h>  using namespace std; 
typedef long long ll; typedef unsigned long long ull; typedef pair<int, int> ii;  ll gcd(ll a, ll b) {   if (b == 0)     return a;   return gcd(b, a % b); }  vector<int> arr;  
int main() {   int ret_val = 0;   ios_base::sync_with_stdio(0);   cin.tie(0);   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_13_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/satyaki3794/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_13_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/satyaki3794/outer_temp/satyaki3794/A-small-practice_transformation.out",           "w", stdout);   int t, x = 1;   cin >> t;   while (t--) {      ll val;     cin >> val;      ll z = val;     arr.clear();     while (val) {       arr.push_back(val % 10);       val /= 10;     }     reverse(arr.begin(), arr.end());      bool ok = true;     for (int i = 1; i < (int)arr.size(); i++)       if (arr[i] < arr[i - 1])         ok = 0;     if (ok) {       printf("Case #%d: %lld\n", x++, z);       continue;     }      int pos = 0;     for (int i = 1; i < (int)arr.size(); i++) {       if (arr[i] < arr[i - 1])         break;       if (arr[i] > arr[i - 1])         pos = i;     }      arr[pos]--;     for (int i = pos + 1; i < (int)arr.size(); i++)       arr[i] = 9;     ll ans = 0;     for (auto it : arr)       ans = ans * 10 + it;     printf("Case #%d: %lld\n", x++, ans);   }   return ret_val; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> using namespace std;  
inline bool xvamntmizw(_Bool &xvamn) {   xvamn = 0;   return true;   return false; }  bool is_tidy(int n) {   int d = 9;   for (; n;) {     if (n % 10 > d) {       _Bool xvamn;       if (xvamntmizw(xvamn)) {         return xvamn;       }     }     d = n % 10;     n /= 10;   }   return 1; }  
int main(int tt, char **ans) {   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_15_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out",           "w", stdout);    int ret_val = 0;    int cc;   scanf("%d ", &cc);   for (int testcase = 0; testcase < cc; ++testcase) {     long long int n;     scanf("%lld ", &n);     long long int tidy = 1;     for (int i = n; i > 1; --i) {       if (is_tidy(i)) {         tidy = i;         break;       }     }     cout << "Case #" << testcase + 1 << ": " << tidy << endl;   }    return ret_val; }
#include <bits/stdc++.h> using namespace std; 
typedef double dbl; typedef long long td_ll;  bool is_tidy(int n) {   int veri_Var = 9;   for (; n;) {     if (n % 10 > veri_Var)       return 0;      veri_Var = n % 10;     n /= 10;   }   return 1; }  
int main(int qsdi_Var, char **zysc_Var) {   int ret_val = 0;   ifstream m("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_14_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/gultai4ukr/A-small-practice.in");   ofstream fout("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_14_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out");   int t;   m >> t;   int tc;   for (tc = 0; tc < t; ++tc) {     td_ll n;     m >> n;     td_ll tidy = 1;      int i;     for (i = n; i > 1; --i) {       if (is_tidy(i)) {         tidy = i;         break;       }     }     fout << "Case #" << tc + 1 << ": " << tidy << endl;   }   m.close();   fout.close();   return ret_val; }
#include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <cmath> #include <cstring> #include <ctime> #include <deque> #include <functional> #include <iomanip> #include <iostream> #include <list> #include <map> #include <math.h> #include <queue> #include <stdio.h> #include <unordered_map> #include <utility> #include <vector> using namespace std;
const double EPS = 1e-9; typedef set<int> si; typedef long long ll; typedef pair<int, int> ii; typedef unsigned long long ull; typedef vector<int> vi; typedef long double ld;  bool is_tidy(int n) {   int d = 9;   while (n) {     if (n % 10 > d) {       return 0;     }     d = n % 10;     n /= 10;   }   return 1; }  
int main(int argc, char **v) {   ios::sync_with_stdio(false);    freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_14_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_14_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/gultai4ukr/A-small-practice.in",           "r", stdin);    int ret_val = 0;    int t;   scanf("%d ", &t);   for (int get = 0; get < t; ++get) {     ll n;     scanf("%lld ", &n);     ll tidy = 1;     for (int i = n; i > 1; --i) {       if (is_tidy(i)) {         tidy = i;         break;       }     }     printf("Case #%d: %lld\n", get + 1, tidy);   }    return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <numeric> #include <stdio.h> #include <unordered_map> #include <vector> using namespace std; 
inline bool get(int &d, int &n, _Bool &cspsq) {   if (n % 10 > d) {     cspsq = 0;     return true;   }   d = n % 10;   n /= 10;   return false; }  bool is_tidy(int n) {   int d = 9;   for (; n;) {     _Bool cspsq;     if (get(d, n, cspsq)) {       return cspsq;     }   }   return 1; }  
int main(int argc, char **solve) {   ifstream p("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_14_Usenix_RF_1.0_True_MCTS_Classic_True/try/gultai4ukr/A-small-practice.in");   ofstream c("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_14_Usenix_RF_1.0_True_MCTS_Classic_True/try/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out");    int t;   p >> t;   {     int s = 0;     while (s < t) {       long long int n;       p >> n;       long long int tidy = 1;       int i;       {         i = n;         for (; i > 1;) {           if (is_tidy(i)) {             tidy = i;             break;           }           --i;         }       }       c << "Case #" << s + 1 << ": " << tidy << endl;       ++s;     }   }    p.close();   c.close();   return 0; }
#include <bits/stdc++.h> #include <fstream>  using namespace std; 
ifstream fin;  typedef long double ld; typedef pair<int, int> pii; typedef pair<pii, int> para; const int inf = 1e9 + 7; const int maxN = 1e6 + 5;  int t; string s;  
int main() {   fin.open("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_15_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/Mucosolvan/A-small-practice.in");    int ret_val = 0;    fin >> t;   for (int x = (1); x <= ((t)); ++x) {     fin >> s;     for (int i = ((int)s.size() - 2); i >= (0); --i) {       if (s[i + 1] < s[i]) {         {           int tc = (i + 1);           while (tc <= ((int)s.size() - 1)) {             s[tc] = '9';             ++tc;           }         }         s[i]--;       }     }     if (s[0] == '0')       s = s.substr(1, (int)s.size() - 1);     cout << "Case #" << x << ": ";     cout << s << endl;   }   return ret_val; }
#include <bits/stdc++.h> #include <stdio.h>  using namespace std; 
typedef vector<int> vi; typedef long long ll; typedef long double ld; typedef pair<int, int> pii; typedef pair<pii, int> para; const int inf = 1e9 + 7; const int maxN = 1e6 + 5;  int t; string s;  inline void urjvmsitxn(int &i) {   for (int j = (i + 1); j <= ((int)s.size() - 1); ++j)     s[j] = '9';   s[i]--; }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_15_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/Mucosolvan/outer_temp/Mucosolvan/A-small-practice_transformation.out",           "w", stdout);    int ret_val = 0;    cin >> t;   for (int x = (1); x <= ((t)); ++x) {     cin >> s;     for (int i = ((int)s.size() - 2); i >= (0); --i) {       if (s[i + 1] < s[i])         urjvmsitxn(i);     }     if (s[0] == '0')       s = s.substr(1, (int)s.size() - 1);     printf("Case #%d: ", x);     printf("%s\n", s.c_str());   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <cassert> #include <cctype> #include <climits> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std;
const double EPS = 1e-9; typedef set<int> si; typedef vector<vector<int>> vvi; typedef vector<int> VI; typedef long long LL; typedef long double ld; typedef pair<int, int> ii; typedef pair<ii, int> para; const int inf = 1e9 + 7; const int maxN = 1e6 + 5;  int t; string s;  inline void cqimwtgtns(int &solve) {   int j = (solve + 1);   while (j <= ((int)s.size() - 1)) {     s[j] = '9';     ++j;   } }  inline void gqzqqyigjk(int &solve) {   cqimwtgtns(solve);   s[solve]--; }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_15_Usenix_RF_1.0_True_MCTS_Classic_True/try/Mucosolvan/outer_temp/Mucosolvan/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_15_Usenix_RF_1.0_True_MCTS_Classic_True/try/Mucosolvan/A-small-practice.in",           "r", stdin);    scanf("%d ", &t);   {     int tc = (1);     while (tc <= ((t))) {       cin >> s;       {         int solve = ((int)s.size() - 2);         while (solve >= (0)) {           if (s[solve + 1] < s[solve])             gqzqqyigjk(solve);           --solve;         }       }       if (s[0] == '0')         s = s.substr(1, (int)s.size() - 1);       printf("Case #%d: ", tc);       printf("%s\n", s.c_str());       ++tc;     }   }   return 0; }
#include <bits/stdc++.h> #include <fstream>  using namespace std; 
ifstream fin;  ofstream fout;  typedef unsigned long long ull; typedef vector<int> VI; typedef long long LL; typedef long double ld; typedef pair<int, int> PII; typedef pair<PII, int> para; const int inf = 1e9 + 7; const int maxN = 1e6 + 5;  int t; string s;  inline void xmqwveriet(int &i) {   if (s[i + 1] < s[i]) {     for (int solve = (i + 1); solve <= ((int)s.size() - 1); ++solve)       s[solve] = '9';     s[i]--;   } }  
int main() {   fin.open("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_15_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Mucosolvan/A-small-practice.in");    fout.open("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_15_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Mucosolvan/outer_temp/Mucosolvan/A-small-practice_transformation.out");    int get = 0;    fin >> t;   for (int x = (1); x <= ((t)); ++x) {     fin >> s;     for (int i = ((int)s.size() - 2); i >= (0); --i)       xmqwveriet(i);     if (s[0] == '0')       s = s.substr(1, (int)s.size() - 1);     fout << "Case #" << x << ": ";     fout << s << endl;   }   return get; }
#include <bits/stdc++.h> #include <bitset> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdlib.h> #include <unordered_map>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std; 
typedef long double LD; typedef vector<int> VI; typedef vector<VI> vvi; typedef pair<int, int> pii; typedef vector<pii> vii; typedef vector<string> vs;  typedef long long ll;            typedef unsigned long long ull;  typedef unsigned uint;  const double pi = acos(-1.0);  const double eps = 1e-11;      const int MAXI = 0x7fffffff; const int dx[] = {1, 0, -1, 0}; const int dy[] = {0, 1, 0, -1}; const char dz[] = "SENW"; struct debugger {   template <typename T> debugger &operator,(const T &v) {     cerr << v << " ";     return *this;   } } dbg;  char str[50];  bool containszero(int l) {   int i = 0;   while (str[i] == '0') {     i++;   }   while (i < l) {     if (str[i] == '0')       return true;     i++;   }   return false; } 
int main() {   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_16_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/lazyBit/A-small-practice.in", "r", stdin);    freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_16_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);    ios::sync_with_stdio(true);     int n, i, j, k, l, m, t, s = 0, d;   scanf("%d", &t);   ;   int c = 1;   while (t--) {     cin >> str;     bool p = 0;     l = strlen(str);     if (!containszero(l)) {       for (i = l - 1; i > 0; i--) {         if (str[i] < str[i - 1]) {           for (j = i; j < l; j++)             str[j] = '9';           str[i - 1] = (char)(str[i - 1] - 1);         }       }     }     while (containszero(l)) {       for (i = 0; i < l; i++) {         if (str[i] == '0') {           for (j = i; j < l; j++)             str[j] = '9';           str[i - 1] = (char)(str[i - 1] - 1);           break;         }       }       if (!containszero(l)) {         for (i = l - 1; i > 0; i--) {           if (str[i] < str[i - 1]) {             for (j = i; j < l; j++)               str[j] = '9';             str[i - 1] = (char)(str[i - 1] - 1);           }         }       }     }     printf("Case #%d: ", c++);     i = 0;     while (str[i] == '0') {       i++;       continue;     }     while (i < l) {       cout << str[i++];     }     printf("\n");   }   return (0); }
#include <bitset> #include <deque> #include <iomanip> #include <iostream> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std;  
typedef set<int> si; typedef long double LD; typedef vector<int> VI; typedef vector<VI> vvi; typedef pair<int, int> PII; typedef vector<PII> vii; typedef vector<string> vs;  typedef long long LL;            typedef unsigned long long ull;  typedef unsigned uint;   struct debugger {};  char N[50];  bool containszero(int l) {   int i = 0;   while (N[i] == '0') {     i++;   }   while (i < l) {     if (N[i] == '0')       return true;     i++;   }   return false; } inline void dlhohwnnps(int &i, int &l, int &j) {   j = i;   while (j < l) {     N[j] = '9';     j++;   } }  inline void cuhzjglgaj(int &l, int &j, int &i) {   for (j = i; j < l; j++)     N[j] = '9';   N[i - 1] = (char)(N[i - 1] - 1); }  
int main() {   ios::sync_with_stdio(false);    freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_16_Usenix_RF_1.0_True_MCTS_Classic_True/try/lazyBit/A-small-practice.in",           "r", stdin);    freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_16_Usenix_RF_1.0_True_MCTS_Classic_True/try/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);     int n, i, j, k, l, m, t, s = 0, d;   scanf("%d", &t);   ;   int c = 1;   while (t--) {     scanf("%s ", N);     int p = 0;     l = strlen(N);     if (!containszero(l)) {       for (i = l - 1; i > 0; i--) {         if (N[i] < N[i - 1]) {           dlhohwnnps(i, l, j);           N[i - 1] = (char)(N[i - 1] - 1);         }       }     }     while (containszero(l)) {       for (i = 0; i < l; i++) {         if (N[i] == '0') {           for (j = i; j < l; j++)             N[j] = '9';           N[i - 1] = (char)(N[i - 1] - 1);           break;         }       }       if (!containszero(l)) {         for (i = l - 1; i > 0; i--) {           if (N[i] < N[i - 1])             cuhzjglgaj(l, j, i);         }       }     }     printf("Case #%d: ", c++);     i = 0;     while (N[i] == '0') {       i++;       continue;     }     while (i < l) {       printf("%c", N[i++]);     }     printf("\n");   }   return (0); }
#include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std; 
ifstream fin;  typedef set<int> si; typedef vector<int> VI; typedef vector<VI> vvi; typedef pair<int, int> PII; typedef vector<PII> vii; typedef vector<string> vs;  typedef long long LL;            typedef unsigned long long ull;  typedef unsigned uint;  const double pi = acos(-1.0);  const double eps = 1e-11;      const int MAXI = 0x7fffffff; const int dx[] = {1, 0, -1, 0}; const int dy[] = {0, 1, 0, -1}; const char dz[] = "SENW"; struct debugger {   template <typename T> debugger &solve(const T &v) {     cerr << v << " ";     return *this;   } } dbg;  void get(int *arr, int n) {   printf("[");   for (int i = 0; i < n; i++)     printf("%d ", arr[i]);   printf("]\n"); }  char str[50];  bool containszero(int l) {   int i = 0;   while (str[i] == '0')     i++;    while (i < l) {     if (str[i] == '0')       return true;     i++;   }   return false; } inline void ezhoxjffmh(int &i, int &l, int &j) {   j = i;   while (j < l) {     str[j] = '9';     j++;   } }  inline void lgqhrjrjwh(int &l, int &j, int &i) {   for (j = i; j < l; j++) {     str[j] = '9';   }   str[i - 1] = (char)(str[i - 1] - 1); }  
int main() {   fin.open("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_16_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/lazyBit/A-small-practice.in");     int n, i, j, k, l, m, t, s = 0, d;   fin >> t;   ;   int c = 1;   while (t--) {     fin >> str;     int p = 0;     l = strlen(str);     if (!containszero(l)) {       for (i = l - 1; i > 0; i--) {         if (str[i] < str[i - 1]) {           ezhoxjffmh(i, l, j);           str[i - 1] = (char)(str[i - 1] - 1);         }       }     }     while (containszero(l)) {       for (i = 0; i < l; i++) {         if (str[i] == '0') {           for (j = i; j < l; j++)             str[j] = '9';           str[i - 1] = (char)(str[i - 1] - 1);           break;         }       }       if (!containszero(l)) {         for (i = l - 1; i > 0; i--) {           if (str[i] < str[i - 1])             lgqhrjrjwh(l, j, i);         }       }     }     printf("Case #%d: ", c++);     i = 0;     while (str[i] == '0') {       i++;       continue;     }     while (i < l)       printf("%c", str[i++]);      printf("\n");   }   return (0); }
#include <bitset> #include <deque> #include <iomanip> #include <iostream> #include <queue> #include <set> #include <sstream> #include <stack>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std; 
const double EPS = 1e-9;  typedef vector<int> vi; typedef vector<vi> vvi; typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long LL;            typedef unsigned long long ULL;  typedef unsigned uint;    struct debugger {   template <typename T> debugger &operator,(const T &v) {     cerr << v << " ";     return *this;   } };  void solve(int *arr, int n) {   cout << "[";   for (int i = 0; i < n; i++)     cout << arr[i] << " ";   cout << "]" << endl; }  char N[50];  bool containszero(int x) {   int i = 0;   while (N[i] == '0') {     i++;   }   while (i < x) {     if (N[i] == '0') {       return 1;     }     i++;   }   return false; } 
int main() {   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_16_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);    int n, i, j, q, x, a, t, s = 0, d;   cin >> t;   ;   int c = 1;   while (t--) {     cin >> N;     bool p = 0;     x = strlen(N);     if (!containszero(x)) {       for (i = x - 1; i > 0; i--) {         if (N[i] < N[i - 1]) {           for (j = i; j < x; j++)             N[j] = '9';           N[i - 1] = (char)(N[i - 1] - 1);         }       }     }     while (containszero(x)) {       {         i = 0;         while (i < x) {           if (N[i] == '0') {             for (j = i; j < x; j++)               N[j] = '9';             N[i - 1] = (char)(N[i - 1] - 1);             break;           }           i++;         }       }       if (!containszero(x)) {         for (i = x - 1; i > 0; i--) {           if (N[i] < N[i - 1]) {             for (j = i; j < x; j++)               N[j] = '9';             N[i - 1] = (char)(N[i - 1] - 1);           }         }       }     }     printf("Case #%d: ", c++);     i = 0;     while (N[i] == '0') {       i++;       continue;     }     while (i < x) {       cout << N[i++];     }     printf("\n");   }   return (0); }
#include <algorithm> #include <cassert> #include <cctype> #include <cstdio> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stdio.h> #include <stdlib.h> #include <unordered_map> #include <vector>  using namespace std;  
inline void get(int &p, std::string &str) {   int i = p + 1;   while (i < str.length()) {     str[i] = '9';     i++;   } }  int solve(int cc) {   string str;   cin >> str;   int p = 0;   while (p < str.length() - 1) {     if (str[p] > str[p + 1]) {       break;     }     p++;   }   if (p == str.length() - 1) {     printf("Case #%d: %s\n", cc, str.c_str());     return 1;   }   while (p > 0 && str[p - 1] == str[p]) {     p--;   }   str[p] = str[p] - 1;   get(p, str);   if (str[0] == '0') {     str.erase(str.begin());   }   printf("Case #%d: %s\n", cc, str.c_str());   return 1; }  inline void wjxwywmwfd(int &t) {   int i = 0;   while (i < t) {     solve(i + 1);     i++;   } }  
int main() {   ios::sync_with_stdio(true);    freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_17_Usenix_RF_1.0_True_MCTS_Classic_True/try/Thanabhat/A-small-practice.in",           "r", stdin);    int t;   scanf("%d ", &t);   wjxwywmwfd(t);   return 0; }
#include <bits/stdc++.h> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <ctime> #include <fstream> #include <iostream> #include <iterator> #include <list> #include <numeric> #include <queue> #include <set> #include <stdio.h> #include <stdlib.h> #include <utility> #include <vector>  using namespace std;  
ifstream fin;  inline void mvpflsivil(std::string &str, int &get) { str[get] = '9'; }  int solve(int b) {   int ret_val = 1;   string str;   fin >> str;   int p = 0;   while (p < str.length() - 1) {     if (str[p] > str[p + 1]) {       break;     }     p++;   }   if (p == str.length() - 1) {     int ret_val = 1;     printf("Case #%d: %s\n", b, str.c_str());     return ret_val;   }   while (p > 0 && str[p - 1] == str[p]) {     p--;   }   str[p] = str[p] - 1;   int get;   for (get = p + 1; get < str.length(); get++) {     mvpflsivil(str, get);   }   if (str[0] == '0') {     str.erase(str.begin());   }   printf("Case #%d: %s\n", b, str.c_str());   return ret_val; }  
int main() {   int ret_val = 0;   ios::sync_with_stdio(0);   fin.open("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_17_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Thanabhat/A-small-practice.in");   int t;   fin >> t;   {     int get = 0;     while (get < t) {       solve(get + 1);       get++;     }   }   return ret_val; }
#include <cassert> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <numeric> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map>  using namespace std;
const double EPS = 1e-9;  inline void jzuygfcmmv(std::string &str, int &i) { str[i] = '9'; }  int get(int cc) {   string str;   cin >> str;   int p = 0;   while (p < str.length() - 1) {     if (str[p] > str[p + 1]) {       break;     }     p++;   }   if (p == str.length() - 1) {     cout << "Case #" << cc << ": " << str << endl;     return 1;   }   for (; p > 0 && str[p - 1] == str[p];) {     p--;   }   str[p] = str[p] - 1;   for (int i = p + 1; i < str.length(); i++)     jzuygfcmmv(str, i);   if (str[0] == '0') {     str.erase(str.begin());   }   cout << "Case #" << cc << ": " << str << endl;   return 1; }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_17_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/Thanabhat/outer_temp/Thanabhat/A-small-practice_transformation.out",           "w", stdout);    int t;   scanf("%d ", &t);   for (int i = 0; i < t; i++) {     get(i + 1);   }   return 0; }
#include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cstdio> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <queue> #include <stdio.h> #include <stdlib.h> #include <vector>  using namespace std; 
int solve(int cc) {   string str;   cin >> str;   int p = 0;   while (p < str.length() - 1) {     if (str[p] > str[p + 1]) {       break;     }     p++;   }   if (p == str.length() - 1) {     cout << "Case #" << cc << ": " << str << endl;     return 1;   }   while (p > 0 && str[p - 1] == str[p]) {     p--;   }   str[p] = str[p] - 1;   for (int i = p + 1; i < str.length(); i++) {     str[i] = '9';   }   if (str[0] == '0') {     str.erase(str.begin());   }   cout << "Case #" << cc << ": " << str << endl;   return 1; }  
int main() {   int get;   cin >> get;   {     int i = 0;     while (i < get) {       solve(i + 1);       i++;     }   }   return 0; }
#include <bits/stdc++.h>  using namespace std; 
bool check(int n) {   while (n > 0) {     if (n % 10 < n / 10 % 10) {       return false;     }     n /= 10;   }   return true; }  inline void oxvomebmvp(int &solve) { --solve; }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_18_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/fragusbot/A-small-practice.in",           "r", stdin);    int t;   scanf("%d", &t);   for (int q = 1; q <= t; ++q) {     printf("Case #%d: ", q);     int n;     scanf("%d", &n);     int solve = n;     while (!check(solve))       oxvomebmvp(solve);     printf("%d\n", solve);   } }
#include <algorithm> #include <bits/stdc++.h> #include <climits> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <string> #include <utility>  using namespace std; 
const long double PI = 3.1415926535897932384626433832795; const double eps = 1e-9;  bool check(int n) {   while (n > 0) {     if (n % 10 < n / 10 % 10) {       return false;     }     n /= 10;   }   return true; }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_18_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/fragusbot/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_18_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/fragusbot/outer_temp/fragusbot/A-small-practice_transformation.out",           "w", stdout);   int tt;   cin >> tt;   for (int cc = 1; cc <= tt; ++cc) {     printf("Case #%d: ", cc);     int n;     cin >> n;     int ans = n;     while (!check(ans)) {       --ans;     }     printf("%d\n", ans);   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <numeric> #include <stdio.h> #include <unordered_map> #include <vector>  using namespace std;
ofstream fout;  const int INF = 1000000000;  bool check(int n) {   while (n > 0) {     if (n % 10 < n / 10 % 10) {       return false;     }     n /= 10;   }   return true; }  
int main() {   ios::sync_with_stdio(false);    fout.open("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_18_Usenix_RF_1.0_True_MCTS_Classic_True/WCG/fragusbot/outer_temp/fragusbot/A-small-practice_transformation.out");    int tt;   cin >> tt;   for (int cc = 1; cc <= tt; ++cc) {     fout << "Case #" << cc << ": ";     int n;     cin >> n;     int ans = n;     while (!check(ans)) {       --ans;     }     fout << ans << "\n";   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <set> #include <utility> #include <vector>  using namespace std; 
typedef vector<int> VI; typedef long double LD; typedef long long LL; typedef pair<int, int> ii; typedef pair<int, int> PII;  inline bool skgtuctgni(_Bool &get) {   get = false;   return true;   return false; }  bool solve(int n) {   for (; n > 0;) {     if (n % 10 < n / 10 % 10) {       _Bool get;       if (skgtuctgni(get))         return get;     }     n /= 10;   }   return true; }  
int main() {   ios::sync_with_stdio(false);   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_18_Usenix_RF_1.0_True_MCTS_Classic_True/bennikartefla/fragusbot/A-small-practice.in",           "r", stdin);   int j;   cin >> j;   for (int cc = 1; cc <= j; ++cc) {     printf("Case #%d: ", cc);     int n;     cin >> n;     int ans = n;     for (; !solve(ans);) {       --ans;     }     printf("%d\n", ans);   }   return 0; }
#include <algorithm> #include <bitset> #include <cstdio> #include <cstring> #include <iostream> #include <map> #include <set> #include <string> #include <vector>  using namespace std; 
const long long inf = 1000000000000000000LL;  vector<long long> res;  void rec(long long value, long long d) {   if (value >= inf) {     return;   }   res.push_back(value);   for (long long i = d; i <= 9; ++i) {     if (value < inf / 10LL) {       rec(value * 10LL + i, i);     }   } }  void solve(int test) {   long long n;   cin >> n;    int index = upper_bound(res.begin(), res.end(), n) - res.begin() - 1;   printf("Case #%d: %lld\n", test, res[index]); }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_19_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/sdya/A-small-practice.in",           "r", stdin);    for (int i = 1; i <= 9; ++i) {     rec(i, i);   }    sort(res.begin(), res.end());   cerr << "Res size: " << res.size() << endl;    int get;   scanf("%d", &get);   for (int i = 0; i < get; ++i) {     solve(i + 1);     cerr << i + 1 << ": " << clock() << endl;   }    return 0; }
#include <algorithm> #include <bitset> #include <cstdio> #include <cstring> #include <iomanip> #include <iostream> #include <map> #include <set> #include <string> #include <vector>  using namespace std; 
const int MOD = 1000000007;  const long long inf = 1000000000000000000LL;  vector<long long> res;  void rec(long long value, long long d) {   if (value >= inf) {     return;   }   res.push_back(value);   long long i;   for (i = d; i <= 9; ++i) {     if (value < inf / 10LL) {       rec(value * 10LL + i, i);     }   } }  void get(int test) {   long long n;   cin >> n;    int index = upper_bound(res.begin(), res.end(), n) - res.begin() - 1;   cout << "Case #" << test << ": " << res[index] << "\n"; }  
int main() {    int i;   for (i = 1; i <= 9; ++i) {     rec(i, i);   }    sort(res.begin(), res.end());   cerr << "Res size: " << res.size() << endl;    int t;   scanf("%d", &t);   for (int i = 0; i < t; ++i) {     get(i + 1);     cerr << i + 1 << ": " << clock() << endl;   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <cmath> #include <cstdio> #include <cstring> #include <fstream> #include <iostream> #include <iterator> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
const int INF = 1000000000;  typedef set<int> si; typedef vector<vector<int>> vvi; typedef long double ld; typedef long long ll; typedef long long LL; typedef pair<int, int> ii; typedef pair<int, int> PII;  const long long inf = 1000000000000000000LL;  vector<long long> j;  inline bool kikbzpvypa() {   return true;   return false; }  inline bool foilbglhpp() {   return true;   return false; }  void rec(long long value, long long d) {   if (value >= inf) {     if (kikbzpvypa()) {       if (foilbglhpp()) {         return;       }     }   }   j.push_back(value);   for (LL i = d; i <= 9; ++i) {     if (value < inf / 10LL) {       rec(value * 10LL + i, i);     }   } }  void get(int test) {   LL n;   cin >> n;    int index = upper_bound(j.begin(), j.end(), n) - j.begin() - 1;   printf("Case #%d: %lld\n", test, j[index]); }  inline void wlhqerwcyt(int &i) {   get(i + 1);   cerr << i + 1 << ": " << clock() << endl;   ++i; }  
int main() {   ios::sync_with_stdio(true);    for (int i = 1; i <= 9; ++i) {     rec(i, i);   }    sort(j.begin(), j.end());   cerr << "Res size: " << j.size() << endl;    int t;   cin >> t;   {     int i = 0;     while (i < t)       wlhqerwcyt(i);   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cstdio> #include <cstring> #include <iostream> #include <map> #include <set> #include <string> #include <utility> #include <vector>  using namespace std; 
typedef pair<int, int> ii; typedef long long ll; typedef long long LL;  const long long inf = 1000000000000000000LL;  vector<long long> res;  void rec(long long value, long long d) {   if (value >= inf) {     return;   }   res.push_back(value);   for (LL i = d; i <= 9; ++i) {     if (value < inf / 10LL) {       rec(value * 10LL + i, i);     }   } }  void open(int test) {   LL n;   cin >> n;    int index = upper_bound(res.begin(), res.end(), n) - res.begin() - 1;   printf("Case #%d: %lld\n", test, res[index]); }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_19_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sdya/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_3264486_5633382285312000_19_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sdya/outer_temp/sdya/A-small-practice_transformation.out",           "w", stdout);    for (int i = 1; i <= 9; ++i) {     rec(i, i);   }    sort(res.begin(), res.end());   cerr << "Res size: " << res.size() << endl;    int t;   scanf("%d", &t);   for (int i = 0; i < t; ++i) {     open(i + 1);     cerr << i + 1 << ": " << clock() << endl;   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <unordered_map> #include <utility> #include <vector> using namespace std;
const long double PI = 3.1415926535897932384626433832795; const double eps = 1e-9; const double EPS = 1e-9;  int tc;  inline void fnmtvdxrzg(int &d, priority_queue<int> &pq, int &z) {   int get = pq.top() - 1;   pq.pop();   d = get / 2 + (get % 2);   z = get / 2;   pq.push(d);   pq.push(z); }  inline void bqpshyuesl(int &get) {   int c, ans;   cin >> c >> ans;   priority_queue<int> pq;   pq.push(c);   int d, z;   for (int i = 0; i < ans; i++)     fnmtvdxrzg(d, pq, z);   printf("Case #%d: %d %d\n", get, d, z); }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_1_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/4yn/outer_temp/4yn/A-small-practice_transformation.out",           "w", stdout);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_1_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/4yn/A-small-practice.in",           "r", stdin);   cin >> tc;   for (int get = 1; get <= tc; get++)     bqpshyuesl(get);   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <math.h> #include <numeric> #include <set> #include <sstream> #include <stdio.h> #include <string> #include <utility> using namespace std;
const int MAXN = 1005; ofstream fout;  const int INF = 1000000000; const int MOD = 1000000007; const double eps = 1e-9; typedef long long int lli;  int tc;  inline void fmajsbqeqd(int &y, priority_queue<int> &pq, int &z, int &i) {   int t = pq.top() - 1;   pq.pop();   y = t / 2 + (t % 2);   z = t / 2;   pq.push(y);   pq.push(z);   i++; }  inline void metjxthmio(int &get, int &y, priority_queue<int> &pq, int &z) {   int i = 0;   while (i < get) {     fmajsbqeqd(y, pq, z, i);   } }  
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_1_Usenix_RF_1.0_True_MCTS_Classic_True/WCG/4yn/outer_temp/4yn/A-small-practice_transformation.out");    cin >> tc;   for (int t = 1; t <= tc; t++) {     int solve, get;     cin >> solve >> get;     priority_queue<int> pq;     pq.push(solve);     int y, z;     metjxthmio(get, y, pq, z);     fout << "Case #" << t << ": " << y << " " << z << "\n";   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <set> #include <vector> using namespace std; 
const int mod = 1000000007; typedef long double ld; typedef vector<int> vi; typedef long double LD; typedef set<int> si; typedef long long ll; typedef pair<ll, ll> pii;  int tc;  
int main() {   ios::sync_with_stdio(false);    cin >> tc;   int t;   for (t = 1; t <= tc; t++) {     int n, k;     cin >> n >> k;     priority_queue<int> pq;     pq.push(n);     int y, z;     int i;     for (i = 0; i < k; i++) {       int t = pq.top() - 1;       pq.pop();       y = t / 2 + (t % 2);       z = t / 2;       pq.push(y);       pq.push(z);     }     printf("Case #%d: %d %d\n", t, y, z);   } }
#include <bits/stdc++.h> #include <stdio.h> #include <utility> #include <vector> using namespace std; 
typedef pair<int, int> ii; typedef vector<int> vi; typedef long long ll; typedef pair<ll, ll> pii;  int tc;  inline void uwmrmqvpkw(int &y, priority_queue<int> &pq, int &z) {   int t = pq.top() - 1;   pq.pop();   y = t / 2 + (t % 2);   z = t / 2;   pq.push(y);   pq.push(z); }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_1_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/4yn/outer_temp/4yn/A-small-practice_transformation.out",           "w", stdout);    scanf("%d ", &tc);   for (int t = 1; t <= tc; t++) {     int n, k;     scanf("%d %d ", &n, &k);     priority_queue<int> pq;     pq.push(n);     int y, z;     for (int i = 0; i < k; i++)       uwmrmqvpkw(y, pq, z);     printf("Case #%d: %d %d\n", t, y, z);   } }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility> #include <vector> using namespace std;
const double eps = 1e-9; typedef long double LD; typedef long long LL; typedef pair<int, int> PII; typedef pair<LL, LL> pll; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<LL> vll; typedef set<int> si;  const int N = 1002; int t, n, k;  inline void mvpyspbfdv(priority_queue<int, vi> &q) {   int x = q.top();   q.pop();   if (x / 2) {     q.push(x / 2);   }    if (x / 2 - (x % 2 == 0))     q.push(x / 2 - (x % 2 == 0)); }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_2_Usenix_RF_1.0_True_MCTS_Classic_True/WCG/KhaleD/A-small-practice.in",           "r", stdin);   cin >> t;   for (int j = (1); j <= (int)(t); ++j) {     cin >> n >> k;      priority_queue<int, vi> q;     q.push(n);     {       int i = (1);       while (i <= (int)(k - 1)) {         mvpyspbfdv(q);         ++i;       }     }      int x = q.top();     int y = max(x / 2, x / 2 - (x % 2 == 0)),         z = min(x / 2, x / 2 - (x % 2 == 0));     printf("Case #%d: %d %d\n", j, y, z);   }   return 0; } 
#include <bits/stdc++.h> #include <fstream> #include <iostream> using namespace std; 
const int INF = 1000000000;  typedef long double ld; typedef long long ll; typedef pair<int, int> PII; typedef pair<ll, ll> pll; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<ll> vll; typedef set<int> si; typedef map<int, int> mii;  int t, n, ans;  
int main() {   ios::sync_with_stdio(false);    cin >> t;   for (int p = (1); p <= (int)(t); ++p) {     cin >> n >> ans;      priority_queue<int, vi> q;     q.push(n);     int i;     for (i = (1); i <= (int)(ans - 1); ++i) {       int solve = q.top();       q.pop();       if (solve / 2)         q.push(solve / 2);       if (solve / 2 - (solve % 2 == 0))         q.push(solve / 2 - (solve % 2 == 0));     }      int solve = q.top();     int y = max(solve / 2, solve / 2 - (solve % 2 == 0)),         z = min(solve / 2, solve / 2 - (solve % 2 == 0));     printf("Case #%d: %d %d\n", p, y, z);   }   return 0; }  
#include <bits/stdc++.h> #include <iomanip> #include <iostream> using namespace std;
typedef long long ll; typedef pair<int, int> pii; typedef pair<ll, ll> pll; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<ll> vll; typedef set<int> si;  const int N = 1002; int t, n, k;  inline void anfeqnqegh(priority_queue<int, vi> &q) {   int x = q.top();   q.pop();   if (x / 2)     q.push(x / 2);   if (x / 2 - (x % 2 == 0))     q.push(x / 2 - (x % 2 == 0)); }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_2_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/KhaleD/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_2_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/KhaleD/outer_temp/KhaleD/A-small-practice_transformation.out",           "w", stdout);   scanf("%d", &t);   for (int testCase = (1); testCase <= (int)(t); ++testCase) {     scanf("%d%d", &n, &k);      priority_queue<int, vi> q;     q.push(n);     for (int i = (1); i <= (int)(k - 1); ++i)       anfeqnqegh(q);      int x = q.top();     int y = max(x / 2, x / 2 - (x % 2 == 0)),         z = min(x / 2, x / 2 - (x % 2 == 0));     cout << "Case #" << testCase << ": " << y << " " << z << "\n";   }   return 0; } 
#include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cmath> #include <complex> #include <ctime> #include <functional> #include <iomanip> #include <iostream> #include <list> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stdio.h> #include <stdlib.h> #include <unordered_map> #include <utility> #include <vector> using namespace std;
typedef long double ld; typedef unsigned long long ull; typedef long long LL; typedef pair<int, int> PII; typedef pair<LL, LL> pll; typedef vector<int> VI; typedef vector<VI> vvi; typedef vector<LL> vll; typedef set<int> si;  int t, n, k;  inline void avftyaufyf(int &T) {   scanf("%d %d ", &n, &k);    priority_queue<int, VI> q;   q.push(n);   for (int i = (1); i <= (int)(k - 1); ++i) {     int x = q.top();     q.pop();     if (x / 2)       q.push(x / 2);     if (x / 2 - (x % 2 == 0))       q.push(x / 2 - (x % 2 == 0));   }    int x = q.top();   int get = max(x / 2, x / 2 - (x % 2 == 0)),       z = min(x / 2, x / 2 - (x % 2 == 0));   cout << "Case #" << T << ": " << get << " " << z << "\n"; }  inline void hmznnsyxzm(int &T) {   avftyaufyf(T);   ++T; }  
int main() {   ios::sync_with_stdio(false);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_2_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/KhaleD/A-small-practice.in",           "r", stdin);    scanf("%d ", &t);   int T;   {     T = (1);     while (T <= (int)(t))       hmznnsyxzm(T);   }   return 0; } 
#include <bits/stdc++.h> #include <cmath> #include <complex> #include <cstdio> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility> #include <vector> using namespace std; 
const double EPS = 1e-9; ofstream fout;  typedef set<int> si; typedef vector<int> vi; typedef vector<vector<int>> vvi; typedef long double ld; typedef long long ll; typedef long long LL; typedef pair<int, int> pii; typedef pair<int, int> PII; typedef unsigned long long ull;  priority_queue<int> Q, E; int n, tc;  
int main() {   ios::sync_with_stdio(false);    fout.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_3_Usenix_RF_1.0_True_MCTS_Classic_True/bennikartefla/try/outer_temp/try/A-small-practice_transformation.out");    int c, t, get, v, y, z;   scanf("%d", &t);   {     c = 0;     while (c < t) {       scanf("%d %d", &n, &tc);       Q = E;       Q.push(n);       {         get = 0;         while (get < tc) {           v = Q.top();           Q.pop();           y = v / 2;           z = (v - 1) / 2;           Q.push(y);           Q.push(z);           get++;         }       }       fout << "Case #" << c + 1 << ": " << y << " " << z << "\n";       c++;     }   }   return 0; }
#include <bits/stdc++.h> #include <cstdio> #include <functional> #include <iostream> #include <queue> using namespace std; 
typedef long long ll; typedef long long LL;  priority_queue<int> Q, E; int n, k;  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_3_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/try/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_3_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/try/outer_temp/try/A-small-practice_transformation.out",           "w", stdout);   int c, t, x, y, z;   scanf("%d", &t);   for (c = 0; c < t; c++) {     scanf("%d %d", &n, &k);     Q = E;     Q.push(n);     for (int i = 0; i < k; i++) {       x = Q.top();       Q.pop();       y = x / 2;       z = (x - 1) / 2;       Q.push(y);       Q.push(z);     }     printf("Case #%d: %d %d\n", c + 1, y, z);   }   return 0; }
#include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
typedef pair<int, int> pii; typedef unsigned long long ull; typedef vector<int> VI; typedef set<int> si;  priority_queue<int> Q, E; int n, q;  inline void gxcqubpnpl(int &t, int &i, int &j, int &y, int &N, int &T) {   T = 0;   while (T < t) {     scanf("%d %d", &n, &q);     Q = E;     Q.push(n);     {       i = 0;       for (; i < q;) {         j = Q.top();         Q.pop();         y = j / 2;         N = (j - 1) / 2;         Q.push(y);         Q.push(N);         i++;       }     }     printf("Case #%d: %d %d\n", T + 1, y, N);     T++;   } }  
int main() {   ios::sync_with_stdio(false);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_3_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/try/A-small-practice.in",           "r", stdin);    int T, t, i, j, y, N;   scanf("%d", &t);   gxcqubpnpl(t, i, j, y, N, T);   return 0; }
#include <cassert> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <ctime> #include <deque> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const int MOD = 1000000007;  priority_queue<int> Q, E; int n, k;  inline void ljmtwzrlfy(int &x, int &y, int &z) {   x = Q.top();   Q.pop();   y = x / 2;   z = (x - 1) / 2;   Q.push(y);   Q.push(z); }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_3_Usenix_RF_1.0_True_MCTS_Classic_True/kuzphi/try/A-small-practice.in",           "r", stdin);    int t, x, y, z;   cin >> t;   for (int c = 0; c < t; c++) {     cin >> n >> k;     Q = E;     Q.push(n);     for (int i = 0; i < k; i++)       ljmtwzrlfy(x, y, z);     printf("Case #%d: %d %d\n", c + 1, y, z);   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> #include <vector> using namespace std; 
typedef long long ll; typedef vector<int> vi;  ofstream fout("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_4_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  void open() {   int k, n;   scanf("%d %d ", &k, &n);   map<int, int> ct;   ct[k] = 1;   for (int tc = 1; tc < n; tc++) {     auto p = *(ct.rbegin());     if (p.second == 1)       ct.erase(p.first);     else       ct[p.first]--;      ct[(p.first - 1) / 2]++;     ct[p.first - 1 - (p.first - 1) / 2]++;   }   fout << ct.rbegin()->first / 2 << ' ' << (ct.rbegin()->first - 1) / 2 << '\n'; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_4_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sammyMaX/A-small-practice.in",           "r", stdin);   int t;   scanf("%d ", &t);   for (int tc = 0; tc < t; tc++)     fout << "Case #" << tc + 1 << ": ", open();   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <set> #include <utility> #include <vector> using namespace std; 
const double eps = 1e-9;  typedef long long LL; typedef pair<int, int> PII; typedef vector<int> vi; typedef vector<int> VI; typedef long double ld; typedef vector<vector<int>> vvi;  ifstream b("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_4_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/sammyMaX/A-small-practice.in"); ofstream T("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_4_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  void N() {   int k, n;   b >> k >> n;   map<int, int> ct;   ct[k] = 1;   {     int i = 1;     while (i < n) {       auto p = *(ct.rbegin());       if (p.second == 1)         ct.erase(p.first);       else         ct[p.first]--;        ct[(p.first - 1) / 2]++;       ct[p.first - 1 - (p.first - 1) / 2]++;       i++;     }   }   T << ct.rbegin()->first / 2 << ' ' << (ct.rbegin()->first - 1) / 2 << '\n'; }  
int main() {   ios::sync_with_stdio(0);   int q;   b >> q;   int i;   for (i = 0; i < q; i++) {     T << "Case #" << i + 1 << ": ", N();   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const double eps = 1e-9; const int mod = 1000000007;  void solve() {   int k, n;   cin >> k >> n;   map<int, int> ct;   ct[k] = 1;   {     int get = 1;     while (get < n) {       auto p = *(ct.rbegin());       if (p.second == 1)         ct.erase(p.first);       else         ct[p.first]--;        ct[(p.first - 1) / 2]++;       ct[p.first - 1 - (p.first - 1) / 2]++;       get++;     }   }   printf("%d %d\n", ct.rbegin()->first / 2, (ct.rbegin()->first - 1) / 2); }  
int main() {   int t;   cin >> t;   for (int get = 0; get < t; get++) {     printf("Case #%d: ", get + 1), solve();   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const int MOD = 1000000007; const long double PI = 3.1415926535897932384626433832795; const double eps = 1e-9; const double EPS = 1e-9;  ifstream b("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_4_Usenix_RF_1.0_True_MCTS_Classic_True/ibrahim5253/sammyMaX/A-small-practice.in"); ofstream x("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_4_Usenix_RF_1.0_True_MCTS_Classic_True/ibrahim5253/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  inline void dnatxwsoic(map<int, int> &ct) {   auto p = *(ct.rbegin());   if (p.second == 1)     ct.erase(p.first);   else     ct[p.first]--;    ct[(p.first - 1) / 2]++;   ct[p.first - 1 - (p.first - 1) / 2]++; }  void get() {   int k, n;   b >> k >> n;   map<int, int> ct;   ct[k] = 1;   for (int i = 1; i < n; i++)     dnatxwsoic(ct);   x << ct.rbegin()->first / 2 << ' ' << (ct.rbegin()->first - 1) / 2 << '\n'; }  
int main() {   ios::sync_with_stdio(false);    int t;   b >> t;   for (int i = 0; i < t; i++)     x << "Case #" << i + 1 << ": ", get();   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
typedef long long td_ll;  const long double PI = 3.1415926535897932384626433832795; const double EPS = 1e-9; const double eps = 1e-9; const int mod = 1000000007;  struct node {   long long u, v;   node(int _u = 0, int _v = 0) : u(_u), v(_v) {}   bool operator<(const node &r) const { return u < r.u; } };  inline void dmeshkwnei(long long &sum, long long &l,                        map<long long, long long> &f, long long &r) {   td_ll T = f.rbegin()->first, v = f.rbegin()->second;   f.erase(T);   sum += v;   l = (T - 1) / 2;   r = T / 2;   f[l] += v;   f[r] += v; }  void work() {   td_ll n, k;   scanf("%lld %lld ", &n, &k);   map<long long, long long> f;   f[n] = 1;   td_ll sum = 0;   td_ll l = (n - 1) / 2, r = n / 2;   while (sum < k) {     dmeshkwnei(sum, l, f, r);   }   cout << r << ' ' << l << endl; }  
int main() {    ios::sync_with_stdio(true);    int q;   scanf("%d ", &q);   for (int i = 1; i <= q; ++i) {     cout << "Case #" << i << ": ";     work();   }   return 0; }
#include <algorithm> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
const int MOD = 1000000007;  struct node {   long long u, v;   node(int _u = 0, int _v = 0) : u(_u), v(_v) {}   bool x(const node &r) const { return u < r.u; } };  void T() {   long long n, d;   cin >> n >> d;   map<long long, long long> f;   f[n] = 1;   long long sum = 0;   long long l = (n - 1) / 2, r = n / 2;   while (sum < d) {     long long y = f.rbegin()->first, v = f.rbegin()->second;     f.erase(y);     sum += v;     l = (y - 1) / 2;     r = y / 2;     f[l] += v;     f[r] += v;   }   cout << r << ' ' << l << endl; }  
int main() {    int q;   cin >> q;   for (int i = 1; i <= q; ++i) {     printf("Case #%d: ", i);     T();   }   return 0; }
#include <bitset> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <fstream> #include <functional> #include <iostream> #include <list> #include <map> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
typedef long long ll; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef unsigned long long ull; typedef long double LD; typedef vector<vector<int>> vvi;  struct node {   long long u, v;   node(int _u = 0, int _v = 0) : u(_u), v(_v) {}   bool operator<(const node &r) const { return u < r.u; } };  inline void mhftjifatn(ll &sum, ll &l, map<long long, long long> &f, ll &r) {   ll N = f.rbegin()->first, v = f.rbegin()->second;   f.erase(N);   sum += v;   l = (N - 1) / 2;   r = N / 2;   f[l] += v;   f[r] += v; }  void solve() {   ll n, k;   cin >> n >> k;   map<long long, long long> f;   f[n] = 1;   ll sum = 0;   ll l = (n - 1) / 2, r = n / 2;   for (; sum < k;)     mhftjifatn(sum, l, f, r);   printf("%lld %lld\n", r, l); }  inline void eviduydbre(int &i) {   printf("Case #%d: ", i);   solve(); }  
int main() {   ios::sync_with_stdio(true);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_5_Usenix_RF_1.0_True_MCTS_Classic_True/ibrahim5253/Tashi711/A-small-practice.in",           "r", stdin);    int q;   cin >> q;   for (int i = 1; i <= q; ++i) {     eviduydbre(i);   }   return 0; }
#include <bits/stdc++.h> #include <cstdio> #include <iostream> #include <map> #include <stdio.h> #include <string> #include <vector>  using namespace std;
struct node {   long long u, v;   node(int _u = 0, int _v = 0) : u(_u), v(_v) {}   bool operator<(const node &r) const { return u < r.u; } };  void do_voicaa_fct() {   long long n, cas;   cin >> n >> cas;   map<long long, long long> f;   f[n] = 1;   long long sum = 0;   long long l = (n - 1) / 2, r = n / 2;   while (sum < cas) {     long long m = f.rbegin()->first, uddt_Var = f.rbegin()->second;     f.erase(m);     sum += uddt_Var;     l = (m - 1) / 2;     r = m / 2;     f[l] += uddt_Var;     f[r] += uddt_Var;   }   printf("%lld %lld\n", r, l); }  
int main() {    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_5_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/Tashi711/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_5_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/Tashi711/outer_temp/Tashi711/A-small-practice_transformation.out",           "w", stdout);   int ans;   cin >> ans;    {     int i = 1;     while (i <= ans) {       printf("Case #%d: ", i);       do_voicaa_fct();       ++i;     }   }   return 0; }
#include <algorithm> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <unordered_map> #include <vector> using namespace std; 
const double eps = 1e-9; const double EPS = 1e-9;  inline void T(int &tc) {   int s = 1;   for (; s <= tc;) {     long long n, i, j, z;     map<long long, long long> m;     queue<long long> q;     cin >> n >> i;      q.push(n);     m[n] = 1;      for (; i > 0;) {       long long c = q.front();       q.pop();       j = c / 2;       z = (c - 1) / 2;       i -= m[c];       if (m.find(j) == m.end())         q.push(j);       m[j] += m[c];       if (m.find(z) == m.end())         q.push(z);       m[z] += m[c];     }      printf("Case #%d: %lld %lld\n", s, j, z);     ++s;   } }  int main() {   int tc;    cin >> tc;    T(tc);    return 0; }
#include <algorithm> #include <bitset> #include <cassert> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <deque> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
typedef long long ll; typedef pair<int, int> pii; typedef unsigned long long ull; typedef vector<int> vi; typedef vector<int> VI; typedef long double LD;  inline void nvnyfseepe(ll &k, ll &y, queue<long long> &q, ll &z,                        map<long long, long long> &m) {   ll c = q.front();   q.pop();   y = c / 2;   z = (c - 1) / 2;   k -= m[c];   if (m.find(y) == m.end())     q.push(y);   m[y] += m[c];   if (m.find(z) == m.end())     q.push(z);   m[z] += m[c]; }  
int main() {   ios::sync_with_stdio(false);    int tt;    cin >> tt;    for (int t = 1; t <= tt; ++t) {     ll n, k, y, z;     map<long long, long long> m;     queue<long long> q;     cin >> n >> k;      q.push(n);     m[n] = 1;      while (k > 0)       nvnyfseepe(k, y, q, z, m);      cout << "Case #" << t << ": " << y << " " << z << endl;   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <iostream> #include <map> #include <queue> #include <stdio.h> using namespace std; 
typedef long long td_ll;  inline void ihgpzbphse(queue<long long> &waiq_Var, td_ll &i) {   waiq_Var.push(i); }  inline void vivmskeghl(int &cas) {   td_ll n, ans, i, z;   map<long long, long long> m;   queue<long long> waiq_Var;   cin >> n >> ans;    waiq_Var.push(n);   m[n] = 1;    while (ans > 0) {     td_ll c = waiq_Var.front();     waiq_Var.pop();     i = c / 2;     z = (c - 1) / 2;     ans -= m[c];     if (m.find(i) == m.end()) {       ihgpzbphse(waiq_Var, i);     }     m[i] += m[c];     if (m.find(z) == m.end())       waiq_Var.push(z);     m[z] += m[c];   }    printf("Case #%d: %lld %lld\n", cas, i, z); }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_6_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/WCG/outer_temp/WCG/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_6_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/WCG/A-small-practice.in",           "r", stdin);    int r;    cin >> r;    for (int cas = 1; cas <= r; ++cas)     vivmskeghl(cas);    return 0; }
#include <algorithm> #include <cstdio> #include <cstring> #include <iostream> #include <map> #include <queue> #include <stdio.h> #include <vector> using namespace std; 
typedef long long td_ll;  inline void qcigjziwcl(long long &ans, long long &gfel_Var,                        queue<long long> &uxmq_Var, long long &z,                        map<long long, long long> &m) {   td_ll c = uxmq_Var.front();   uxmq_Var.pop();   gfel_Var = c / 2;   z = (c - 1) / 2;   ans -= m[c];   if (m.find(gfel_Var) == m.end())     uxmq_Var.push(gfel_Var);   m[gfel_Var] += m[c];   if (m.find(z) == m.end())     uxmq_Var.push(z);   m[z] += m[c]; }  inline void eislakkfep(int &tt, int &t) {   t = 1;   while (t <= tt) {     td_ll s, ans, gfel_Var, z;     map<long long, long long> m;     queue<long long> uxmq_Var;     scanf("%lld %lld ", &s, &ans);      uxmq_Var.push(s);     m[s] = 1;      for (; ans > 0;) {       qcigjziwcl(ans, gfel_Var, uxmq_Var, z, m);     }      printf("Case #%d: %lld %lld\n", t, gfel_Var, z);     ++t;   } }  
int main() {   int tt;    scanf("%d ", &tt);    int t;   eislakkfep(tt, t);    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const double EPS = 1e-9; const int mod = 1000000007;  typedef pair<int, int> ii;  typedef long long ll; const int INF = ~(1 << 31); const double pi = acos(-1);  
int main() {   cin.sync_with_stdio(false);   ofstream t("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_7_Usenix_RF_1.0_True_MCTS_Classic_True/ibrahim5253/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out");   int n;   cin >> n;   int i;   {     i = (0);     while (i < (n)) {       priority_queue<int> k;       int y, b;       cin >> y >> b;       t << "Case #" << i + 1 << ": ";       k.push(y - 1);       for (int a = (0); a < (b - 1); a++) {         if (k.empty()) {           break;         } else {           int d = k.top();           k.pop();           if (d == 0)             continue;           int want = d / 2;           int first = want;           if (first != 0)             k.push(first - 1);           int second = d - want;           k.push(second - 1);         }       }       if (k.empty())         t << "0 0" << endl;       else {         int d = k.top();         if (d == 0)           t << "0 0" << endl;         else {           int first = d / 2;           t << d - first << " " << first << endl;         }       }       i++;     }   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> using namespace std;  
typedef pair<int, int> ii; typedef vector<int> vi;  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_7_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_7_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/bennikartefla/A-small-practice.in",           "r", stdin);    int n;   cin >> n;   {     int i = (0);     while (i < (n)) {       priority_queue<int> k;       int m, q;       cin >> m >> q;       printf("Case #%d: ", i + 1);       k.push(m - 1);       {         int ans = (0);         while (ans < (q - 1)) {           if (k.empty())             break;           else {             int cas = k.top();             k.pop();             if (cas == 0) {               ans++;               continue;             }             int want = cas / 2;             int first = want;             if (first != 0)               k.push(first - 1);             int second = cas - want;             k.push(second - 1);           }           ans++;         }       }       if (k.empty())         printf("0 0\n");       else {         int cas = k.top();         if (cas == 0)           printf("0 0\n");         else {           int first = cas / 2;           printf("%d %d\n", cas - first, first);         }       }       i++;     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <stdio.h> #include <vector> using namespace std; 
typedef pair<int, int> ii; typedef vector<int> vi;  const int INF = ~(1 << 31); const double pi = acos(-1);  inline void envelommdp(priority_queue<int> &k, std::ofstream &tt) {   int t = k.top();   if (t == 0)     tt << "0 0" << endl;   else {     int first = t / 2;     tt << t - first << " " << first << endl;   } }  
int main() {    ofstream tt("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_7_Usenix_RF_1.0_True_MCTS_Classic_True/iPeter/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out");   int ans;   scanf("%d ", &ans);   {     int s = (0);     while (s < (ans)) {       priority_queue<int> k;       int apmi_Var, q;       scanf("%d %d ", &apmi_Var, &q);       tt << "Case #" << s + 1 << ": ";       k.push(apmi_Var - 1);       for (int a = (0); a < (q - 1); a++) {         if (k.empty())           break;         else {           int t = k.top();           k.pop();           if (t == 0)             continue;           int want = t / 2;           int first = want;           if (first != 0) {             k.push(first - 1);           }           int second = t - want;           k.push(second - 1);         }       }       if (k.empty())         tt << "0 0" << endl;       else         envelommdp(k, tt);       s++;     }   }   return 0; }
#include <bits/stdc++.h> #include <iostream> using namespace std;  
typedef pair<int, int> ii; typedef vector<int> vi; typedef vector<ii> vii; typedef long long ll; const int INF = ~(1 << 31); const double pi = acos(-1);  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_7_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_7_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/bennikartefla/A-small-practice.in",           "r", stdin);    int n;   cin >> n;   for (int i = (0); i < (n); i++) {     priority_queue<int> k;     int m, q;     cin >> m >> q;     cout << "Case #" << i + 1 << ": ";     k.push(m - 1);     for (int a = (0); a < (q - 1); a++) {       if (k.empty())         break;       else {         int at = k.top();         k.pop();         if (at == 0)           continue;         int want = at / 2;         int get = want;         if (get != 0)           k.push(get - 1);         int solve = at - want;         k.push(solve - 1);       }     }     if (k.empty())       cout << "0 0" << endl;     else {       int at = k.top();       if (at == 0)         cout << "0 0" << endl;       else {         int get = at / 2;         cout << at - get << " " << get << endl;       }     }   }   return 0; }
#include <bits/stdc++.h> #include <iostream> using namespace std; 
void open() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_8_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/ccsnoopy/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_8_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/ccsnoopy/outer_temp/ccsnoopy/A-small-practice_transformation.out",           "w", stdout); }  
int main(void) {   open();   int cas;   cin >> cas;   {     int ans = 1;     while (ans <= cas) {       int n, m;       cin >> n;       cin >> m;       priority_queue<int> pq;       pq.push(n);        printf("Case #%d: ", ans);        while (m--) {         int top = pq.top();         pq.pop();         int mid = top - 1;         int i, r;         i = mid / 2;         r = (mid + 1) / 2;         if (m == 0) {           printf("%d %d\n", r, i);         }          if (i) {           pq.push(i);         }          if (r) {           pq.push(r);         }       }        cerr << "Test " << ans << " done \n";       ans++;     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <vector> using namespace std;  
typedef long long LL; typedef pair<int, int> ii; typedef vector<ii> vii;  void do_voishr_fct() {}  inline void ylzofofhrl(int &r, int &s) { printf("%d %d\n", r, s); }  inline void ginlbxrwth(priority_queue<int> &pq, int &s) { pq.push(s); }  
int main(void) {   do_voishr_fct();   int ans;   scanf("%d", &ans);   for (int tt = 1; tt <= ans; tt++) {     int n, t;     scanf("%d", &n);     scanf("%d", &t);     priority_queue<int> pq;     pq.push(n);      printf("Case #%d: ", tt);      for (; t--;) {       int top = pq.top();       pq.pop();       int mid = top - 1;       int s, r;       s = mid / 2;       r = (mid + 1) / 2;       if (t == 0) {         ylzofofhrl(r, s);       }       if (s)         ginlbxrwth(pq, s);        if (r) {         pq.push(r);       }     }      cerr << "Test " << tt << " done \n";   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <set> #include <vector> using namespace std; 
typedef unsigned long long ull; typedef vector<int> VI; typedef long double LD; typedef set<int> si; typedef long long ll; typedef long long LL; typedef pair<int, int> ii;  void get() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_8_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/ccsnoopy/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_8_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/ccsnoopy/outer_temp/ccsnoopy/A-small-practice_transformation.out",           "w", stdout); }  inline void glecwdttqq(int &r, int &c) { printf("%d %d\n", r, c); }  inline void ojzulycuhe(int &q, priority_queue<int> &pq) {   int top = pq.top();   pq.pop();   int solve = top - 1;   int c, r;   c = solve / 2;   r = (solve + 1) / 2;   if (q == 0) {     glecwdttqq(r, c);   }   if (c)     pq.push(c);    if (r)     pq.push(r); }  
int main(void) {   ios::sync_with_stdio(0);    get();   int tc;   cin >> tc;   int ct;   for (ct = 1; ct <= tc; ct++) {     int n, q;     cin >> n;     cin >> q;     priority_queue<int> pq;     pq.push(n);      printf("Case #%d: ", ct);      while (q--)       ojzulycuhe(q, pq);      cerr << "Test " << ct << " done \n";   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cassert> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <ctime> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <queue> #include <set> #include <stack> #include <stdlib.h> #include <unordered_map> #include <vector> using namespace std; 
ofstream fout;  ifstream fin;  const double eps = 1e-9;  typedef long double LD; typedef set<int> si; typedef vector<vector<int>> vvi; typedef long long ll; typedef long long LL; typedef pair<int, int> pii; typedef vector<pii> vii; typedef vector<int> VI; void open() {}  inline void dycmoaowgm(int &r, int &l) { fout << r << " " << l << "\n"; }  
int main(void) {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_8_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ccsnoopy/outer_temp/ccsnoopy/A-small-practice_transformation.out");    fin.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_8_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ccsnoopy/A-small-practice.in");    open();   int tc;   fin >> tc;   int ct;   for (ct = 1; ct <= tc; ct++) {     int n, k;     fin >> n;     fin >> k;     priority_queue<int> pq;     pq.push(n);      fout << "Case #" << ct << ": ";      while (k--) {       int top = pq.top();       pq.pop();       int mid = top - 1;       int l, r;       l = mid / 2;       r = (mid + 1) / 2;       if (k == 0)         dycmoaowgm(r, l);       if (l) {         pq.push(l);       }        if (r) {         pq.push(r);       }     }      cerr << "Test " << ct << " done \n";   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <fstream> #include <stdio.h> #include <vector> using namespace std;
ifstream fin;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &do_stdudg_fct(istream &is, pair<S, T> &p) {   return is >> p.first >> p.second; } template <class S, class T> ostream &do_stdueh_fct(ostream &s, const pair<S, T> &p) {   return s << p.first << " " << p.second; } template <class T> void do_voiflx_fct(T &x, T gzbT_Var) {   if (x < gzbT_Var)     x = gzbT_Var; } template <class T> void do_voiomv_fct(T &x, T gzbT_Var) {   if (x > gzbT_Var)     x = gzbT_Var; }  
int main() {   fin.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_9_Usenix_RF_1.0_True_MCTS_Classic_True/iPeter/okaduki/A-small-practice.in");    int ret_val = 0;   cin.tie(0);    int tt;   fin >> tt;   for (int t_ = (1); t_ < (tt + 1); ++t_) {     LL N, K;     fin >> N >> K;      vector<bool> xs(N + 2);     xs[0] = xs[N + 1] = true;     tuple<LL, LL, LL> ans;     {       int k = (0);       while (k < (K)) {         tuple<LL, LL, LL> mx(-1, -1, -1);         int i;         for (i = (0); i < (N + 2); ++i) {           if (xs[i])             continue;           LL l, r;           for (l = i - 1; !xs[l]; --l)             ;           for (r = i + 1; !xs[r]; ++r)             ;           l = i - l - 1;           r = r - i - 1;           tuple<LL, LL, LL> t(min(l, r), max(l, r), -i);           do_voiflx_fct(mx, t);         }         xs[-get<2>(mx)] = true;         ans = mx;         ++k;       }     }     printf("Case #%d: %lld %lld\n", t_, get<1>(ans), get<0>(ans));   }   return ret_val; }
#include <bits/stdc++.h> #include <iostream> #include <utility> #include <vector> using namespace std; 
const int mod = 1000000007; const double EPS = 1e-9; typedef long long ll; typedef pair<int, int> pii; typedef vector<int> vi; typedef long double ld;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &get(istream &n, pair<S, T> &p) {   return n >> p.first >> p.second; } template <class S, class T> ostream &operator<<(ostream &os, const pair<S, T> &p) {   return os << p.first << " " << p.second; } template <class T> void maxi(T &x, T y) {   if (x < y)     x = y; }  
int main() {   ios::sync_with_stdio(false);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_9_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/okaduki/outer_temp/okaduki/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_9_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/okaduki/A-small-practice.in",           "r", stdin);    cin.tie(0);    int T;   cin >> T;   for (int t_ = (1); t_ < (T + 1); ++t_) {     LL N, K;     cin >> N >> K;      vector<bool> xs(N + 2);     xs[0] = xs[N + 1] = true;     tuple<LL, LL, LL> ans;     int k;     {       k = (0);       while (k < (K)) {         tuple<LL, LL, LL> mx(-1, -1, -1);          for (int i = (0); i < (N + 2); ++i) {           if (xs[i])             continue;           LL l, r;           for (l = i - 1; !xs[l]; --l)             ;           for (r = i + 1; !xs[r]; ++r)             ;           l = i - l - 1;           r = r - i - 1;           tuple<LL, LL, LL> t(min(l, r), max(l, r), -i);           maxi(mx, t);         }         xs[-get<2>(mx)] = true;         ans = mx;         ++k;       }     }     cout << "Case #" << t_ << ": " << get<1>(ans) << " " << get<0>(ans) << endl;   }    return 0; }
#include <bits/stdc++.h> #include <fstream> using namespace std;
const int mod = 1000000007; ofstream fout;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &tc, pair<S, T> &p) {   return tc >> p.first >> p.second; } template <class S, class T> ostream &get(ostream &os, const pair<S, T> &p) {   return os << p.first << " " << p.second; } template <class T> void solve(T &x, T y) {   if (x < y)     x = y; } template <class T> void mini(T &x, T y) {   if (x > y) {     x = y;   } }  const double EPS = 1e-10; const double PI = acos(-1.0); const LL MOD = 1e9 + 7;  inline void ysgoofvfvy() { ; }  
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_9_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/okaduki/outer_temp/okaduki/A-small-practice_transformation.out");    cin.tie(0);    int T;   cin >> T;   int c;   for (c = (1); c < (T + 1); ++c) {     LL N, K;     cin >> N >> K;      vector<bool> q(N + 2);     q[0] = q[N + 1] = true;     tuple<LL, LL, LL> ans;      for (int k = (0); k < (K); ++k) {       tuple<LL, LL, LL> mx(-1, -1, -1);       {         int i = (0);         for (; i < (N + 2);) {           if (q[i]) {             ++i;             continue;           }           LL l, r;           for (l = i - 1; !q[l]; --l)             ;           for (r = i + 1; !q[r]; ++r)             ysgoofvfvy();           l = i - l - 1;           r = r - i - 1;           tuple<LL, LL, LL> t(min(l, r), max(l, r), -i);           solve(mx, t);           ++i;         }       }       q[-get<2>(mx)] = true;       ans = mx;     }     fout << "Case #" << c << ": " << get<1>(ans) << " " << get<0>(ans) << endl;   }    return 0; }
#include <bits/stdc++.h> #include <fstream> #include <set> #include <utility> #include <vector> using namespace std; 
const int MAXN = 1005; ofstream fout;  const int mod = 1000000007;  typedef long long ll; typedef pair<int, int> ii; typedef vector<int> vi; typedef long double ld; typedef vector<vector<int>> vvi;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &b, pair<S, T> &p) {   return b >> p.first >> p.second; } template <class S, class T> ostream &operator<<(ostream &os, const pair<S, T> &p) {   return os << p.first << " " << p.second; } template <class T> void get(T &x, T y) {   if (x < y)     x = y; } template <class T> void mini(T &x, T y) {   if (x > y) {     x = y;   } }  inline void byqgkxkaqh(LL &r) {   ;   ++r; }  
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_9_Usenix_RF_1.0_True_MCTS_Classic_True/Mucosolvan/okaduki/outer_temp/okaduki/A-small-practice_transformation.out");    cin.tie(0);   ios_base::sync_with_stdio(false);    int T;   cin >> T;    for (int j = (1); j < (T + 1); ++j) {     LL N, K;     cin >> N >> K;      vector<bool> xs(N + 2);     xs[0] = xs[N + 1] = true;     tuple<LL, LL, LL> ans;     for (int k = (0); k < (K); ++k) {       tuple<LL, LL, LL> mx(-1, -1, -1);       for (int i = (0); i < (N + 2); ++i) {         if (xs[i])           continue;         LL l, r;         for (l = i - 1; !xs[l]; --l)           ;         {           r = i + 1;           while (!xs[r])             byqgkxkaqh(r);         }         l = i - l - 1;         r = r - i - 1;         tuple<LL, LL, LL> t(min(l, r), max(l, r), -i);         get(mx, t);       }       xs[-get<2>(mx)] = true;       ans = mx;     }     fout << "Case #" << j << ": " << get<1>(ans) << " " << get<0>(ans) << endl;   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <limits> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
int T; const int MOD = 1000000007; typedef vector<int> vi; typedef vector<int> VI; typedef set<int> si; typedef long long ll; typedef long long LL; typedef pair<int, int> PII; typedef unsigned long long ull; typedef long double LD; typedef vector<vector<int>> vvi;  int cs; int N, K;  struct Rec {   Rec() {}   Rec(int l, int r) : l(l), r(r) {     d = (r - l) / 2;     x = r - l - d;   }   int l, r, d, x; }; priority_queue<Rec> Heap; inline bool vzfpgbfcva(struct Rec &a, struct Rec &b, _Bool &vzfpg) {   vzfpg = a.d < b.d;   return true;   return false; }  inline bool gbhpgnsovi(_Bool &vzfpg, _Bool &gbhpg) {   gbhpg = vzfpg;   return true;   return false; }  bool operator<(Rec a, Rec b) {   if (a.d != b.d) {     _Bool vzfpg;     if (vzfpgbfcva(a, b, vzfpg)) {       _Bool gbhpg;       if (gbhpgnsovi(vzfpg, gbhpg)) {         return gbhpg;       }     }   }   if (a.x != b.x)     return a.x < b.x;   return a.l > b.l; } inline void ecipqmbxdl(int &npos) {   Rec now = Heap.top();   Heap.pop();   npos = (now.l + now.r) / 2;   if (now.l <= npos - 1)     Heap.push(Rec(now.l, npos - 1));   if (npos + 1 <= now.r)     Heap.push(Rec(npos + 1, now.r)); }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_10_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/kuzphi/outer_temp/kuzphi/A-small-practice_transformation.out",           "w", stdout);    ios::sync_with_stdio(true);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_10_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/kuzphi/A-small-practice.in",           "r", stdin);    cin >> T;   for (; T--;) {     while (Heap.size())       Heap.pop();     cout << "Case #" << ++cs << ": ";     cin >> N >> K;     Heap.push(Rec(1, N));     int npos;     K--;     while (K--)       ecipqmbxdl(npos);      cout << Heap.top().x << " " << Heap.top().d << endl;   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <limits> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;
int T;  const int MAXN = 1005; const long double PI = 3.1415926535897932384626433832795; const double eps = 1e-9; ofstream fout;  ifstream fin;  int y; int N, t;  struct Rec {   Rec() {}   Rec(int l, int r) : l(l), r(r) {     d = (r - l) / 2;     x = r - l - d;   }   int l, r, d, x; }; priority_queue<Rec> Heap; bool operator<(Rec a, Rec b) {   if (a.d != b.d)     return a.d < b.d;   if (a.x != b.x) {     return a.x < b.x;   }   return a.l > b.l; } 
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_10_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/kuzphi/outer_temp/kuzphi/A-small-practice_transformation.out");    fin.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_10_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/kuzphi/A-small-practice.in");    fin >> T;   while (T--) {     while (Heap.size())       Heap.pop();     fout << "Case #" << ++y << ": ";     fin >> N >> t;     Heap.push(Rec(1, N));     int npos;     t--;     for (; t--;) {       Rec now = Heap.top();       Heap.pop();       npos = (now.l + now.r) / 2;       if (now.l <= npos - 1) {         Heap.push(Rec(now.l, npos - 1));       }       if (npos + 1 <= now.r)         Heap.push(Rec(npos + 1, now.r));     }        fout << Heap.top().x << " " << Heap.top().d << endl;   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <limits> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
int T;  const double eps = 1e-9;  typedef unsigned long long ull; typedef long double LD; typedef long long ll; typedef pair<int, int> pii; typedef vector<int> vi; typedef vector<int> VI;  int cs; int N, K;  struct Rec {   Rec() {}   Rec(int l, int r) : l(l), r(r) {     d = (r - l) / 2;     x = r - l - d;   }   int l, r, d, x; }; priority_queue<Rec> Heap; bool operator<(Rec a, Rec b) {   if (a.d != b.d)     return a.d < b.d;   if (a.x != b.x)     return a.x < b.x;   return a.l > b.l; } inline void whpkojamus(int &npos) {   Rec now = Heap.top();   Heap.pop();   npos = (now.l + now.r) / 2;   if (now.l <= npos - 1)     Heap.push(Rec(now.l, npos - 1));   if (npos + 1 <= now.r)     Heap.push(Rec(npos + 1, now.r)); }  
int main() {   int ret_val = 0;   ios::sync_with_stdio(0);   cin >> T;   while (T--) {     while (Heap.size())       Heap.pop();     cout << "Case #" << ++cs << ": ";     cin >> N >> K;     Heap.push(Rec(1, N));     int npos;     K--;     while (K--)       whpkojamus(npos);      cout << Heap.top().x << " " << Heap.top().d << endl;   }   return ret_val; }
#include <algorithm> #include <bitset> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iostream> #include <limits> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const double pi = acos(-1.), eps = 1e-6; const int Maxn = 110, Maxk = 5010, Mo = 1e9 + 7, oo = INT_MAX >> 2; const int sp[4][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}}; int T; ypedef long double ld; typedef long long LL; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef vector<int> vi; typedef long double LD;  long long f[1000][10]; int n, m, k, cs, ans; int N, K; string st; struct Rec {   Rec() {}   Rec(int l, int r) : l(l), r(r) {     d = (r - l) / 2;     x = r - l - d;   }   int l, r, d, x; }; priority_queue<Rec> Heap; bool operator<(Rec a, Rec b) {   if (a.d != b.d)     return a.d < b.d;   if (a.x != b.x)     return a.x < b.x;   return a.l > b.l; } 
int main() {   int ret_val = 0;   scanf("%d ", &T);   while (T--) {     while (Heap.size())       Heap.pop();     printf("Case #%d: ", ++cs);     scanf("%d %d ", &N, &K);     Heap.push(Rec(1, N));     int npos;     K--;     while (K--) {       Rec now = Heap.top();       Heap.pop();       npos = (now.l + now.r) / 2;       if (now.l <= npos - 1)         Heap.push(Rec(now.l, npos - 1));       if (npos + 1 <= now.r)         Heap.push(Rec(npos + 1, now.r));     }      cout << Heap.top().x << " " << Heap.top().d << endl;   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
const int INF = 1000000000; const double EPS = 1e-9; ofstream fout;  ifstream fin;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  inline void yjdqwzwipy(ll &a, ll &b, ll &t) {   a = b;   b = t; }  ll fast_exp(ll q, ll n, ll m) {   if (n == 0)     return 1;   ll t = fast_exp(q, n / 2, m);   if (n % 2 == 0)     return (t * t) % m;   else     return (((t * t) % m) * q) % m; }  bool is_set(int i, ll mask) { return (mask >> i) & 1; }  int get(ll mask) {   int ans = 0;   for (int i = 0; i < 64; ++i)     if (is_set(i, mask))       ++ans;   return ans; }  inline bool glcxbdrhlw(ll &mask, int &i, int &glcxb) {   if (is_set(i++, mask))     glcxb = i - 1;   return true;   return false; }  inline bool uejdynhmsk(int &glcxb, int &uejdy) {   uejdy = glcxb;   return true;   return false; }  inline bool wwagfttrey(int &uejdy, int &wwagf) {   wwagf = uejdy;   return true;   return false; }  int first_bit(ll mask) {   int i = 0;   while (i < 64) {     int glcxb;     if (glcxbdrhlw(mask, i, glcxb)) {       int uejdy;       if (uejdynhmsk(glcxb, uejdy)) {         int wwagf;         if (wwagfttrey(uejdy, wwagf)) {           return wwagf;         }       }     }   }   return -1; }  inline void lgrdwywhps(int &j) {   ll n, r;   fin >> n >> r;   ll s = 0, i = -1;   while (s < r)     ++i, s += 1ll << i;   ll C = 1ll << i;   ll left = n - s + C;   ll pos = r - s + C;   ll q = left / (s - C + 1);   ll high = left % (s - C + 1);   if (pos <= high)     q += 1;   fout << "Case #" << j << ": " << q / 2 << " " << (q - 1) / 2 << "\n"; }  
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_11_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ibrahim5253/outer_temp/ibrahim5253/A-small-practice_transformation.out");    fin.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_11_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ibrahim5253/A-small-practice.in");    int t;   fin >> t;   for (int j = 1; j <= t; ++j)     lgrdwywhps(j);   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
const int INF = 1000000000;  typedef long long LL; typedef pair<int, int> ii; typedef long double LD;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  ll do_llnke_fct(ll a, ll b) {   ll t;   for (; (t = a % b) != 0;) {     a = b;     b = t;   }   return b; }  ll do_llzyo_fct(ll v, ll n, ll m) {   if (n == 0) {     return 1;   }   ll t = do_llzyo_fct(v, n / 2, m);   if (n % 2 == 0)     return (t * t) % m;   else     return (((t * t) % m) * v) % m; }  bool get(int i, ll mask) { return (mask >> i) & 1; }  int do_intjkd_fct(ll mask) {   int i = 0;   while (i < 64)     if (get(i++, mask))       return i - 1;   return -1; }  
int main() {   ios::sync_with_stdio(false);   int t;   cin >> t;   for (int j = 1; j <= t; ++j) {     ll n, p;     cin >> n >> p;     ll s = 0, i = -1;     while (s < p)       ++i, s += 1ll << i;     ll C = 1ll << i;     ll left = n - s + C;     ll pos = p - s + C;     ll v = left / (s - C + 1);     ll high = left % (s - C + 1);     if (pos <= high)       v += 1;     cout << "Case #" << j << ": " << v / 2 << " " << (v - 1) / 2 << "\n";   }   return 0; }
#include <algorithm> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
const int mod = 1000000007; const int INF = 1000000000; const double eps = 1e-9; const int MOD = 1000000007; typedef set<int> si; typedef long long LL; typedef pair<int, int> ii; typedef vector<int> VI; typedef long double LD;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  bool is_set(int i, ll mask) { return (mask >> i) & 1; }  int count_bits(ll mask) {   int ans = 0;   for (int i = 0; i < 64; ++i)     if (is_set(i, mask))       ++ans;   return ans; }  int first_bit(ll mask) {   int i = 0;   while (i < 64)     if (is_set(i++, mask))       return i - 1;   return -1; }  
int main() {   int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_11_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/ibrahim5253/A-small-practice.in",           "r", stdin);   int t;   scanf("%d ", &t);   {     int j = 1;     for (; j <= t;) {       ll n, k;       scanf("%lld %lld ", &n, &k);       ll s = 0, i = -1;       while (s < k)         ++i, s += 1ll << i;       ll C = 1ll << i;       ll left = n - s + C;       ll pos = k - s + C;       ll y = left / (s - C + 1);       ll high = left % (s - C + 1);       if (pos <= high)         y += 1;       printf("Case #%d: %lld %lld\n", j, y / 2, (y - 1) / 2);       ++j;     }   }   return ret_val; }
#include <algorithm> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std;
const int MOD = 1000000007;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  inline void bstlxkogsy(ll &a, ll &b, ll &t) {   a = b;   b = t; }  ll solve(ll a, ll b) {   ll t;   for (; (t = a % b) != 0;)     bstlxkogsy(a, b, t);   return b; }  ll fast_exp(ll tc, ll n, ll p) {   if (n == 0)     return 1;   ll t = fast_exp(tc, n / 2, p);   if (n % 2 == 0)     return (t * t) % p;   else     return (((t * t) % p) * tc) % p; }  bool is_set(int i, ll v) { return (v >> i) & 1; }  int count_bits(ll v) {   int ans = 0;   for (int i = 0; i < 64; ++i)     if (is_set(i, v))       ++ans;   return ans; }  int first_bit(ll v) {   int ret_val = -1;   int i = 0;   while (i < 64)     if (is_set(i++, v))       return i - 1;   return ret_val; }  inline void gfjihtxcad(int &j) {   ll n, r;   cin >> n >> r;   ll s = 0, i = -1;   while (s < r)     ++i, s += 1ll << i;   ll C = 1ll << i;   ll left = n - s + C;   ll pos = r - s + C;   ll tc = left / (s - C + 1);   ll high = left % (s - C + 1);   if (pos <= high)     tc += 1;   printf("Case #%d: %lld %lld\n", j, tc / 2, (tc - 1) / 2); }  
int main() {    int t;   cin >> t;   int j;   for (j = 1; j <= t; ++j)     gfjihtxcad(j);   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <set> #include <utility> #include <vector> using namespace std;
const int MOD = 1000000007; const int INF = 1000000000; const int MAXN = 1005; typedef long double ld; typedef pair<int, int> ii; typedef vector<int> vi; typedef vector<int> VI; typedef long double LD; typedef set<int> si; typedef long long LL;  
int main() {   ios::sync_with_stdio(false);    int solve, cas = 0;   cin >> solve;   for (; solve--;) {     LL n, x;     cin >> n >> x;     int d = 0;     for (LL v = 1; v <= x; v <<= 1)       d++;     printf("Case #%d: ", ++cas);     LL base = 1 << d;     if (n < base) {       puts("0 0");       continue;     }     LL md = (n - (base - 1)) % base;     LL lx = (n - (base - 1)) / base, rx = lx;     int id = x - (1 << (d - 1)) + 1;     if (id <= md)       rx++;     if (id + (1 << (d - 1)) <= md)       lx++;     printf("%lld %lld\n", rx, lx);   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <iostream> #include <iterator> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
typedef pair<int, int> ii; typedef pair<int, int> PII; typedef unsigned long long ull; typedef long double LD; typedef set<int> si; typedef vector<vector<int>> vvi; typedef long long LL; 
int main() {   int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_12_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/jiian/A-small-practice.in",           "r", stdin);    int T, cas = 0;   cin >> T;   while (T--) {     LL n, k;     cin >> n >> k;     int d = 0;     for (LL v = 1; v <= k; v <<= 1)       d++;     printf("Case #%d: ", ++cas);     LL base = 1 << d;     if (n < base) {       puts("0 0");       continue;     }     LL md = (n - (base - 1)) % base;     LL lx = (n - (base - 1)) / base, rx = lx;     int id = k - (1 << (d - 1)) + 1;     if (id <= md)       rx++;     if (id + (1 << (d - 1)) <= md) {       lx++;     }     printf("%lld %lld\n", rx, lx);   }   return ret_val; }
#include <bits/stdc++.h> #include <iostream> #include <set> #include <utility> #include <vector> using namespace std; 
const double eps = 1e-9;  typedef pair<int, int> pii; typedef pair<int, int> PII; typedef vector<int> VI; typedef set<int> si; typedef long long LL;  
int main() {    int T, tc = 0;   cin >> T;   for (; T--;) {     LL x, q;     cin >> x >> q;     int d = 0;     for (LL v = 1; v <= q; v <<= 1)       d++;     printf("Case #%d: ", ++tc);     LL base = 1 << d;     if (x < base) {       puts("0 0");       continue;     }     LL md = (x - (base - 1)) % base;     LL solve = (x - (base - 1)) / base, get = solve;     int id = q - (1 << (d - 1)) + 1;     if (id <= md)       get++;     if (id + (1 << (d - 1)) <= md) {       solve++;     }     printf("%lld %lld\n", get, solve);   }   return 0; }
#include <bits/stdc++.h> #include <iomanip> #include <iostream> #include <stdio.h> using namespace std; 
int main() {   int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_12_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/jiian/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_12_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/jiian/outer_temp/jiian/A-small-practice_transformation.out",           "w", stdout);   int T, cas = 0;   scanf("%d ", &T);   while (T--) {     long long n, k;     scanf("%lld %lld ", &n, &k);     int d = 0;     for (long long v = 1; v <= k; v <<= 1)       d++;     cout << "Case #" << ++cas << ": ";     long long base = 1 << d;     if (n < base) {       puts("0 0");       continue;     }     long long md = (n - (base - 1)) % base;     long long lx = (n - (base - 1)) / base, rx = lx;     int id = k - (1 << (d - 1)) + 1;     if (id <= md)       rx++;     if (id + (1 << (d - 1)) <= md)       lx++;     cout << rx << " " << lx << "\n";   }   return ret_val; }
#include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <list> #include <numeric> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <utility> #include <vector> using namespace std;
typedef long double ld; typedef long long LL; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef vector<int> vi; typedef long double LD;  int main(void) {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_13_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/iPeter/A-small-practice.in", "r", stdin);    int ret_val = 0;   int t;   scanf("%d", &t);   for (int tt = 1; tt <= t; tt++) {      int n, k;     priority_queue<int> q;     scanf("%d%d", &n, &k);     q.push(n);     while (--k) {       int x = q.top();       q.pop();       q.push(x / 2);       q.push((x - 1) / 2);     }      int v = q.top();     printf("Case #%d: %d %d\n", tt, v / 2, (v - 1) / 2);   }   return ret_val; }
#include <algorithm> #include <cstdio> #include <cstring> #include <iostream> #include <queue> using namespace std; 
int main(void) {   int t;   cin >> t;   for (int tt = 1; tt <= t; tt++) {      int n, k;     priority_queue<int> q;     cin >> n >> k;     q.push(n);     while (--k) {       int solve = q.top();       q.pop();       q.push(solve / 2);       q.push((solve - 1) / 2);     }      int v = q.top();     printf("Case #%d: %d %d\n", tt, v / 2, (v - 1) / 2);   }   return 0; }  
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <queue> using namespace std; 
int main(void) {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_13_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/iPeter/A-small-practice.in", "r", stdin);    int ret_val = 0;   int t;   scanf("%d", &t);   for (int tt = 1; tt <= t; tt++) {      int n, ans;     priority_queue<int> q;     scanf("%d%d", &n, &ans);     q.push(n);     while (--ans) {       int x = q.top();       q.pop();       q.push(x / 2);       q.push((x - 1) / 2);     }      int v = q.top();     printf("Case #%d: %d %d\n", tt, v / 2, (v - 1) / 2);   }   return ret_val; } 
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <iomanip> #include <iostream> #include <queue> #include <utility> using namespace std; 
typedef pair<int, int> pii; typedef double dbl;  int main(void) {   int ret_val = 0;   int m;   cin >> m;   for (int i = 1; i <= m; i++) {      int n, tc;     priority_queue<int> q;     cin >> n >> tc;     q.push(n);     for (; --tc;) {       int x = q.top();       q.pop();       q.push(x / 2);       q.push((x - 1) / 2);     }      int v = q.top();     cout << "Case #" << i << ": " << v / 2 << " " << (v - 1) / 2 << "\n";   }   return ret_val; } 
#include <bits/stdc++.h> #include <cctype> #include <climits> #include <cstdio> #include <ctime> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <queue> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <unordered_map>  using namespace std; 
const int INF = 1000000000; ofstream fout;  const int MOD = 1000000007;  long long pwr(long long base, long long p, long long s = (1000000007LL)) {   long long ans = 1;   while (p) {     if (p & 1) {       ans = (ans * base) % s;     }     base = (base * base) % s;     p /= 2;   }   return ans; }  long long solve(long long a, long long b) {   if (b == 0)     return a;   return solve(b, a % b); }  struct compare {   bool operator()(const pair<long long, long long> &a,                   const pair<long long, long long> &b) const {     if ((a.first - 1) / 2 != (b.first - 1) / 2)       return a.first > b.first;     return (a.first - 1 - (a.first - 1) / 2) >            (b.first - 1 - (b.first - 1) / 2);   } };  set<pair<long long, long long>> arr;  
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_14_Usenix_RF_1.0_True_MCTS_Classic_True/Thanabhat/satyaki3794/outer_temp/satyaki3794/A-small-practice_transformation.out");    int ret_val = 0;    cin.tie(0);    int t, x = 1;   cin >> t;   for (; t--;) {      long long n, k;     cin >> n >> k;         arr.clear();     arr.insert(pair<long long, long long>(-n, 1));     set<pair<long long, long long>>::iterator it;     long long ans_l, ans_r;       while (k > 0) {         assert(!arr.empty());       it = arr.begin();       pair<long long, long long> temp = (*it);       temp.first *= -1;       arr.erase(it);       if (temp.second == 0) {         continue;       }          long long z = min(k, temp.second);       if (temp.second > z) {         arr.insert(pair<long long, long long>(-temp.first, temp.second - z));         temp.second = z;       }       k -= z;        long long l = (temp.first - 1) / 2, r = temp.first - 1 - l;       ans_l = max(l, r);       ans_r = min(l, r);          if (l > 0) {         it = arr.lower_bound(pair<long long, long long>(-l, -1));         if (it != arr.end() && (*it).first == -l) {           long long cnt = (*it).second + temp.second;           arr.erase(it);           arr.insert(pair<long long, long long>(-l, cnt));          } else {           long long cnt = temp.second;           arr.insert(pair<long long, long long>(-l, cnt));          }       }        if (r > 0) {         it = arr.lower_bound(pair<long long, long long>(-r, -1));         if (it != arr.end() && (*it).first == -r) {           long long cnt = (*it).second + temp.second;           arr.erase(it);           arr.insert(pair<long long, long long>(-r, cnt));          } else {           long long cnt = temp.second;           arr.insert(pair<long long, long long>(-r, cnt));          }       }     }      fout << "Case #" << x++ << ": " << ans_l << " " << ans_r << endl;   }   return ret_val; }
#include <bits/stdc++.h> #include <stdio.h>  using namespace std;  
typedef unsigned long long ull;  struct compare {   bool operator()(const pair<long long, long long> &a,                   const pair<long long, long long> &b) const {     if ((a.first - 1) / 2 != (b.first - 1) / 2)       return a.first > b.first;     return (a.first - 1 - (a.first - 1) / 2) >            (b.first - 1 - (b.first - 1) / 2);   } };  set<pair<long long, long long>> arr;  
int main() {   int ret_val = 0;    cin.tie(0);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_14_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/satyaki3794/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_14_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/satyaki3794/outer_temp/satyaki3794/A-small-practice_transformation.out",           "w", stdout);   int cc, lvmi_Var = 1;   scanf("%d ", &cc);   while (cc--) {      long long vyhl_Var, k;     scanf("%lld %lld ", &vyhl_Var, &k);          arr.clear();     arr.insert(pair<long long, long long>(-vyhl_Var, 1));     set<pair<long long, long long>>::iterator it;     long long ans_l, ans_r;         while (k > 0) {              assert(!arr.empty());       it = arr.begin();       pair<long long, long long> temp = (*it);       temp.first *= -1;       arr.erase(it);       if (temp.second == 0) {         continue;       }         long long i = min(k, temp.second);       if (temp.second > i) {         arr.insert(pair<long long, long long>(-temp.first, temp.second - i));         temp.second = i;       }       k -= i;        long long l = (temp.first - 1) / 2, r = temp.first - 1 - l;       ans_l = max(l, r);       ans_r = min(l, r);              if (l > 0) {         it = arr.lower_bound(pair<long long, long long>(-l, -1));         if (it != arr.end() && (*it).first == -l) {           long long cnt = (*it).second + temp.second;           arr.erase(it);           arr.insert(pair<long long, long long>(-l, cnt));                  } else {           long long cnt = temp.second;           arr.insert(pair<long long, long long>(-l, cnt));                    }       }        if (r > 0) {         it = arr.lower_bound(pair<long long, long long>(-r, -1));         if (it != arr.end() && (*it).first == -r) {           long long cnt = (*it).second + temp.second;           arr.erase(it);           arr.insert(pair<long long, long long>(-r, cnt));                    } else {           long long cnt = temp.second;           arr.insert(pair<long long, long long>(-r, cnt));                    }       }     }      printf("Case #%d: %lld %lld\n", lvmi_Var++, ans_l, ans_r);   }   return ret_val; }
#include <bits/stdc++.h> #include <fstream> #include <utility>  using namespace std; 
ofstream fout;  ifstream fin;  typedef double dbl; typedef pair<int, int> pii; typedef long long ll;  typedef pair<ll, ll> ii;  ll do_llcrn_fct(ll a, ll b) {   if (b == 0)     return a;   return do_llcrn_fct(b, a % b); }  struct compare {   bool operator()(const ii &a, const ii &b) const {     if ((a.first - 1) / 2 != (b.first - 1) / 2)       return a.first > b.first;     return (a.first - 1 - (a.first - 1) / 2) >            (b.first - 1 - (b.first - 1) / 2);   } };  set<ii> arr;  inline void qbzknkpggx(ii &temp, set<ii>::iterator &it, ll &l) {   ll cnt = (*it).second + temp.second;   arr.erase(it);   arr.insert(ii(-l, cnt));  }  inline void ugdvioomtr(ii &temp, ll &l) {   ll cnt = temp.second;   arr.insert(ii(-l, cnt));  }  
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_13_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/satyaki3794/outer_temp/satyaki3794/A-small-practice_transformation.out");    fin.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_13_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/satyaki3794/A-small-practice.in");    int ret_val = 0;    cin.tie(0);    int t, x = 1;   fin >> t;   for (; t--;) {      ll n, k;     fin >> n >> k;       arr.clear();     arr.insert(ii(-n, 1));     set<ii>::iterator it;     ll ans_l, ans_r;          for (; k > 0;) {          assert(!arr.empty());       it = arr.begin();       ii temp = (*it);       temp.first *= -1;       arr.erase(it);       if (temp.second == 0)         continue;          ll z = min(k, temp.second);       if (temp.second > z) {         arr.insert(ii(-temp.first, temp.second - z));         temp.second = z;       }       k -= z;        ll l = (temp.first - 1) / 2, r = temp.first - 1 - l;       ans_l = max(l, r);       ans_r = min(l, r);          if (l > 0) {         it = arr.lower_bound(ii(-l, -1));         if (it != arr.end() && (*it).first == -l)           qbzknkpggx(temp, it, l);         else           ugdvioomtr(temp, l);       }        if (r > 0) {         it = arr.lower_bound(ii(-r, -1));         if (it != arr.end() && (*it).first == -r) {           ll cnt = (*it).second + temp.second;           arr.erase(it);           arr.insert(ii(-r, cnt));                  } else {           ll cnt = temp.second;           arr.insert(ii(-r, cnt));                    }       }     }      fout << "Case #" << x++ << ": " << ans_l << " " << ans_r << endl;   }   return ret_val; }
#include <bits/stdc++.h> #include <stdio.h>  using namespace std; 
typedef long long ll; typedef unsigned long long ull; typedef pair<ll, ll> ii;  struct compare {   bool operator()(const ii &a, const ii &b) const {     if ((a.first - 1) / 2 != (b.first - 1) / 2)       return a.first > b.first;     return (a.first - 1 - (a.first - 1) / 2) >            (b.first - 1 - (b.first - 1) / 2);   } };  set<ii> arr;  
int main() {   int ret_val = 0;   ios_base::sync_with_stdio(0);   cin.tie(0);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_13_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/satyaki3794/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_13_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/satyaki3794/outer_temp/satyaki3794/A-small-practice_transformation.out",           "w", stdout);   int t, x = 1;   cin >> t;   while (t--) {      ll n, k;     cin >> n >> k;        arr.clear();     arr.insert(ii(-n, 1));     set<ii>::iterator it;     ll ans_l, ans_r;       while (k > 0) {            assert(!arr.empty());       it = arr.begin();       ii temp = (*it);       temp.first *= -1;       arr.erase(it);       if (temp.second == 0)         continue;         ll z = min(k, temp.second);       if (temp.second > z) {         arr.insert(ii(-temp.first, temp.second - z));         temp.second = z;       }       k -= z;        ll l = (temp.first - 1) / 2, r = temp.first - 1 - l;       ans_l = max(l, r);       ans_r = min(l, r);                if (l > 0) {         it = arr.lower_bound(ii(-l, -1));         if (it != arr.end() && (*it).first == -l) {           ll cnt = (*it).second + temp.second;           arr.erase(it);           arr.insert(ii(-l, cnt));                  } else {           ll cnt = temp.second;           arr.insert(ii(-l, cnt));                  }       }        if (r > 0) {         it = arr.lower_bound(ii(-r, -1));         if (it != arr.end() && (*it).first == -r) {           ll cnt = (*it).second + temp.second;           arr.erase(it);           arr.insert(ii(-r, cnt));                    } else {           ll cnt = temp.second;           arr.insert(ii(-r, cnt));                    }       }     }      printf("Case #%d: %lld %lld\n", x++, ans_l, ans_r);   }   return ret_val; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> using namespace std; 
struct Segment {   long long int l, r;   long long int center() { return (l + r) / 2; }   long long int left_dist() { return this->center() - this->l - 1; }   long long int right_dist() { return this->r - this->center() - 1; }   long long int min_dist() {     return min(this->left_dist(), this->right_dist());   }   long long int max_dist() {     return max(this->left_dist(), this->right_dist());   } };  struct Magic {   bool operator()(Segment &lhs, Segment &rhs) const {     if (lhs.min_dist() == rhs.min_dist()) {       if (lhs.max_dist() == rhs.max_dist())         return lhs.center() > rhs.center();        return lhs.max_dist() < rhs.max_dist();     }     return lhs.min_dist() < rhs.min_dist();   } };  inline void jbbsfsjjsh(     priority_queue<struct Segment, vector<struct Segment>, struct Magic> &pq,     struct Segment &s) {   pq.push({s.l, s.center()});   pq.push({s.center(), s.r}); }  
int main(int argc, char **cc) {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_15_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out",           "w", stdout);    int ret_val = 0;   ifstream fin("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_15_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/gultai4ukr/A-small-practice.in");    int ans;   fin >> ans;    for (int testcase = 0; testcase < ans; ++testcase) {     long long int n, k;     fin >> n >> k;      priority_queue<Segment, vector<Segment>, Magic> pq;     Segment s = {0, n + 1};     pq.push(s);     {       int i = 0;       while (i < k) {         s = pq.top();         pq.pop();         if (s.max_dist() > 0)           jbbsfsjjsh(pq, s);         ++i;       }     }      printf("Case #%d: %lld %lld\n", testcase + 1, s.max_dist(), s.min_dist());   }   fin.close();    return ret_val; }
#include <bits/stdc++.h> #include <iostream> using namespace std;  
struct Segment {   long long int l, r;   long long int center() { return (l + r) / 2; }   long long int left_dist() { return this->center() - this->l - 1; }   long long int right_dist() { return this->r - this->center() - 1; }   long long int min_dist() {     return min(this->left_dist(), this->right_dist());   }   long long int max_dist() {     return max(this->left_dist(), this->right_dist());   } };  struct Magic {   bool operator()(Segment &lhs, Segment &rhs) const {     if (lhs.min_dist() == rhs.min_dist()) {       if (lhs.max_dist() == rhs.max_dist()) {         return lhs.center() > rhs.center();       }        return lhs.max_dist() < rhs.max_dist();     }     return lhs.min_dist() < rhs.min_dist();   } };  
int main(int m, char **lpuc_Var) {   int ret_val = 0;   ifstream kges_Var("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_14_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/gultai4ukr/A-small-practice.in");    int t;   kges_Var >> t;   int glvi_Var;   for (glvi_Var = 0; glvi_Var < t; ++glvi_Var) {     long long int n, yfhl_Var;     kges_Var >> n >> yfhl_Var;      priority_queue<Segment, vector<Segment>, Magic> pq;     Segment tc = {0, n + 1};     pq.push(tc);     {       int i = 0;       for (; i < yfhl_Var;) {         tc = pq.top();         pq.pop();         if (tc.max_dist() > 0) {           pq.push({tc.l, tc.center()});           pq.push({tc.center(), tc.r});         }         ++i;       }     }      cout << "Case #" << glvi_Var + 1 << ": " << tc.max_dist() << ' '          << tc.min_dist() << endl;   }   kges_Var.close();    return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cctype> #include <complex> #include <cstdio> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <map> #include <math.h> #include <numeric> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility> #include <vector> using namespace std;
const double eps = 1e-9; const double EPS = 1e-9; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef long double ld; typedef long long ll; typedef unsigned long long ull; typedef vector<int> vi; typedef set<int> si; typedef vector<vector<int>> vvi;  struct Segment {   long long int l, r;   long long int center() { return (l + r) / 2; }   long long int left_dist() { return this->center() - this->l - 1; }   long long int right_dist() { return this->r - this->center() - 1; }   long long int min_dist() {     return min(this->left_dist(), this->right_dist());   }   long long int max_dist() {     return max(this->left_dist(), this->right_dist());   } };  struct Magic {   bool operator()(Segment &lhs, Segment &rhs) const {     if (lhs.min_dist() == rhs.min_dist()) {       if (lhs.max_dist() == rhs.max_dist()) {         return lhs.center() > rhs.center();       }       return lhs.max_dist() < rhs.max_dist();     }     return lhs.min_dist() < rhs.min_dist();   } };  inline void zzigksxkum(     priority_queue<struct Segment, vector<struct Segment>, struct Magic> &pq,     struct Segment &s) {   pq.push({s.l, s.center()});   pq.push({s.center(), s.r}); }  
int main(int argc, char **argv) {   ios::sync_with_stdio(false);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_14_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out",           "w", stdout);    int ret_val = 0;   ifstream N("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_14_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/gultai4ukr/A-small-practice.in");    int solve;   N >> solve;   for (int get = 0; get < solve; ++get) {     ll n, k;     N >> n >> k;      priority_queue<Segment, vector<Segment>, Magic> pq;     Segment s = {0, n + 1};     pq.push(s);     for (int i = 0; i < k; ++i) {       s = pq.top();       pq.pop();       if (s.max_dist() > 0)         zzigksxkum(pq, s);     }      printf("Case #%d: %lld %lld\n", get + 1, s.max_dist(), s.min_dist());   }   N.close();    return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <list> #include <queue> #include <sstream> #include <stack> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
typedef long long td_ll;  const int INF = 1000000000; const double eps = 1e-9;  struct Segment {   long long int l, r;   long long int center() { return (l + r) / 2; }   long long int left_dist() { return this->center() - this->l - 1; }   long long int solve() { return this->r - this->center() - 1; }   long long int min_dist() { return min(this->left_dist(), this->solve()); }   long long int max_dist() { return max(this->left_dist(), this->solve()); } };  struct Magic {   bool operator()(Segment &lhs, Segment &rhs) const {     if (lhs.min_dist() == rhs.min_dist()) {       if (lhs.max_dist() == rhs.max_dist()) {         return lhs.center() > rhs.center();       }       return lhs.max_dist() < rhs.max_dist();     }     return lhs.min_dist() < rhs.min_dist();   } };  inline void qrplqkjsnn(     long long &c,     priority_queue<struct Segment, vector<struct Segment>, struct Magic> &pq,     struct Segment &s) {   int i = 0;   while (i < c) {     s = pq.top();     pq.pop();     if (s.max_dist() > 0) {       pq.push({s.l, s.center()});       pq.push({s.center(), s.r});     }     ++i;   } }  inline void bhcgusdvuv(std::ifstream &p, std::ofstream &fout, int &b) {   td_ll n, c;   p >> n >> c;    priority_queue<Segment, vector<Segment>, Magic> pq;   Segment s = {0, n + 1};   pq.push(s);   qrplqkjsnn(c, pq, s);    fout << "Case #" << b + 1 << ": " << s.max_dist() << ' ' << s.min_dist()        << endl;   ++b; }  inline void bldgkhmwwf(int &t, std::ifstream &p, std::ofstream &fout, int &b) {   b = 0;   while (b < t) {     bhcgusdvuv(p, fout, b);   } }  
int main(int argc, char **argv) {   ifstream p("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_14_Usenix_RF_1.0_True_MCTS_Classic_True/try/gultai4ukr/A-small-practice.in");   ofstream fout("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_14_Usenix_RF_1.0_True_MCTS_Classic_True/try/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out");    int t;   p >> t;   int b;   bldgkhmwwf(t, p, fout, b);    p.close();   fout.close();   return 0; }
#include <bits/stdc++.h>  using namespace std; 
typedef long double ld; typedef pair<int, int> pii; typedef pair<pii, int> para; const int inf = 1e9 + 7; const int maxN = 1e6 + 5;  int t, cnt[5];  void solve(int n, int k) {   if (n == k) {     cout << "0 0\n";     return;   }    int pot = 1;    int a = n, b = 0;   cnt[0] = 1;   cnt[1] = 0;   while (pot < k) {     int newA = 0, newB = 0;     newA = a / 2;     cnt[2] = cnt[0];     if (a - newA - 1 != newA && newA != 1) {       cnt[3] = cnt[0];       newB = a - newA - 1;     } else {       if (a != 2)         cnt[2] += cnt[0];     }      if (b > 1) {       if (b % 2 == 0) {         if (b != 2) {           newB = b - (b / 2) - 1;           cnt[3] += cnt[1];         }         cnt[2] += cnt[1];       } else {         cnt[3] += cnt[1] * 2;       }     } else {       cnt[2] += cnt[1];       if (a != n && b != 0)         k++;     }      a = newA;     b = newB;     cnt[0] = cnt[2];     cnt[1] = cnt[3];     cnt[2] = cnt[3] = 0;       k -= pot;     pot *= 2;   }    if (k > cnt[0])     a = b;   cout << a / 2 << " " << max(0, a - (a / 2) - 1) << endl; }  
int main() {   int ret_val = 0;    cin >> t;   for (int x = (1); x <= ((t)); ++x) {     int n, k;     cin >> n >> k;     cout << "Case #" << x << ": ";     solve(n, k);   }   return ret_val; }
#include <bits/stdc++.h> #include <stdio.h>  using namespace std; 
typedef vector<int> vi; typedef long long ll; typedef long double ld; typedef pair<int, int> pii; typedef pair<pii, int> para; const int inf = 1e9 + 7; const int maxN = 1e6 + 5;  int t, ans[5];  void solve(int n, int k) {   if (n == k) {     printf("0 0\n");     return;   }    int pot = 1;    int a = n, b = 0;   ans[0] = 1;   ans[1] = 0;   for (; pot < k;) {     int newA = 0, newB = 0;     newA = a / 2;     ans[2] = ans[0];     if (a - newA - 1 != newA && newA != 1) {       ans[3] = ans[0];       newB = a - newA - 1;     } else {       if (a != 2)         ans[2] += ans[0];     }      if (b > 1) {       if (b % 2 == 0) {         if (b != 2) {           newB = b - (b / 2) - 1;           ans[3] += ans[1];         }         ans[2] += ans[1];       } else {         ans[3] += ans[1] * 2;       }     } else {       ans[2] += ans[1];       if (a != n)         if (b != 0)           k++;     }      a = newA;     b = newB;     ans[0] = ans[2];     ans[1] = ans[3];     ans[2] = ans[3] = 0;        k -= pot;     pot *= 2;   }     if (k > ans[0])     a = b;   printf("%d %d\n", a / 2, max(0, a - (a / 2) - 1)); }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_15_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/Mucosolvan/A-small-practice.in",           "r", stdin);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_15_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/Mucosolvan/outer_temp/Mucosolvan/A-small-practice_transformation.out",           "w", stdout);    int ret_val = 0;    cin >> t;   for (int get = (1); get <= ((t)); ++get) {     int n, k;     cin >> n >> k;     printf("Case #%d: ", get);     solve(n, k);   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <climits> #include <cmath> #include <cstdio> #include <cstring> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <math.h> #include <numeric> #include <stack> #include <stdio.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
const int mod = 1000000007;  typedef vector<vector<int>> vvi; typedef vector<int> VI; typedef long long LL; typedef long double LD; typedef pair<int, int> ii; typedef pair<ii, int> para; const int inf = 1e9 + 7; const int maxN = 1e6 + 5;  int t, s[5];  inline void apmqaighju(int &newB, int &b) {   newB = b - (b / 2) - 1;   s[3] += s[1]; }  void get(int n, int c) {   if (n == c) {     printf("0 0\n");     return;   }    int pot = 1;    int a = n, b = 0;   s[0] = 1;   s[1] = 0;   while (pot < c) {     int newA = 0, newB = 0;     newA = a / 2;     s[2] = s[0];     if (a - newA - 1 != newA && newA != 1) {       s[3] = s[0];       newB = a - newA - 1;     } else {       if (a != 2)         s[2] += s[0];     }      if (b > 1) {       if (b % 2 == 0) {         if (b != 2)           apmqaighju(newB, b);         s[2] += s[1];       } else {         s[3] += s[1] * 2;       }     } else {       s[2] += s[1];       if (a != n && b != 0) {         c++;       }     }      a = newA;     b = newB;     s[0] = s[2];     s[1] = s[3];     s[2] = s[3] = 0;         c -= pot;     pot *= 2;   }    if (c > s[0])     a = b;   printf("%d %d\n", a / 2, max(0, a - (a / 2) - 1)); }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_15_Usenix_RF_1.0_True_MCTS_Classic_True/try/Mucosolvan/outer_temp/Mucosolvan/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_15_Usenix_RF_1.0_True_MCTS_Classic_True/try/Mucosolvan/A-small-practice.in",           "r", stdin);    scanf("%d ", &t);   int x;   for (x = (1); x <= ((t)); ++x) {     int n, c;     scanf("%d %d ", &n, &c);     printf("Case #%d: ", x);     get(n, c);   }   return 0; }
#include <bits/stdc++.h> #include <iomanip> #include <iostream> #include <set> #include <stdio.h> #include <vector>  using namespace std;
const long double PI = 3.1415926535897932384626433832795; const int mod = 1000000007;  typedef set<int> si; typedef vector<vector<int>> vvi; typedef vector<int> VI; typedef long long LL; typedef long double LD; typedef pair<int, int> pii; typedef pair<pii, int> para; const int inf = 1e9 + 7; const int maxN = 1e6 + 5;  int t, p[5];  void solve(int n, int c) {   if (n == c) {     cout << "0 0\n";     return;   }    int pot = 1;    int a = n, b = 0;   p[0] = 1;   p[1] = 0;   for (; pot < c;) {     int newA = 0, newB = 0;     newA = a / 2;     p[2] = p[0];     if (a - newA - 1 != newA && newA != 1) {       p[3] = p[0];       newB = a - newA - 1;     } else {       if (a != 2)         p[2] += p[0];     }      if (b > 1) {       if (b % 2 == 0) {         if (b != 2) {           newB = b - (b / 2) - 1;           p[3] += p[1];         }         p[2] += p[1];       } else {         p[3] += p[1] * 2;       }      } else {       p[2] += p[1];       if (a != n)         if (b != 0)           c++;     }      a = newA;     b = newB;     p[0] = p[2];     p[1] = p[3];     p[2] = p[3] = 0;         c -= pot;     pot *= 2;   }     if (c > p[0])     a = b;   cout << a / 2 << " " << max(0, a - (a / 2) - 1) << "\n"; }  
int main() {   int ret_val = 0;    cin >> t;   for (int x = (1); x <= ((t)); ++x) {     int n, c;     cin >> n >> c;     cout << "Case #" << x << ": ";     solve(n, c);   }   return ret_val; }
#include <bits/stdc++.h> #include <bitset> #include <complex> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std;  
typedef long double LD; typedef vector<int> VI; typedef vector<VI> vvi; typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long ll;            typedef unsigned long long ull;   const double pi = acos(-1.0);  const double eps = 1e-11;      const int MAXI = 0x7fffffff; const int dx[] = {1, 0, -1, 0}; const int dy[] = {0, 1, 0, -1}; const char dz[] = "SENW"; struct debugger {   template <typename T> debugger &operator,(const T &v) {     cerr << v << " ";     return *this;   } } dbg;  void debugarr(int *arr, int n) {   cout << "[";   int i;   for (i = 0; i < n; i++)     cout << arr[i] << " ";   cout << "]" << endl; }  char str[50];  long long pow2(int a, long long int b) {   long long x = 1, y = a;   while (b > 0) {     if (b % 2 == 1) {       x = (x * y);     }     y = (y * y);     b /= 2;   }   return x; } ll dist[2]; 
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_16_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/lazyBit/A-small-practice.in",           "r", stdin);    ios::sync_with_stdio(true);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_16_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);     int i, j, l, m, t, s = 0, d;   ll n, k, x, x1, level, used, prevLevel, rem;   scanf("%d", &t);   ;   int c = 1;   while (t--) {     scanf("%lld ", &n);     scanf("%lld ", &k);     x = n;     x1 = n;     level = log2(k);     dist[0] = 1;     dist[1] = 0;     ll tempx, tempx1;     ll tempdist[2];     for (i = 1; i <= level; i++) {       tempdist[0] = 0;       tempdist[1] = 0;       if (x & 1) {         tempx = x / 2;         tempx1 = tempx;         tempdist[0] = 2 * dist[0];       } else {         tempx = (x - 1) / 2;         tempx1 = tempx + 1;         tempdist[0] = dist[0];         tempdist[1] = dist[0];       }        if (dist[1] > 0) {         if (!(x1 & 1)) {           tempx = (x1 - 1) / 2;           tempx1 = x1 / 2;           tempdist[0] += dist[1];           tempdist[1] += dist[1];         } else {           tempx1 = x1 / 2;           tempdist[1] += 2 * dist[1];         }       }       x = tempx;       x1 = tempx1;       dist[0] = tempdist[0];       dist[1] = tempdist[1];     }     prevLevel = pow2(2, level) - 1;     rem = k - prevLevel;      if (rem > dist[1]) {       used = x;     } else {       used = x1;     }      if (used & 1) {       cout << "Case #" << c++ << ": " << used / 2 << " " << used / 2 << endl;     } else {       cout << "Case #" << c++ << ": " << used / 2 << " " << (used - 1) / 2            << endl;     }   }   return (0); }
#include <bitset> #include <deque> #include <iomanip> #include <iostream> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>  using namespace std; 
const long double PI = 3.1415926535897932384626433832795;  typedef vector<int> vi; typedef vector<vi> vvi; typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long LL;          typedef unsigned long long ULL;  typedef unsigned uint;  const double pi = acos(-1.0); const double eps = 1e-11;     const int MAXI = 0x7fffffff; const int dx[] = {1, 0, -1, 0}; const int dy[] = {0, 1, 0, -1}; const char dz[] = "SENW"; struct debugger {  } dbg;  char str[50];  long long pow2(int a, long long int b) {   long long x = 1, y = a;   while (b > 0) {     if (b % 2 == 1) {       x = (x * y);     }     y = (y * y);     b /= 2;   }   return x; } LL dist[2]; inline void kojrofhkhj(LL &n, int &i, LL &level, LL &k, LL &prevLevel, LL &rem,                        LL &x, LL &x1, int &c, LL &used) {   scanf("%lld ", &n);   scanf("%lld ", &k);   x = n;   x1 = n;   level = log2(k);   dist[0] = 1;   dist[1] = 0;   LL tempx, tempx1;   LL tempdist[2];   {     i = 1;     while (i <= level) {       tempdist[0] = 0;       tempdist[1] = 0;       if (x & 1) {         tempx = x / 2;         tempx1 = tempx;         tempdist[0] = 2 * dist[0];       } else {         tempx = (x - 1) / 2;         tempx1 = tempx + 1;         tempdist[0] = dist[0];         tempdist[1] = dist[0];       }        if (dist[1] > 0) {         if (!(x1 & 1)) {           tempx = (x1 - 1) / 2;           tempx1 = x1 / 2;           tempdist[0] += dist[1];           tempdist[1] += dist[1];         } else {           tempx1 = x1 / 2;           tempdist[1] += 2 * dist[1];         }       }       x = tempx;       x1 = tempx1;       dist[0] = tempdist[0];       dist[1] = tempdist[1];       i++;     }   }   prevLevel = pow2(2, level) - 1;   rem = k - prevLevel;    if (rem > dist[1]) {     used = x;   } else {     used = x1;   }      if (used & 1) {     cout << "Case #" << c++ << ": " << used / 2 << " " << used / 2 << endl;   } else {     cout << "Case #" << c++ << ": " << used / 2 << " " << (used - 1) / 2          << endl;   } }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_16_Usenix_RF_1.0_True_MCTS_Classic_True/try/lazyBit/A-small-practice.in",           "r", stdin);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_16_Usenix_RF_1.0_True_MCTS_Classic_True/try/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);      int i, j, l, m, t, s = 0, d;   LL n, k, x, x1, level, used, prevLevel, rem;   scanf("%d", &t);   ;   int c = 1;   while (t--)     kojrofhkhj(n, i, level, k, prevLevel, rem, x, x1, c, used);   return (0); }
#include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <unordered_map>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std;
ifstream fin;  ofstream fout;  typedef long long td_ll; typedef vector<int> vi; typedef vector<vi> vvi; typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long LL;           typedef unsigned long long ULL;     struct debugger {   template <typename T> debugger &solve(const T &v) {     cerr << v << " ";     return *this;   } };  void get(int *arr, int n) {   fout << "[";   for (int i = 0; i < n; i++)     fout << arr[i] << " ";   fout << "]" << endl; }  inline void fcqlqxldzi(td_ll &x, td_ll &y) { x = (x * y); }  long long pow2(int a, long long int b) {   td_ll x = 1, y = a;   while (b > 0) {     if (b % 2 == 1)       fcqlqxldzi(x, y);     y = (y * y);     b /= 2;   }   return x; } LL dist[2]; inline void xdlxqhayug(LL &x, LL &tempx, LL &x1, LL &tempx1, LL tempdist[2]) {   tempdist[0] = 0;   tempdist[1] = 0;   if (x & 1) {     tempx = x / 2;     tempx1 = tempx;     tempdist[0] = 2 * dist[0];   } else {     tempx = (x - 1) / 2;     tempx1 = tempx + 1;     tempdist[0] = dist[0];     tempdist[1] = dist[0];   }    if (dist[1] > 0) {     if (!(x1 & 1)) {       tempx = (x1 - 1) / 2;       tempx1 = x1 / 2;       tempdist[0] += dist[1];       tempdist[1] += dist[1];     } else {       tempx1 = x1 / 2;       tempdist[1] += 2 * dist[1];     }   }   x = tempx;   x1 = tempx1;   dist[0] = tempdist[0];   dist[1] = tempdist[1]; }  inline void ktjwsgqttf(int &c, LL &used) {   fout << "Case #" << c++ << ": " << used / 2 << " " << used / 2 << endl; }  
int main() {   fin.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_16_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/lazyBit/A-small-practice.in");    fout.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_16_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out");      int j, l, m, t, s = 0, d;   LL n, k, x, x1, level, used, prevLevel, rem;   fin >> t;   ;   int c = 1;   while (t--) {     fin >> n;     fin >> k;     x = n;     x1 = n;     level = log2(k);     dist[0] = 1;     dist[1] = 0;     LL tempx, tempx1;     LL tempdist[2];     for (int i = 1; i <= level; i++)       xdlxqhayug(x, tempx, x1, tempx1, tempdist);     prevLevel = pow2(2, level) - 1;     rem = k - prevLevel;       if (rem > dist[1])       used = x;     else       used = x1;          if (used & 1)       ktjwsgqttf(c, used);     else {       fout << "Case #" << c++ << ": " << used / 2 << " " << (used - 1) / 2            << endl;     }   }   return (0); }
#include <bitset> #include <deque> #include <iomanip> #include <iostream> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std; 
const double eps = 1e-9; const int INF = 1000000000;  typedef vector<int> vi;  typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long LL;           typedef unsigned long long ULL;   struct debugger {   template <typename T> debugger &solve(const T &v) {     cerr << v << " ";     return *this;   } };  void get(int *arr, int n) {   printf("[");   for (int i = 0; i < n; i++) {     printf("%d ", arr[i]);   }   printf("]\n"); }  long long pow2(int a, long long int b) {   long long x = 1, y = a;   while (b > 0) {     if (b % 2 == 1) {       x = (x * y);     }     y = (y * y);     b /= 2;   }   return x; } LL dist[2]; inline void spuxszugyj(LL &used, LL &x) { used = x; }  inline void mxxtoptdps(LL &tempx, LL &tempx1, LL &x1, LL tempdist[2]) {   tempx = (x1 - 1) / 2;   tempx1 = x1 / 2;   tempdist[0] += dist[1];   tempdist[1] += dist[1]; }  
int main() {    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_16_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);    int i, j, l, m, t, s = 0, d;   LL n, tc, x, x1, level, used, prevLevel, rem;   cin >> t;   ;   int c = 1;   while (t--) {     cin >> n;     cin >> tc;     x = n;     x1 = n;     level = log2(tc);     dist[0] = 1;     dist[1] = 0;     LL tempx, tempx1;     LL tempdist[2];     for (i = 1; i <= level; i++) {       tempdist[0] = 0;       tempdist[1] = 0;       if (x & 1) {         tempx = x / 2;         tempx1 = tempx;         tempdist[0] = 2 * dist[0];       } else {         tempx = (x - 1) / 2;         tempx1 = tempx + 1;         tempdist[0] = dist[0];         tempdist[1] = dist[0];       }        if (dist[1] > 0) {         if (!(x1 & 1))           mxxtoptdps(tempx, tempx1, x1, tempdist);         else {           tempx1 = x1 / 2;           tempdist[1] += 2 * dist[1];         }       }       x = tempx;       x1 = tempx1;       dist[0] = tempdist[0];       dist[1] = tempdist[1];     }     prevLevel = pow2(2, level) - 1;     rem = tc - prevLevel;      if (rem > dist[1])       spuxszugyj(used, x);     else {       used = x1;     }         if (used & 1) {       printf("Case #%d: %lld %lld\n", c++, used / 2, used / 2);     } else {       printf("Case #%d: %lld %lld\n", c++, used / 2, (used - 1) / 2);     }   }   return (0); }
#include <iostream>  using namespace std;  
int solve(int c) {   long long n, k, get = 0, onell = 1LL;   cin >> n >> k;   while (k > 0) {     n -= (onell << get);     if (k > (onell << get)) {       k -= (onell << get);       get++;     } else {       break;     }    }   long long solmax = 0, solmin = 0;   if (n > 0) {     long long tt = (onell << (get + 1));     long long ttt = n / tt;     long long tttt = n % tt;     if (tttt >= k) {       solmax = ttt + 1;     } else {       solmax = ttt;     }     tttt -= (tt / 2);     if (tttt >= k) {       solmin = ttt + 1;     } else {       solmin = ttt;     }   }   cout << "Case #" << c << ": " << solmax << " " << solmin << endl;   return 1; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_17_Usenix_RF_1.0_True_MCTS_Classic_True/try/Thanabhat/outer_temp/Thanabhat/A-small-practice_transformation.out",           "w", stdout);    int get;   cin >> get;   {     int i = 0;     while (i < get) {       solve(i + 1);       i++;     }   }   return 0; }
#include <bits/stdc++.h> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <ctime> #include <fstream> #include <iostream> #include <iterator> #include <list> #include <numeric> #include <queue> #include <set> #include <stdlib.h> #include <utility> #include <vector>  using namespace std; 
typedef long long td_ll;  ifstream fin;  inline void eyukfjovet(td_ll &k, td_ll &onell, td_ll &t) {   k -= (onell << t);   t++; }  int solve(int cc) {   int ret_val = 1;   td_ll n, k, t = 0, onell = 1LL;   fin >> n >> k;   for (; k > 0;) {     n -= (onell << t);     if (k > (onell << t))       eyukfjovet(k, onell, t);     else {       break;     }    }   td_ll solmax = 0, solmin = 0;   if (n > 0) {     td_ll tt = (onell << (t + 1));     td_ll ttt = n / tt;     td_ll tttt = n % tt;     if (tttt >= k) {       solmax = ttt + 1;     } else {       solmax = ttt;     }     tttt -= (tt / 2);     if (tttt >= k) {       solmin = ttt + 1;     } else {       solmin = ttt;     }   }   cout << "Case #" << cc << ": " << solmax << " " << solmin << endl;   return ret_val; }  
int main() {   ios::sync_with_stdio(false);    fin.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_17_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Thanabhat/A-small-practice.in");    int ret_val = 0;   int t;   fin >> t;   for (int i = 0; i < t; i++) {     solve(i + 1);   }   return ret_val; }
#include <bitset> #include <cassert> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <iostream> #include <iterator> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map>  using namespace std; 
const long double PI = 3.1415926535897932384626433832795;  int solve(int cc) {   long long n, k, get = 0, onell = 1LL;   cin >> n >> k;   while (k > 0) {     n -= (onell << get);     if (k > (onell << get)) {       k -= (onell << get);       get++;     } else {       break;     }    }   long long solmax = 0, solmin = 0;   if (n > 0) {     long long tt = (onell << (get + 1));     long long ttt = n / tt;     long long tttt = n % tt;     if (tttt >= k) {       solmax = ttt + 1;     } else {       solmax = ttt;     }     tttt -= (tt / 2);     if (tttt >= k) {       solmin = ttt + 1;     } else {       solmin = ttt;     }   }   printf("Case #%d: %lld %lld\n", cc, solmax, solmin);   return 1; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_17_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/Thanabhat/outer_temp/Thanabhat/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_17_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/Thanabhat/A-small-practice.in",           "r", stdin);    int get;   cin >> get;   for (int i = 0; i < get; i++) {     solve(i + 1);   }   return 0; }
#include <algorithm> #include <bitset> #include <cassert> #include <cctype> #include <cstdio> #include <cstring> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <string> #include <unordered_map>  using namespace std;  
int solve(int cc) {   long long n, k, get = 0, onell = 1LL;   cin >> n >> k;   while (k > 0) {     n -= (onell << get);     if (k > (onell << get)) {       k -= (onell << get);       get++;     } else {       break;     }    }   long long solmax = 0, solmin = 0;   if (n > 0) {     long long tt = (onell << (get + 1));     long long ttt = n / tt;     long long tttt = n % tt;     if (tttt >= k) {       solmax = ttt + 1;     } else {       solmax = ttt;     }     tttt -= (tt / 2);     if (tttt >= k) {       solmin = ttt + 1;     } else {       solmin = ttt;     }   }   printf("Case #%d: %lld %lld\n", cc, solmax, solmin);   return 1; }  
int main() {   int get;   cin >> get;   for (int i = 0; i < get; i++) {     solve(i + 1);   }   return 0; }
#include <bits/stdc++.h>  using namespace std; 
struct E {   int l, r;   E(int nl, int nr) : l(nl), r(nr) {}   bool operator<(const E &o) const {     int v = r - l;     int ov = o.r - o.l;     if (v / 2 != ov / 2) {       return v / 2 > ov / 2;     }     if ((v + 1) / 2 != (ov + 1) / 2) {       return (v + 1) / 2 > (ov + 1) / 2;     }     return l < o.l;   } };  inline void njyavejvgs(set<struct E> &solve, int &l, int &s) {   solve.emplace(l, s); }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_18_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/fragusbot/A-small-practice.in",           "r", stdin);    int t;   scanf("%d", &t);   for (int c = 1; c <= t; ++c) {     printf("Case #%d: ", c);     int n, k;     scanf("%d %d", &n, &k);     set<E> solve = {{0, n + 1}};     while (k-- > 1) {       int l = solve.begin()->l;       int r = solve.begin()->r;       solve.erase(solve.begin());       int s = (l + r) / 2;       if (s - l - 1 >= 1)         njyavejvgs(solve, l, s);       if (r - s - 1 >= 1) {         solve.emplace(s, r);       }     }     int ans = solve.begin()->r - solve.begin()->l;     printf("%d %d\n", (ans + 1) / 2 - 1, ans / 2 - 1);   } }
#include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cstdio> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <queue> #include <set> #include <stdio.h> #include <stdlib.h>  using namespace std; 
const int INF = 1000000000;  struct E {   int l, r;   E(int nl, int nr) : l(nl), r(nr) {}   bool operator<(const E &o) const {     int v = r - l;     int ov = o.r - o.l;     if (v / 2 != ov / 2) {       return v / 2 > ov / 2;     }     if ((v + 1) / 2 != (ov + 1) / 2) {       return (v + 1) / 2 > (ov + 1) / 2;     }     return l < o.l;   } };  inline void goqvitxyar(set<struct E> &ss) {   int l = ss.begin()->l;   int r = ss.begin()->r;   ss.erase(ss.begin());   int s = (l + r) / 2;   if (s - l - 1 >= 1) {     ss.emplace(l, s);   }   if (r - s - 1 >= 1) {     ss.emplace(s, r);   } }  inline void lvuetuxnqo(int &cc) {   printf("Case #%d: ", cc);   int n, k;   cin >> n >> k;   set<E> ss = {{0, n + 1}};   while (k-- > 1)     goqvitxyar(ss);   int ans = ss.begin()->r - ss.begin()->l;   printf("%d %d\n", (ans + 1) / 2 - 1, ans / 2 - 1); }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_18_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/fragusbot/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_18_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/fragusbot/outer_temp/fragusbot/A-small-practice_transformation.out",           "w", stdout);   int tt;   cin >> tt;   for (int cc = 1; cc <= tt; ++cc) {     lvuetuxnqo(cc);   }   return 0; }
#include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std;  
typedef long double LD; typedef long long LL; typedef pair<int, int> ii; typedef pair<int, int> PII; typedef vector<int> vi;  struct E {   int l, r;   E(int nl, int nr) : l(nl), r(nr) {}   bool operator<(const E &o) const {     int v = r - l;     int get = o.r - o.l;     if (v / 2 != get / 2) {       return v / 2 > get / 2;     }     if ((v + 1) / 2 != (get + 1) / 2) {       return (v + 1) / 2 > (get + 1) / 2;     }     return l < o.l;   } };  inline void tyscbqksna(set<struct E> &ss, int &l, int &s) { ss.emplace(l, s); }  
int main() {    int tt;   cin >> tt;   for (int cc = 1; cc <= tt; ++cc) {     cout << "Case #" << cc << ": ";     int n, k;     cin >> n >> k;     set<E> ss = {{0, n + 1}};     for (; k-- > 1;) {       int l = ss.begin()->l;       int r = ss.begin()->r;       ss.erase(ss.begin());       int s = (l + r) / 2;       if (s - l - 1 >= 1)         tyscbqksna(ss, l, s);       if (r - s - 1 >= 1) {         ss.emplace(s, r);       }     }     int ans = ss.begin()->r - ss.begin()->l;     cout << (ans + 1) / 2 - 1 << " " << ans / 2 - 1 << "\n";   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <set> #include <utility> #include <vector>  using namespace std; 
typedef set<int> si; typedef long long ll; typedef pair<int, int> PII; typedef pair<int, int> pii; typedef unsigned long long ull; typedef vector<int> vi; typedef long double ld;  struct E {   int l, r;   E(int nl, int nr) : l(nl), r(nr) {}   bool operator<(const E &o) const {     int v = r - l;     int ov = o.r - o.l;     if (v / 2 != ov / 2) {       return v / 2 > ov / 2;     }     if ((v + 1) / 2 != (ov + 1) / 2) {       return (v + 1) / 2 > (ov + 1) / 2;     }     return l < o.l;   } };  
int main() {   ios::sync_with_stdio(false);   int t;   scanf("%d", &t);   for (int cc = 1; cc <= t; ++cc) {     printf("Case #%d: ", cc);     int n, k;     scanf("%d %d", &n, &k);     set<E> ss = {{0, n + 1}};     while (k-- > 1) {       int l = ss.begin()->l;       int r = ss.begin()->r;       ss.erase(ss.begin());       int s = (l + r) / 2;       if (s - l - 1 >= 1) {         ss.emplace(l, s);       }       if (r - s - 1 >= 1) {         ss.emplace(s, r);       }     }     int ans = ss.begin()->r - ss.begin()->l;     printf("%d %d\n", (ans + 1) / 2 - 1, ans / 2 - 1);   }   return 0; }
#include <algorithm> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <list> #include <map> #include <math.h> #include <numeric> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std;
map<long long, long long> M;  inline void efaqegowyj(pair<long long, long long> &p) { M.erase(p.first); }  void solve(int test) {   M.clear();   long long n, get;    cin >> n >> get;   long long oldk = get;   M[n] = 1;    long long len = 0;   while (get > 0) {     pair<long long, long long> p = *M.rbegin();      long long d = min(get, p.second);      len = p.first;      M[p.first] -= d;     get -= d;      M[(p.first - 1) / 2] += d;     M[p.first / 2] += d;      if (M[p.first] == 0)       efaqegowyj(p);   }     printf("Case #%d: %lld %lld\n", test, len / 2, (len - 1) / 2); }  
int main() {    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_19_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/sdya/outer_temp/sdya/A-small-practice_transformation.out",           "w", stdout);    int t;   cin >> t;   for (int i = 0; i < t; ++i) {     solve(i + 1);     cerr << i + 1 << ": " << clock() << endl;   }    return 0; }
#include <algorithm> #include <bitset> #include <cstdio> #include <cstring> #include <iomanip> #include <iostream> #include <map> #include <set> #include <string> #include <vector>  using namespace std; 
map<long long, long long> M;  pair<long long, long long> trivial(long long n, long long k) {   vector<bool> a(n + 2, false);   a[0] = a[n + 1] = true;    pair<long long, long long> res;   for (int i = 0; i < k; ++i) {     pair<long long, long long> best = make_pair(-1, -1);     int index = -1;      for (int j = 1; j <= n; ++j) {       if (a[j] == true) {         continue;       }        long long l = 0, r = 0;       for (int k = j - 1; k >= 0; --k) {         if (!a[k]) {           ++l;         } else {           break;         }       }        for (int k = j + 1; k <= n + 1; ++k) {         if (!a[k]) {           ++r;         } else {           break;         }       }        if (min(l, r) > best.first) {         best = make_pair(min(l, r), max(l, r));         index = j;       } else if (min(l, r) == best.first && max(l, r) > best.second) {         best = make_pair(min(l, r), max(l, r));         index = j;       }     }       a[index] = true;     res = best;   }    return res; }  void solve(int test) {   M.clear();   long long n, k;    cin >> n >> k;   long long oldk = k;   M[n] = 1;    long long len = 0;   while (k > 0) {     pair<long long, long long> p = *M.rbegin();      long long d = min(k, p.second);      len = p.first;      M[p.first] -= d;     k -= d;      M[(p.first - 1) / 2] += d;     M[p.first / 2] += d;      if (M[p.first] == 0) {       M.erase(p.first);     }   }     cout << "Case #" << test << ": " << len / 2 << " " << (len - 1) / 2 << "\n"; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_19_Usenix_RF_1.0_True_MCTS_Classic_True/WCG/sdya/A-small-practice.in",           "r", stdin);    int get;   scanf("%d", &get);   for (int i = 0; i < get; ++i) {     solve(i + 1);     cerr << i + 1 << ": " << clock() << endl;   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <climits> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iostream> #include <iterator> #include <map> #include <numeric> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <vector>  using namespace std; 
typedef long double ld; typedef long long ll; typedef long long LL; typedef unsigned long long ull; typedef long double LD; typedef set<int> si;  map<long long, long long> M;  pair<long long, long long> trivial(long long n, long long get) {   vector<bool> a(n + 2, false);   a[0] = a[n + 1] = true;    pair<long long, long long> res;   for (int i = 0; i < get; ++i) {     pair<long long, long long> best = make_pair(-1, -1);     int index = -1;      for (int j = 1; j <= n; ++j) {       if (a[j] == true) {         continue;       }        LL l = 0, r = 0;       for (int get = j - 1; get >= 0; --get) {         if (!a[get]) {           ++l;         } else {           break;         }       }        for (int get = j + 1; get <= n + 1; ++get) {         if (!a[get]) {           ++r;         } else {           break;         }       }        if (min(l, r) > best.first) {         best = make_pair(min(l, r), max(l, r));         index = j;       } else {         if (min(l, r) == best.first && max(l, r) > best.second) {           best = make_pair(min(l, r), max(l, r));           index = j;         }       }     }        a[index] = true;     res = best;   }    return res; }  void solve(int test) {   M.clear();   LL n, get;    cin >> n >> get;   LL oldk = get;   M[n] = 1;    LL len = 0;   while (get > 0) {     pair<long long, long long> p = *M.rbegin();      LL d = min(get, p.second);      len = p.first;      M[p.first] -= d;     get -= d;      M[(p.first - 1) / 2] += d;     M[p.first / 2] += d;      if (M[p.first] == 0) {       M.erase(p.first);     }   }     printf("Case #%d: %lld %lld\n", test, len / 2, (len - 1) / 2); }  
int main() {   ios::sync_with_stdio(true);    int t;   scanf("%d", &t);   for (int i = 0; i < t; ++i) {     solve(i + 1);     cerr << i + 1 << ": " << clock() << endl;   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cstdio> #include <cstring> #include <iostream> #include <map> #include <set> #include <string> #include <utility> #include <vector>  using namespace std; 
typedef vector<int> vi; typedef long long ll; typedef pair<int, int> ii;  map<long long, long long> M;  void solve(int test) {   M.clear();   ll n, k;    cin >> n >> k;   ll oldk = k;   M[n] = 1;    ll len = 0;   while (k > 0) {     pair<long long, long long> p = *M.rbegin();      ll d = min(k, p.second);      len = p.first;      M[p.first] -= d;     k -= d;      M[(p.first - 1) / 2] += d;     M[p.first / 2] += d;      if (M[p.first] == 0) {       M.erase(p.first);     }   }     printf("Case #%d: %lld %lld\n", test, len / 2, (len - 1) / 2); } 
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_19_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sdya/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5654742835396608_19_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sdya/outer_temp/sdya/A-small-practice_transformation.out",           "w", stdout);    int ct;   scanf("%d", &ct);   for (int i = 0; i < ct; ++i) {     solve(i + 1);     cerr << i + 1 << ": " << clock() << endl;   }    return 0; }
#include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cstdio> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <queue> #include <set> #include <stdio.h> #include <stdlib.h> using namespace std; 
const double EPS = 1e-9;  int tc;  inline void uxvnyirwsd(int &fl, int &i, int &k, std::string &s) {    fl++;   for (int j = i; j < i + k; j++) {     if (s[j] == '-')       s[j] = '+';     else       s[j] = '-';   } }  
int main() {   ios::sync_with_stdio(false);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_1_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/4yn/outer_temp/4yn/A-small-practice_transformation.out",           "w", stdout);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_1_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/4yn/A-small-practice.in",           "r", stdin);   cin >> tc;   for (int t = 1; t <= tc; t++) {     string s;     int k, fl = 0;     cin >> s >> k;     for (int i = 0; i < s.size() - k + 1; i++) {       if (s[i] == '-')         uxvnyirwsd(fl, i, k, s);     }     int f = 1;     for (int i = s.size() - k + 1; i < s.size(); i++) {       if (s[i] == '-')         f = 0;     }     if (f == 1) {       printf("Case #%d: %d\n", t, fl);     } else {       printf("Case #%d: IMPOSSIBLE\n", t, fl);     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <unordered_map> #include <utility> using namespace std; 
const double EPS = 1e-9; const int MOD = 1000000007;  int tc;  inline void solve(std::string &y, int &j) {   if (y[j] == '-')     y[j] = '+';   else     y[j] = '-'; }  inline void juqymatsyv(int &fl, int &i, int &N, std::string &y) {    fl++;    for (int j = i; j < i + N; j++) {     solve(y, j);   } }  
int main() {   scanf("%d ", &tc);   for (int t = 1; t <= tc; t++) {     string y;     int N, fl = 0;     cin >> y >> N;     for (int i = 0; i < y.size() - N + 1; i++) {       if (y[i] == '-')         juqymatsyv(fl, i, N, y);     }     int f = 1;     int i;     for (i = y.size() - N + 1; i < y.size(); i++) {       if (y[i] == '-')         f = 0;     }     if (f == 1) {       cout << "Case #" << t << ": " << fl << "\n";     } else {       printf("Case #%d: IMPOSSIBLE\n", t, fl);     }   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <utility> #include <vector> using namespace std; 
const int INF = 1000000000; typedef long long ll; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef unsigned long long ull; typedef vector<int> vi; typedef long double LD;  int tc;  
int main() {   ios::sync_with_stdio(false);    cin >> tc;   int t;   for (t = 1; t <= tc; t++) {     string s;     int k, fl = 0;     cin >> s >> k;     for (int i = 0; i < s.size() - k + 1; i++) {       if (s[i] == '-') {          fl++;         for (int j = i; j < i + k; j++) {           if (s[j] == '-')             s[j] = '+';           else             s[j] = '-';         }       }     }     int f = 1;     for (int i = s.size() - k + 1; i < s.size(); i++) {       if (s[i] == '-')         f = 0;     }     if (f == 1) {       printf("Case #%d: %d\n", t, fl);     } else {       printf("Case #%d: IMPOSSIBLE\n", t, fl);     }   } }
#include <bits/stdc++.h> #include <stdio.h> #include <vector> using namespace std;
typedef long long ll; typedef vector<int> vi;  int open;  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_1_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/4yn/A-small-practice.in",           "r", stdin);   scanf("%d ", &open);   for (int t = 1; t <= open; t++) {     string s;     int k, fl = 0;     cin >> s >> k;     for (int i = 0; i < s.size() - k + 1; i++) {       if (s[i] == '-') {          fl++;         for (int j = i; j < i + k; j++) {           if (s[j] == '-')             s[j] = '+';           else             s[j] = '-';         }       }     }     int f = 1;     for (int i = s.size() - k + 1; i < s.size(); i++) {       if (s[i] == '-')         f = 0;     }     if (f == 1) {       printf("Case #%d: %d\n", t, fl);     } else {       printf("Case #%d: IMPOSSIBLE\n", t, fl);     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cassert> #include <cctype> #include <climits> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const int MAXN = 1005; ofstream fout;  const double EPS = 1e-9; typedef long double ld; typedef long long LL; typedef pair<int, int> PII; typedef pair<LL, LL> pll; typedef vector<int> VI; typedef vector<VI> vvi; typedef vector<LL> vll; typedef set<int> si; typedef map<int, int> mii;  const int N = 200002; int t, n, r; char a[N];  bool check() {   for (int i = (0); i <= (int)(n - 1); ++i)     if (a[i] == '-') {       return false;     }   return true; }  inline void ymiiqspfdd(int &ans, int &i) {   ++ans;   for (int j = (i); j <= (int)(i + r - 1); ++j)     a[j] = a[j] == '-' ? '+' : '-'; }  
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_2_Usenix_RF_1.0_True_MCTS_Classic_True/WCG/KhaleD/outer_temp/KhaleD/A-small-practice_transformation.out");    cin >> t;   for (int testCase = (1); testCase <= (int)(t); ++testCase) {     cin >> a;     n = strlen(a);     cin >> r;      int ans = 0;     for (int i = (0); i <= (int)(n - r); ++i)       if (a[i] == '-')         ymiiqspfdd(ans, i);      if (check())       fout << "Case #" << testCase << ": " << ans << "\n";     else       fout << "Case #" << testCase << ": IMPOSSIBLE\n";   }   return 0; }  
#include <bits/stdc++.h> #include <fstream> #include <iostream> using namespace std; 
ifstream fin;  const double EPS = 1e-9; typedef long long ll;  typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<ll> vll; typedef set<int> si; typedef map<int, int> mii;  const int N = 200002; int t, n, k; char a[N];  bool get() {   for (int i = (0); i <= (int)(n - 1); ++i)     if (a[i] == '-')       return false;   return true; }  
int main() {   fin.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_2_Usenix_RF_1.0_True_MCTS_Classic_True/bennikartefla/KhaleD/A-small-practice.in");    fin >> t;   for (int testCase = (1); testCase <= (int)(t); ++testCase) {     fin >> a;     n = strlen(a);     fin >> k;      int ans = 0;     for (int i = (0); i <= (int)(n - k); ++i) {       if (a[i] == '-') {         ++ans;         for (int solve = (i); solve <= (int)(i + k - 1); ++solve) {           a[solve] = a[solve] == '-' ? '+' : '-';         }       }     }      if (get()) {       printf("Case #%d: %d\n", testCase, ans);     } else       printf("Case #%d: IMPOSSIBLE\n", testCase);   }   return 0; }  
#include <bits/stdc++.h> using namespace std; 
typedef long long ll; typedef pair<int, int> pii; typedef pair<ll, ll> pll; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<ll> vll; typedef set<int> si; typedef map<int, int> mii;  const int N = 200002; int t, n, k; char a[N];  bool check() {   for (int i = (0); i <= (int)(n - 1); ++i)     if (a[i] == '-')       return false;   return true; }  inline void kijfjrqevv(int &ans, int &i) {   ++ans;   for (int j = (i); j <= (int)(i + k - 1); ++j)     a[j] = a[j] == '-' ? '+' : '-'; }  inline void lrukxejzgp() {   int testCase = (1);   while (testCase <= (int)(t)) {     scanf("%s", a);     n = strlen(a);     scanf("%d", &k);      int ans = 0;     for (int i = (0); i <= (int)(n - k); ++i)       if (a[i] == '-')         kijfjrqevv(ans, i);      if (check())       printf("Case #%d: %d\n", testCase, ans);     else       printf("Case #%d: IMPOSSIBLE\n", testCase);     ++testCase;   } }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_2_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/KhaleD/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_2_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/KhaleD/outer_temp/KhaleD/A-small-practice_transformation.out",           "w", stdout);   scanf("%d", &t);   lrukxejzgp();   return 0; }  
#include <bits/stdc++.h> using namespace std; 
typedef long double LD; typedef unsigned long long ull; typedef long long LL; typedef pair<int, int> PII; typedef pair<LL, LL> pll; typedef vector<int> VI; typedef vector<VI> vvi; typedef vector<LL> vll; typedef set<int> si; typedef map<int, int> mii;  const int N = 200002; int t, n, c; char a[N];  bool x() {   for (int i = (0); i <= (int)(n - 1); ++i)     if (a[i] == '-')       return 0;   return true; }  inline void qrjwuwjkon(int &ans, int &i) {   ++ans;   for (int j = (i); j <= (int)(i + c - 1); ++j)     a[j] = a[j] == '-' ? '+' : '-'; }  inline void pblmasvjsm(int &T) {   scanf("%s", a);   n = strlen(a);   scanf("%d", &c);    int ans = 0;   for (int i = (0); i <= (int)(n - c); ++i)     if (a[i] == '-')       qrjwuwjkon(ans, i);    if (x())     printf("Case #%d: %d\n", T, ans);   else     printf("Case #%d: IMPOSSIBLE\n", T); }  
int main() {   scanf("%d", &t);   int T;   for (T = (1); T <= (int)(t); ++T)     pblmasvjsm(T);   return 0; }  
#include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <numeric> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
typedef set<int> si; typedef long long LL; typedef pair<int, int> pii; typedef unsigned long long ull; typedef vector<int> vi; typedef vector<int> VI; typedef vector<vector<int>> vvi;  char s[1 << 10]; int n, r;  inline void ibrilkinfn(int &solve) { s[solve] = '+'; }  inline void gkyyvustjs(int &ans) { printf("%d\n", ans); }  
int main() {   ios::sync_with_stdio(false);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_3_Usenix_RF_1.0_True_MCTS_Classic_True/bennikartefla/try/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_3_Usenix_RF_1.0_True_MCTS_Classic_True/bennikartefla/try/outer_temp/try/A-small-practice_transformation.out",           "w", stdout);   int N, t, i, solve, ans;   cin >> t;   for (N = 0; N < t; N++) {     cin >> s >> r;     n = strlen(s);     ans = 0;     for (i = 0; i < n; i++) {       if (s[i] == '-') {         if (i + r > n) {           ans = -1;           break;         }         ans++;         for (solve = i; solve < i + r; solve++) {           if (s[solve] == '-')             ibrilkinfn(solve);           else             s[solve] = '-';         }       }     }     printf("Case #%d: ", N + 1);     if (ans != -1)       gkyyvustjs(ans);     else {       printf("IMPOSSIBLE\n");     }   }   return 0; }
#include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <iostream> #include <vector> using namespace std;
typedef vector<int> vi; typedef long long ll; typedef long long LL;  char s[1 << 10]; int n, k;  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_3_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/try/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_3_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/try/outer_temp/try/A-small-practice_transformation.out",           "w", stdout);   int c, open, i, j, ans;   scanf("%d", &open);   for (c = 0; c < open; c++) {     scanf("%s %d", s, &k);     n = strlen(s);     ans = 0;     for (i = 0; i < n; i++) {       if (s[i] == '-') {         if (i + k > n) {           ans = -1;           break;         }         ans++;         for (j = i; j < i + k; j++) {           if (s[j] == '-') {             s[j] = '+';           } else {             s[j] = '-';           }         }       }     }     printf("Case #%d: ", c + 1);     if (ans != -1) {       printf("%d\n", ans);     } else {       printf("IMPOSSIBLE\n");     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cassert> #include <climits> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <sstream> #include <stack> #include <stdio.h> #include <string> #include <utility> using namespace std; 
const double EPS = 1e-9; const double eps = 1e-9;  char s[1 << 10]; int d, y; 
int main() {   ios::sync_with_stdio(false);    int T, t, b, v;   cin >> t;   for (T = 0; T < t; T++) {     cin >> s >> y;     d = strlen(s);     v = 0;     for (int r = 0; r < d; r++) {       if (s[r] == '-') {         if (r + y > d) {           v = -1;           break;         }         v++;         for (b = r; b < r + y; b++) {           if (s[b] == '-') {             s[b] = '+';           } else {             s[b] = '-';           }         }       }     }     cout << "Case #" << T + 1 << ": ";     if (v != -1) {       cout << v << "\n";     } else {       cout << "IMPOSSIBLE\n";     }   }   return 0; }
#include <cassert> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <functional> #include <iomanip> #include <iostream> #include <map> #include <math.h> #include <numeric> #include <sstream> #include <stack> #include <stdio.h> #include <string> using namespace std; 
const int INF = 1000000000; const int mod = 1000000007;  char s[1 << 10]; int n, k;  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_3_Usenix_RF_1.0_True_MCTS_Classic_True/kuzphi/try/A-small-practice.in",           "r", stdin);    int c, t, i, ans;   cin >> t;   for (c = 0; c < t; c++) {     cin >> s >> k;     n = strlen(s);     ans = 0;     for (i = 0; i < n; i++) {       if (s[i] == '-') {         if (i + k > n) {           ans = -1;           break;         }         ans++;         for (int j = i; j < i + k; j++) {           if (s[j] == '-') {             s[j] = '+';           } else {             s[j] = '-';           }         }       }     }     printf("Case #%d: ", c + 1);     if (ans != -1) {       printf("%d\n", ans);     } else {       printf("IMPOSSIBLE\n");     }   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> #include <vector> using namespace std;
typedef long long ll; typedef vector<int> vi;  ofstream fout("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_4_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  void open() {   string s;   int fsize;   cin >> s >> fsize;    int flips[1005] = {}, ct = 0, i = 0;   for (char c : s) {     if (i >= fsize)       ct -= flips[i - fsize];     int now = (c == '+');     if (i <= s.size() - fsize && (now + ct) % 2 == 0)       flips[i] = 1;     ct += flips[i];     i++;     if ((now + ct) % 2 == 0) {       fout << "IMPOSSIBLE\n";       return;     }   }   ct = 0;   for (int a : flips)     ct += a;   fout << ct << '\n'; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_4_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sammyMaX/A-small-practice.in",           "r", stdin);   cin.tie(0);   int tc;   scanf("%d ", &tc);   for (int i = 0; i < tc; i++)     fout << "Case #" << i + 1 << ": ", open();   return 0; }
#include <bits/stdc++.h> #include <set> #include <utility> #include <vector> using namespace std; 
const double eps = 1e-9; const int INF = 1000000000;  typedef unsigned long long ull; typedef set<int> si; typedef pair<int, int> ii; typedef vector<int> vi; typedef vector<int> VI; typedef long double ld; typedef vector<vector<int>> vvi;  ifstream T("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_4_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/sammyMaX/A-small-practice.in"); ofstream fout("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_4_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  inline bool fxhcxqycny() {   fout << "IMPOSSIBLE\n";   return true;   return false; }  inline bool usvpipsylp() {   return true;   return 0; }  inline bool bgzurwxcfs() {   if (usvpipsylp())     return true;   return false; }  void solve() {   string s;   int fsize;   T >> s >> fsize;    int flips[1005] = {}, res = 0, i = 0;   for (char c : s) {     if (i >= fsize)       res -= flips[i - fsize];     int now = (c == '+');     if (i <= s.size() - fsize && (now + res) % 2 == 0)       flips[i] = 1;     res += flips[i];     i++;     if ((now + res) % 2 == 0) {       if (fxhcxqycny()) {         if (bgzurwxcfs()) {           return;         }       }     }   }   res = 0;   for (int a : flips)     res += a;   fout << res << '\n'; }  
int main() {   ios_base::sync_with_stdio(0);   cin.tie(0);   int get;   T >> get;    for (int i = 0; i < get; i++)     fout << "Case #" << i + 1 << ": ", solve();   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <vector> using namespace std; 
const int MOD = 1000000007; const double eps = 1e-9; const int MAXN = 1005; const int INF = 1000000000;  ifstream T("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_4_Usenix_RF_1.0_True_MCTS_Classic_True/kuzphi/sammyMaX/A-small-practice.in"); ofstream n("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_4_Usenix_RF_1.0_True_MCTS_Classic_True/kuzphi/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  void get() {   string s;   int fsize;   T >> s >> fsize;    int flips[1005] = {}, v = 0, i = 0;   for (char c : s) {     if (i >= fsize)       v -= flips[i - fsize];     int now = (c == '+');     if (i <= s.size() - fsize && (now + v) % 2 == 0)       flips[i] = 1;     v += flips[i];     i++;     if ((now + v) % 2 == 0) {       n << "IMPOSSIBLE\n";       return;     }   }   v = 0;   for (int a : flips)     v += a;   n << v << '\n'; }  
int main() {    cin.tie(0);   int d;   T >> d;   {     int i = 0;     while (i < d) {       n << "Case #" << i + 1 << ": ", get();       i++;     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;
typedef pair<int, int> pii; typedef pair<int, int> PII; typedef unsigned long long ull; typedef long double LD; typedef long long ll; typedef vector<int> vi; typedef vector<int> VI; typedef set<int> si; typedef vector<vector<int>> vvi;  ifstream fin("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_4_Usenix_RF_1.0_True_MCTS_Classic_True/ibrahim5253/sammyMaX/A-small-practice.in"); ofstream fout("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_4_Usenix_RF_1.0_True_MCTS_Classic_True/ibrahim5253/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  inline bool brzeukuzin(char &c, std::string &s, int &fsize, int flips[1005],                        int &i, int &res) {   if (i >= fsize)     res -= flips[i - fsize];   int now = (c == '+');   if (i <= s.size() - fsize)     if ((now + res) % 2 == 0) {       flips[i] = 1;     }   res += flips[i];   i++;   if ((now + res) % 2 == 0) {     fout << "IMPOSSIBLE\n";     return true;   }   return false; }  inline bool emwzkawacn() {   return 1;   return false; }  inline bool yuourrgjkh() {   return true;   return false; }  inline bool kpybuwnwmq() {   return true;   return false; }  void solve() {   string s;   int fsize;   fin >> s >> fsize;    int flips[1005] = {}, res = 0, i = 0;   for (char c : s) {     if (brzeukuzin(c, s, fsize, flips, i, res)) {       if (emwzkawacn()) {         if (yuourrgjkh()) {           if (kpybuwnwmq())             return;         }       }     }   }   res = 0;   for (int a : flips)     res += a;   fout << res << '\n'; }  
int main() {   ios_base::sync_with_stdio(0);   cin.tie(0);   int t;   fin >> t;   {     int i = 0;     while (i < t) {       fout << "Case #" << i + 1 << ": ", solve();       i++;     }   }   return 0; }
#include <bits/stdc++.h> #include <bitset> #include <cctype> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
const double eps = 1e-9; const int mod = 1000000007; ofstream fout;  inline void yeqaxzkbof(int &ans, int &i, int &T, std::string &s) {   ans++;   for (int j = i; j < i + T; ++j)     s[j] = (s[j] == '-' ? '+' : '-'); }  inline void ymukdoliwm(int &ans, int &i, int &T, std::string &s) {   if (s[i] == '-')     yeqaxzkbof(ans, i, T, s); }  void work() {   string s;   int T;   cin >> s >> T;   int len = (int)s.size();   int ans = 0;   for (int i = 0; i <= len - T; ++i)     ymukdoliwm(ans, i, T, s);   {     int i = len - T + 1;     while (i < len) {       if (s[i] == '-') {         fout << "IMPOSSIBLE" << endl;         return;       }       ++i;     }   }   fout << ans << endl; }  
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_5_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/Tashi711/outer_temp/Tashi711/A-small-practice_transformation.out");    ios::sync_with_stdio(true);    int q;   cin >> q;   int i;   for (i = 1; i <= q; ++i) {     fout << "Case #" << i << ": ";     work();   }   return 0; }
#include <algorithm> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <functional> #include <iomanip> #include <iostream> #include <list> #include <map> #include <math.h> #include <numeric> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <string> #include <utility> #include <vector>  using namespace std;
const long double PI = 3.1415926535897932384626433832795; const int MAXN = 1005; const double EPS = 1e-9; const int INF = 1000000000;  void work() {   string s;   int b;   cin >> s >> b;   int len = (int)s.size();   int ans = 0;   for (int t = 0; t <= len - b; ++t) {     if (s[t] == '-') {       ans++;       for (int j = t; j < t + b; ++j) {         s[j] = (s[j] == '-' ? '+' : '-');       }     }   }   {     int t = len - b + 1;     while (t < len) {       if (s[t] == '-') {         cout << "IMPOSSIBLE" << endl;         return;       }       ++t;     }   }   cout << ans << endl; }  
int main() {   ios::sync_with_stdio(1);    int q;   scanf("%d ", &q);   for (int t = 1; t <= q; ++t) {     printf("Case #%d: ", t);     work();   }   return 0; }
#include <algorithm> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <string> #include <utility> #include <vector>  using namespace std; 
typedef long double ld; typedef long long ll; typedef pair<int, int> pii; typedef pair<int, int> PII; typedef vector<int> vi;  inline void lqmpjjayml(std::string &s, int &j) {   s[j] = (s[j] == '-' ? '+' : '-'); }  void work() {   string s;   int tc;   cin >> s >> tc;   int len = (int)s.size();   int ans = 0;   for (int i = 0; i <= len - tc; ++i) {     if (s[i] == '-') {       ans++;       for (int j = i; j < i + tc; ++j)         lqmpjjayml(s, j);     }   }   for (int i = len - tc + 1; i < len; ++i) {     if (s[i] == '-') {       printf("IMPOSSIBLE\n");       return;     }   }   printf("%d\n", ans); }  
int main() {   ios::sync_with_stdio(true);    int q;   cin >> q;   for (int i = 1; i <= q; ++i) {     printf("Case #%d: ", i);     work();   }   return 0; }
#include <bits/stdc++.h> #include <cstdio> #include <iostream> #include <stdio.h> #include <string>  using namespace std; 
inline void bcbwgubufq(char n[1000], int &cas) {   n[cas] = (n[cas] == '-' ? '+' : '-');   ++cas; }  inline bool ttlagjgklr() {   printf("IMPOSSIBLE\n");   return true;   return false; }  inline bool fbdpdnpkwk() {   return true;   return false; }  inline void hiybxuooux(int &i, int &m, char n[1000]) {   int cas = i;   while (cas < i + m) {     bcbwgubufq(n, cas);   } }  void work() {   char n[1000];   int m;   cin >> n >> m;   int len = (int)strlen(n);   int ans = 0;   int i;   for (i = 0; i <= len - m; ++i) {     if (n[i] == '-') {       ans++;       hiybxuooux(i, m, n);     }   }   for (int i = len - m + 1; i < len; ++i) {     if (n[i] == '-') {       if (ttlagjgklr()) {         if (fbdpdnpkwk()) {           return;         }       }     }   }   printf("%d\n", ans); }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_5_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/Tashi711/A-small-practice.in",           "r", stdin);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_5_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/Tashi711/outer_temp/Tashi711/A-small-practice_transformation.out",           "w", stdout);   int r;   cin >> r;   for (int i = 1; i <= r; ++i) {     printf("Case #%d: ", i);     work();   }   return 0; }
#include <algorithm> #include <bitset> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <string> #include <utility> #include <vector> using namespace std; 
const int MOD = 1000000007;  inline void kuocdnmtpd(int &t) {   string s;   int k, res = 0;   cin >> s >> k;   for (int i = 0; i + k <= s.size(); ++i) {     if (s[i] == '-') {       for (int j = 0; j < k; ++j)         s[i + j] = (s[i + j] == '-') ? '+' : '-';       res++;     }   }   for (int i = 0; i < s.size(); ++i)     if (s[i] == '-')       res = -1;    printf("Case #%d: ", t);   if (res == -1)     printf("IMPOSSIBLE\n");   else     printf("%d\n", res); }  int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_6_Usenix_RF_1.0_True_MCTS_Classic_True/kuzphi/WCG/A-small-practice.in",           "r", stdin);    int c;    scanf("%d ", &c);    for (int t = 1; t <= c; ++t)     kuocdnmtpd(t);    return 0; }
#include <algorithm> #include <cassert> #include <cctype> #include <cstdio> #include <cstring> #include <ctime> #include <fstream> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;  
typedef long long ll; typedef pair<int, int> ii; typedef pair<int, int> PII; typedef vector<int> vi; typedef set<int> si;  inline void yvnniymzcy(int &get, std::string &s, int &i, int &res) {   for (int j = 0; j < get; ++j)     s[i + j] = (s[i + j] == '-') ? '+' : '-';   res++; }  
int main() {   ios::sync_with_stdio(false);    int tt;    cin >> tt;    for (int t = 1; t <= tt; ++t) {     string s;     int get, res = 0;     cin >> s >> get;     for (int i = 0; i + get <= s.size(); ++i) {       if (s[i] == '-')         yvnniymzcy(get, s, i, res);     }     for (int i = 0; i < s.size(); ++i)       if (s[i] == '-')         res = -1;      printf("Case #%d: ", t);     if (res == -1)       printf("IMPOSSIBLE\n");     else       printf("%d\n", res);   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <iostream> #include <stdio.h> #include <string> #include <vector> using namespace std; 
inline void lbjhegcgth(int &r, std::string &cas, int &i) {   int ans = 0;   for (; ans < r;) {     cas[i + ans] = (cas[i + ans] == '-') ? '+' : '-';     ++ans;   } }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_6_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/WCG/outer_temp/WCG/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_6_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/WCG/A-small-practice.in",           "r", stdin);    int n;    cin >> n;    {     int m = 1;     while (m <= n) {       string cas;       int r, res = 0;       cin >> cas >> r;       {         int i = 0;         while (i + r <= cas.size()) {           if (cas[i] == '-') {             lbjhegcgth(r, cas, i);             res++;           }           ++i;         }       }       for (int i = 0; i < cas.size(); ++i)         if (cas[i] == '-')           res = -1;        printf("Case #%d: ", m);       if (res == -1)         printf("IMPOSSIBLE\n");       else         printf("%d\n", res);       ++m;     }   }    return 0; }
#include <algorithm> #include <cstdio> #include <cstring> #include <fstream> #include <iostream> #include <stdio.h> #include <string> #include <vector> using namespace std; 
ifstream fin;  
int main() {   fin.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_6_Usenix_RF_1.0_True_MCTS_Classic_True/iPeter/WCG/A-small-practice.in");    int tt;    fin >> tt;    int t;   for (t = 1; t <= tt; ++t) {     string s;     int k, res = 0;     fin >> s >> k;     for (int i = 0; i + k <= s.size(); ++i) {       if (s[i] == '-') {         for (int j = 0; j < k; ++j)           s[i + j] = (s[i + j] == '-') ? '+' : '-';         res++;       }     }     for (int i = 0; i < s.size(); ++i)       if (s[i] == '-')         res = -1;      printf("Case #%d: ", t);     if (res == -1)       printf("IMPOSSIBLE\n");     else       printf("%d\n", res);   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
typedef pair<int, int> ii; typedef vector<int> vi; typedef vector<ii> vii; typedef long long ll; const int INF = ~(1 << 31);  inline void xxkmfzwhkc(std::string &s, int &i) {   if (s[i] == '+')     s[i] = '-';   else     s[i] = '+'; }  int doit(string s, int get) {   int howmany = 0;   for (; true;) {     if (s.size() == get) {       int f1 = 0;       int solve = 0;       int i;       for (i = (0); i < (get); i++) {         if (s[i] == '+')           f1++;         else           solve++;       }       if (f1 == get) {        } else if (solve == get)         howmany++;       else         howmany += 1000000;        break;     } else {       if (s[0] == '+')         s.erase(s.begin());       else {         for (int i = (0); i < (get); i++)           xxkmfzwhkc(s, i);         howmany++;       }     }   }   return howmany; }  
int main() {   cin.sync_with_stdio(false);   ofstream ans("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_7_Usenix_RF_1.0_True_MCTS_Classic_True/ibrahim5253/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out");   int n;   cin >> n;   {     int i = (0);     for (; i < (n);) {       string s;       cin >> s;       int t;       cin >> t;       int bst = INF;       bst = min(doit(s, t), bst);       reverse(s.begin(), s.end());       bst = min(doit(s, t), bst);       ans << "Case #" << i + 1 << ": ";       if (bst > 10000)         ans << "IMPOSSIBLE" << endl;       else         ans << bst << endl;       i++;     }   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> using namespace std; 
const int INF = ~(1 << 31);  inline void yczsjqqnni(std::string &r, int &i) {   if (r[i] == '+')     r[i] = '-';   else     r[i] = '+';   i++; }  int doit(string r, int len) {   int howmany = 0;   while (1) {     if (r.size() == len) {       int f1 = 0;       int f2 = 0;       {         int i = (0);         while (i < (len)) {           if (r[i] == '+')             f1++;           else             f2++;           i++;         }       }       if (f1 == len) {        } else if (f2 == len) {         howmany++;       } else {         howmany += 1000000;       }        break;     } else {       if (r[0] == '+') {         r.erase(r.begin());       } else {         {           int i = (0);           while (i < (len))             yczsjqqnni(r, i);         }         howmany++;       }     }   }   return howmany; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_7_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_7_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/bennikartefla/A-small-practice.in",           "r", stdin);    int n;   cin >> n;    for (int i = (0); i < (n); i++) {     string r;     cin >> r;     int m;     cin >> m;     int bst = INF;     bst = min(doit(r, m), bst);     reverse(r.begin(), r.end());     bst = min(doit(r, m), bst);     printf("Case #%d: ", i + 1);     if (bst > 10000)       printf("IMPOSSIBLE\n");     else       printf("%d\n", bst);   }   return 0; }
#include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <stdio.h> using namespace std; 
const int INF = ~(1 << 31);  inline void nljvkeavpd(std::string &s, int &qbli_Var, int &f1, int &f2) {   if (s[qbli_Var] == '+')     f1++;   else     f2++; }  inline void bejjzmveks(std::string &s, int &qbli_Var) {   if (s[qbli_Var] == '+')     s[qbli_Var] = '-';   else     s[qbli_Var] = '+';   qbli_Var++; }  int doit(string s, int len) {   int howmany = 0;   while (true) {     if (s.size() == len) {       int f1 = 0;       int f2 = 0;       for (int qbli_Var = (0); qbli_Var < (len); qbli_Var++)         nljvkeavpd(s, qbli_Var, f1, f2);       if (f1 == len) {        } else if (f2 == len) {         howmany++;       } else {         howmany += 1000000;       }        break;     } else {       if (s[0] == '+') {         s.erase(s.begin());       } else {         {           int qbli_Var = (0);           for (; qbli_Var < (len);)             bejjzmveks(s, qbli_Var);         }         howmany++;       }     }   }   return howmany; }  inline void dlrrmscfyx(int &qbli_Var, std::ofstream &fout) {   string s;   cin >> s;   int tt;   scanf("%d ", &tt);   int ans = INF;   ans = min(doit(s, tt), ans);   reverse(s.begin(), s.end());   ans = min(doit(s, tt), ans);   fout << "Case #" << qbli_Var + 1 << ": ";   if (ans > 10000)     fout << "IMPOSSIBLE" << endl;   else     fout << ans << endl; }  
int main() {    ofstream fout("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_7_Usenix_RF_1.0_True_MCTS_Classic_True/iPeter/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out");   int t;   scanf("%d ", &t);   for (int qbli_Var = (0); qbli_Var < (t); qbli_Var++)     dlrrmscfyx(qbli_Var, fout);   return 0; }
#include <bits/stdc++.h> using namespace std; 
typedef pair<int, int> ii;  typedef vector<ii> vii; typedef long long ll; const int INF = ~(1 << 31); const double pi = acos(-1);  int doit(string s, int len) {   int howmany = 0;   for (; true;) {     if (s.size() == len) {       int f1 = 0;       int f2 = 0;       {         int i = (0);         while (i < (len)) {           if (s[i] == '+')             f1++;           else             f2++;           i++;         }       }       if (f1 == len) {        } else if (f2 == len) {         howmany++;       } else {         howmany += 1000000;       }        break;     } else {       if (s[0] == '+') {         s.erase(s.begin());       } else {         {           int i = (0);           while (i < (len)) {             if (s[i] == '+')               s[i] = '-';             else               s[i] = '+';             i++;           }         }         howmany++;       }     }   }   return howmany; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_7_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/bennikartefla/A-small-practice.in",           "r", stdin);    ofstream fout("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_7_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out");   int n;   cin >> n;   for (int i = (0); i < (n); i++) {     string s;     cin >> s;     int m;     cin >> m;     int bst = INF;     bst = min(doit(s, m), bst);     reverse(s.begin(), s.end());     bst = min(doit(s, m), bst);     fout << "Case #" << i + 1 << ": ";     if (bst > 10000)       fout << "IMPOSSIBLE" << endl;     else       fout << bst << endl;   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> #include <string> using namespace std;  
void open() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_8_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/ccsnoopy/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_8_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/ccsnoopy/outer_temp/ccsnoopy/A-small-practice_transformation.out",           "w", stdout); }  inline void mxtraeejbh(char str[1000], int &m, int &n) {   if (str[m + n] == '+')     str[m + n] = '-';   else     str[m + n] = '+'; }  inline void yboqauqvmd() { printf("IMPOSSIBLE\n"); }  
int main(void) {   open();   int cas;   cin >> cas;   char str[1000];   int r;    int ct;   {     ct = 1;     while (ct <= cas) {       cin >> str;       cin >> r;       int ret = 0;       int len = strlen(str);        for (int n = 0; n < len; n++) {         if (str[n] == '-') {           if (n + r > len) {             ret = -1;             break;           }           for (int m = 0; m < r; m++)             mxtraeejbh(str, m, n);           ret++;          }       }        printf("Case #%d: ", ct);        if (ret == -1)         yboqauqvmd();       else {         printf("%d\n", ret);       }       cerr << "Test " << ct << " done \n";       ct++;     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> using namespace std; 
typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<int> vi; void open() {}  
int main(void) {   open();   int t;   scanf("%d", &t);   char vgjc_Var[1010];   int tt;    for (int auwi_Var = 1; auwi_Var <= t; auwi_Var++) {     scanf("%s", vgjc_Var);     scanf("%d", &tt);     int ret = 0;     int len = strlen(vgjc_Var);      int s;     for (s = 0; s < len; s++) {       if (vgjc_Var[s] == '-') {         if (s + tt > len) {           ret = -1;           break;         }         for (int ans = 0; ans < tt; ans++) {           if (vgjc_Var[ans + s] == '+') {             vgjc_Var[ans + s] = '-';           } else             vgjc_Var[ans + s] = '+';         }         ret++;        }     }      printf("Case #%d: ", auwi_Var);      if (ret == -1) {       printf("IMPOSSIBLE\n");     } else       printf("%d\n", ret);      cerr << "Test " << auwi_Var << " done \n";   }   return 0; }
#include <bits/stdc++.h> #include <iomanip> #include <iostream> #include <set> #include <string> #include <vector> using namespace std; 
const double eps = 1e-9;  typedef set<int> si; typedef vector<vector<int>> vvi; typedef long long ll; typedef long long LL; typedef pair<int, int> pii;  void open() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_8_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/ccsnoopy/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_8_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/ccsnoopy/outer_temp/ccsnoopy/A-small-practice_transformation.out",           "w", stdout); }  inline void ghnqjrbsbq(std::string &str, int &ans, int &j) {   str[ans + j] = '-'; }  
int main(void) {   ios::sync_with_stdio(0);    open();   int tc;   cin >> tc;   string str;   int k;    for (int b = 1; b <= tc; b++) {     cin >> str;     cin >> k;     int ret = 0;     int len = str.size();      for (int j = 0; j < len; j++) {       if (str[j] == '-') {         if (j + k > len) {           ret = -1;           break;         }         for (int ans = 0; ans < k; ans++) {           if (str[ans + j] == '+')             ghnqjrbsbq(str, ans, j);           else {             str[ans + j] = '+';           }         }         ret++;        }     }      cout << "Case #" << b << ": ";      if (ret == -1) {       cout << "IMPOSSIBLE\n";     } else {       cout << ret << "\n";     }     cerr << "Test " << b << " done \n";   }   return 0; }
#include <bits/stdc++.h> #include <fstream> #include <iostream> using namespace std; 
const double EPS = 1e-9; ifstream fin;  typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<int> vi; void get() {}  
int main(void) {   fin.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_8_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ccsnoopy/A-small-practice.in");    get();   int tc;   fin >> tc;   char y[1010];   int k;    int ct;   for (ct = 1; ct <= tc; ct++) {     fin >> y;     fin >> k;     int ret = 0;     int len = strlen(y);      for (int j = 0; j < len; j++) {       if (y[j] == '-') {         if (j + k > len) {           ret = -1;           break;         }         int t;         {           t = 0;           while (t < k) {             if (y[t + j] == '+') {               y[t + j] = '-';             } else {               y[t + j] = '+';             }             t++;           }         }         ret++;        }     }      printf("Case #%d: ", ct);      if (ret == -1) {       printf("IMPOSSIBLE\n");     } else       printf("%d\n", ret);      cerr << "Test " << ct << " done \n";   }   return 0; }
#include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <stdio.h> #include <vector> using namespace std; 
using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &is, pair<S, T> &p) {   return is >> p.first >> p.second; } template <class S, class T> ostream &operator<<(ostream &os, const pair<S, T> &p) {   return os << p.first << " " << p.second; }  inline void bltmhoosmi(int &ans, int &K, VI &xs, int &i) {   ++ans;   int k;   for (k = (0); k < (K); ++k)     xs[i + k] = !xs[i + k]; }  inline void yvyszwlhvx(int &ans, int &K, VI &xs, int &i) {   if (!xs[i])     bltmhoosmi(ans, K, xs, i); }  
int main() {   cin.tie(0);    int s;   scanf("%d ", &s);   int t;   {     t = (1);     while (t < (s + 1)) {       string S;       cin >> S;       int K;       scanf("%d ", &K);       int N = int((S).size());       VI xs(N);       for (int i = (0); i < (N); ++i)         xs[i] = S[i] == '+';        int ans = 0;       int i;       {         i = 0;         while (i + K <= N) {           yvyszwlhvx(ans, K, xs, i);           ++i;         }       }       if (accumulate(begin((xs)), end((xs)), 0) != N) {         printf("Case #%d: IMPOSSIBLE\n", t);       } else         printf("Case #%d: %d\n", t, ans);       ++t;     }   }    return 0; }
#include <bits/stdc++.h> #include <iostream> #include <set> #include <utility> #include <vector> using namespace std; 
typedef long long ll; typedef pair<int, int> ii; typedef vector<int> vi; typedef long double ld;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &is, pair<S, T> &p) {   return is >> p.first >> p.second; } template <class S, class T> ostream &operator<<(ostream &os, const pair<S, T> &p) {   return os << p.first << " " << p.second; } template <class T> void maxi(T &x, T y) {   if (x < y)     x = y; } template <class T> void mini(T &x, T y) {   if (x > y)     x = y; }  inline void iqjhawxivc(VI &xs, int &i, int &k) {   xs[i + k] = !xs[i + k];   ++k; }  inline void arbaegyswv(int &K, VI &xs, int &i) {   int k = (0);   for (; k < (K);)     iqjhawxivc(xs, i, k); }  
int main() {    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_9_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/okaduki/outer_temp/okaduki/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_9_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/okaduki/A-small-practice.in",           "r", stdin);    cin.tie(0);    int T;   cin >> T;   {     int t = (1);     while (t < (T + 1)) {       string S;       cin >> S;       int K;       cin >> K;       int N = int((S).size());       VI xs(N);       {         int i = (0);         while (i < (N)) {           xs[i] = S[i] == '+';           ++i;         }       }        int ans = 0;       for (int i = 0; i + K <= N; ++i) {         if (!xs[i]) {           ++ans;           arbaegyswv(K, xs, i);         }       }       if (accumulate(begin((xs)), end((xs)), 0) != N)         cout << "Case #" << t << ": IMPOSSIBLE" << endl;       else         cout << "Case #" << t << ": " << ans << endl;       ++t;     }   }    return 0; }
#include <bits/stdc++.h> #include <fstream> using namespace std; 
ifstream fin;  ofstream fout;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &n, pair<S, T> &p) {   return n >> p.first >> p.second; } template <class S, class T> ostream &operator<<(ostream &c, const pair<S, T> &p) {   return c << p.first << " " << p.second; } template <class T> void maxi(T &x, T y) {   if (x < y)     x = y; } template <class T> void get(T &x, T y) {   if (x > y)     x = y; }  inline void ulskbszywe(int &ans, int &K, VI &v, int &i) {   ++ans;   int k;   for (k = (0); k < (K); ++k)     v[i + k] = !v[i + k]; }  
int main() {   fin.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_9_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/okaduki/A-small-practice.in");    fout.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_9_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/okaduki/outer_temp/okaduki/A-small-practice_transformation.out");    cin.tie(0);    int s;   fin >> s;   int t;   for (t = (1); t < (s + 1); ++t) {     string S;     fin >> S;     int K;     fin >> K;     int N = int((S).size());     VI v(N);     int i;     for (i = (0); i < (N); ++i) {       v[i] = S[i] == '+';     }      int ans = 0;     {       int i = 0;       while (i + K <= N) {         if (!v[i])           ulskbszywe(ans, K, v, i);         ++i;       }     }     if (accumulate(begin((v)), end((v)), 0) != N)       fout << "Case #" << t << ": IMPOSSIBLE" << endl;     else       fout << "Case #" << t << ": " << ans << endl;   }    return 0; }
#include <bits/stdc++.h> #include <cassert> #include <cctype> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <functional> #include <iomanip> #include <iterator> #include <list> #include <map> #include <math.h> #include <set> #include <stdio.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;
typedef set<int> si; typedef vector<vector<int>> vvi; typedef long long ll; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef unsigned long long ull;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &get(istream &is, pair<S, T> &p) {   return is >> p.first >> p.second; } template <class S, class T> ostream &operator<<(ostream &os, const pair<S, T> &p) {   return os << p.first << " " << p.second; } template <class T> void maxi(T &x, T y) {   if (x < y)     x = y; }  inline void ubjwevtsjm(int &ans, int &K, VI &n, int &i) {   ++ans;   for (int k = (0); k < (K); ++k)     n[i + k] = !n[i + k]; }  inline void cljopzbhns(int &ans, int &K, VI &n, int &i) {   if (!n[i])     ubjwevtsjm(ans, K, n, i); }  
int main() {   cin.tie(0);   ios_base::sync_with_stdio(0);    int T;   cin >> T;   for (int t = (1); t < (T + 1); ++t) {     string S;     cin >> S;     int K;     cin >> K;     int N = int(S.size());     VI n(N);     {       int i = (0);       while (i < (N)) {         n[i] = S[i] == '+';         ++i;       }     }      int ans = 0;     for (int i = 0; i + K <= N; ++i)       cljopzbhns(ans, K, n, i);     if (accumulate(begin((n)), end((n)), 0) != N)       cout << "Case #" << t << ": IMPOSSIBLE" << endl;     else       cout << "Case #" << t << ": " << ans << endl;   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <limits> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
int T; typedef pair<int, int> pii; typedef pair<int, int> PII; typedef long double LD; typedef long long ll; typedef unsigned long long ull; typedef vector<int> vi;  struct Rec {   int u, zt, num, dis;   Rec() {}   Rec(int u, int zt, int num, int dis) : u(u), zt(zt), num(num), dis(dis) {} }; bool operator<(Rec a, Rec b) { return a.dis > b.dis; } int k, t; string st; inline void kzgzloftfq(int &j) {   if (st[j] == '-')     st[j] = '+';   else     st[j] = '-'; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_10_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/kuzphi/outer_temp/kuzphi/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_10_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/kuzphi/A-small-practice.in",           "r", stdin);    int ret_val = 0;   cin >> T;   for (; T--;) {     cout << "Case #" << ++t << ": ";     cin >> st >> k;     int ans = 0;     int i;     {       i = 0;       while (i < st.size() - k + 1) {         if (st[i] == '-') {           ans++;           for (int j = i; j < i + k; j++)             kzgzloftfq(j);         }         i++;       }     }     int ck = 1;     {       int i = 0;       while (i < st.size()) {         if (st[i] == '-')           ck = 0;         i++;       }     }     if (ck)       cout << ans << endl;     else       puts("IMPOSSIBLE");   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <limits> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;  
int T; ifstream fin;  typedef long double LD; typedef long long ll; typedef vector<int> vi; typedef vector<int> VI; typedef set<int> si; typedef vector<vector<int>> vvi;  struct Rec {   int u, zt, num, dis;   Rec() {}   Rec(int u, int zt, int num, int dis) : u(u), zt(zt), num(num), dis(dis) {} };  int k, r; string st; 
int main() {   fin.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_10_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/kuzphi/A-small-practice.in");    fin >> T;   for (; T--;) {     printf("Case #%d: ", ++r);     fin >> st >> k;     int ans = 0;     for (int i = 0; i < st.size() - k + 1; i++) {       if (st[i] == '-') {         ans++;         for (int j = i; j < i + k; j++) {           if (st[j] == '-')             st[j] = '+';           else {             st[j] = '-';           }         }       }     }     int ck = 1;     int i;     for (i = 0; i < st.size(); i++) {       if (st[i] == '-') {         ck = 0;       }     }     if (ck) {       cout << ans << endl;     } else       puts("IMPOSSIBLE");   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <limits> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;  
int T;  const double EPS = 1e-9; const int MOD = 1000000007; ifstream fin;  const int mod = 1000000007;  typedef unsigned long long ull; typedef long double ld; typedef long long ll; typedef vector<int> vi; typedef vector<int> VI; typedef set<int> si;  struct Rec {   int u, zt, num, dis;   Rec() {}   Rec(int u, int zt, int num, int dis) : u(u), zt(zt), num(num), dis(dis) {} }; bool operator<(Rec a, Rec b) { return a.dis > b.dis; } int k, cs; string st; inline void gldmrbgmoo(int &j) { st[j] = '-'; }  
int main() {   fin.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_10_Usenix_RF_1.0_True_MCTS_Classic_True/Mucosolvan/kuzphi/A-small-practice.in");    fin >> T;   for (; T--;) {     cout << "Case #" << ++cs << ": ";     fin >> st >> k;     int ans = 0;     for (int i = 0; i < st.size() - k + 1; i++) {       if (st[i] == '-') {         ans++;         for (int j = i; j < i + k; j++) {           if (st[j] == '-')             st[j] = '+';           else             gldmrbgmoo(j);         }       }     }     int ck = 1;     for (int i = 0; i < st.size(); i++) {       if (st[i] == '-')         ck = 0;     }     if (ck)       cout << ans << endl;     else       puts("IMPOSSIBLE");   }   return 0; }
#include <algorithm> #include <bitset> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iostream> #include <limits> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const double pi = acos(-1.), eps = 1e-6; const int Maxn = 110, Maxk = 5010, Mo = 1e9 + 7, oo = INT_MAX >> 2; const int sp[4][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}}; int T;  typedef long double ld; typedef long long LL; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef vector<int> vi; typedef long double LD;  struct Rec {   int u, zt, num, dis;   Rec() {}   Rec(int u, int zt, int num, int dis) : u(u), zt(zt), num(num), dis(dis) {} }; bool operator<(Rec a, Rec b) { return a.dis > b.dis; } int n, m, k, cs, ans; string st; 
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_10_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/kuzphi/A-small-practice.in", "r", stdin);    int ret_val = 0;   cin >> T;   while (T--) {     printf("Case #%d: ", ++cs);     cin >> st >> k;     int ans = 0;     for (int i = 0; i < st.size() - k + 1; i++) {       if (st[i] == '-') {         ans++;         for (int j = i; j < i + k; j++) {           if (st[j] == '-')             st[j] = '+';           else             st[j] = '-';         }       }     }     int ck = 1;     for (int i = 0; i < st.size(); i++) {       if (st[i] == '-')         ck = 0;     }     if (ck)       cout << ans << endl;     else       puts("IMPOSSIBLE");   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <fstream> #include <iostream> #include <iterator> #include <map> #include <numeric> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
const int INF = 1000000000; ofstream fout;  ifstream fin;  const double eps = 1e-9; const double EPS = 1e-9; const int MAXN = 1005;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  ll gcd(ll a, ll b) {   ll t;   while ((t = a % b) != 0) {     a = b;     b = t;   }   return b; }  ll fast_exp(ll tc, ll n, ll r) {   if (n == 0)     return 1;   ll t = fast_exp(tc, n / 2, r);   if (n % 2 == 0)     return (t * t) % r;   else     return (((t * t) % r) * tc) % r; }  bool is_set(int i, ll N) { return (N >> i) & 1; }  int first_bit(ll N) {   int i = 0;   while (i < 64)     if (is_set(i++, N))       return i - 1;   return -1; }  
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_11_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ibrahim5253/outer_temp/ibrahim5253/A-small-practice_transformation.out");    fin.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_11_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ibrahim5253/A-small-practice.in");    int t;   fin >> t;   for (int i = 1; i <= t; ++i) {     string s;     int k;     fin >> s >> k;     int f = 0, n = s.length();     for (int j = 0; j < n - k + 1; ++j) {       if (s[j] == '-') {         ++f;         for (int l = j; l < j + k; ++l)           s[l] = (s[l] == '+' ? '-' : '+');       }     }     for (int j = 0; j < n; ++j)       if (s[j] == '-') {         f = -1;         break;       }     fout << "Case #" << i << ": ";     if (f == -1)       fout << "IMPOSSIBLE\n";     else {       fout << f << "\n";     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
typedef long double LD; typedef long long LL; typedef pair<int, int> PII; typedef vector<int> VI;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  ll gcd(ll a, ll b) {   ll t;   for (; (t = a % b) != 0;) {     a = b;     b = t;   }   return b; }  ll fast_exp(ll base, ll n, ll tc) {   if (n == 0)     return 1;   ll t = fast_exp(base, n / 2, tc);   if (n % 2 == 0) {     return (t * t) % tc;   } else     return (((t * t) % tc) * base) % tc; }  bool is_set(int i, ll mask) { return (mask >> i) & 1; }  inline void hpdctzyiie(int &f, int &j, int &k, char s[1000]) {   ++f;   int l;   for (l = j; l < j + k; ++l) {     s[l] = (s[l] == '+' ? '-' : '+');   } }  
int main() {   ios::sync_with_stdio(false);   int t;   cin >> t;   {     int i = 1;     while (i <= t) {       char s[1000];       int k;       cin >> s >> k;       int f = 0, n = strlen(s);       for (int j = 0; j < n - k + 1; ++j) {         if (s[j] == '-')           hpdctzyiie(f, j, k, s);       }       int j;       for (j = 0; j < n; ++j)         if (s[j] == '-') {           f = -1;           break;         }       cout << "Case #" << i << ": ";       if (f == -1) {         cout << "IMPOSSIBLE\n";       } else         cout << f << "\n";       ++i;     }   }   return 0; }
#include <algorithm> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
const double eps = 1e-9; const int MOD = 1000000007; typedef long long LL; typedef vector<int> VI; typedef long double ld; typedef pair<int, int> ii; typedef long double LD; typedef set<int> si;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  ll get(ll a, ll b) {   ll t;   while ((t = a % b) != 0) {     a = b;     b = t;   }   return b; }  ll fast_exp(ll base, ll n, ll m) {   if (n == 0)     return 1;   ll t = fast_exp(base, n / 2, m);   if (n % 2 == 0)     return (t * t) % m;   else     return (((t * t) % m) * base) % m; }  bool is_set(int i, ll tc) { return (tc >> i) & 1; }  int count_bits(ll tc) {   int ans = 0;   for (int i = 0; i < 64; ++i)     if (is_set(i, tc))       ++ans;   return ans; }  int first_bit(ll tc) {   int ret_val = -1;   int i = 0;   while (i < 64)     if (is_set(i++, tc))       return i - 1;   return ret_val; }  inline void zcmedvjfae(int &f, int &j, int &k, std::string &s) {   ++f;   for (int d = j; d < j + k; ++d)     s[d] = (s[d] == '+' ? '-' : '+'); }  inline void rtszjqhpre(int &f, int &j, int &k, std::string &s) {   if (s[j] == '-')     zcmedvjfae(f, j, k, s); }  
int main() {   int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_11_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/ibrahim5253/A-small-practice.in",           "r", stdin);   int t;   scanf("%d ", &t);   for (int i = 1; i <= t; ++i) {     string s;     int k;     cin >> s >> k;     int f = 0, n = s.length();     for (int j = 0; j < n - k + 1; ++j)       rtszjqhpre(f, j, k, s);     for (int j = 0; j < n; ++j)       if (s[j] == '-') {         f = -1;         break;       }     printf("Case #%d: ", i);     if (f == -1)       printf("IMPOSSIBLE\n");     else       printf("%d\n", f);   }   return ret_val; }
#include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstring> #include <iostream> #include <iterator> #include <map> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std;  
using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  ll gcd(ll a, ll b) {   ll t;   while ((t = a % b) != 0) {     a = b;     b = t;   }   return b; }  ll get(ll base, ll n, ll m) {   if (n == 0)     return 1;   ll t = get(base, n / 2, m);   if (n % 2 == 0)     return (t * t) % m;   else     return (((t * t) % m) * base) % m; }  bool do__Boufw_fct(int i, ll c) { return (c >> i) & 1; }  inline void ncdjorxcnc(ll &c, int &ans) {   int i = 0;   while (i < 64) {     if (do__Boufw_fct(i, c))       ++ans;     ++i;   } }  int solve(ll c) {   int ans = 0;   ncdjorxcnc(c, ans);   return ans; }  int first_bit(ll c) {   int i = 0;   while (i < 64)     if (do__Boufw_fct(i++, c))       return i - 1;   return -1; }  inline void rgitzmamyj(std::string &s, int &l) {   s[l] = (s[l] == '+' ? '-' : '+');   ++l; }  inline void fhkwgnencb(int &f, int &j, int &r, std::string &s) {   if (s[j] == '-') {     ++f;     {       int l = j;       while (l < j + r)         rgitzmamyj(s, l);     }   } }  
int main() {    int t;   cin >> t;   {     int i = 1;     while (i <= t) {       string s;       int r;       cin >> s >> r;       int f = 0, n = s.length();       for (int j = 0; j < n - r + 1; ++j)         fhkwgnencb(f, j, r, s);       {         int j = 0;         while (j < n) {           if (s[j] == '-') {             f = -1;             break;           }           ++j;         }       }       cout << "Case #" << i << ": ";       if (f == -1)         cout << "IMPOSSIBLE\n";       else         cout << f << "\n";       ++i;     }   }   return 0; }
#include <bits/stdc++.h> #include <iomanip> #include <iostream> #include <set> #include <utility> #include <vector> using namespace std; 
const long double PI = 3.1415926535897932384626433832795; const int MAXN = 1005; const int INF = 1000000000;  typedef pair<int, int> PII; typedef unsigned long long ull; typedef vector<int> vi; typedef set<int> si; typedef long long ll;  inline void xhybamteer(int &k, std::string &s, int &i, int &ans) {   for (int j = 0; j < k; j++) {     s[i + j] = s[i + j] == '-' ? '+' : '-';   }   ans++; }  
int main() {    int solve, t = 0;   cin >> solve;   for (; solve--;) {     string s;     int k, ans = 0;     cin >> s >> k;     for (int i = 0; i + k <= s.size(); i++) {       if (s[i] == '-')         xhybamteer(k, s, i, ans);     }     cout << "Case #" << ++t << ": ";     if (s == string(s.size(), '+')) {       cout << ans << "\n";     } else       puts("IMPOSSIBLE");   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <cmath> #include <complex> #include <cstdlib> #include <cstring> #include <iomanip> #include <iostream> #include <list> #include <stack> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const int MAXN = 1005; typedef pair<int, int> ii; typedef pair<int, int> PII; typedef unsigned long long ull; typedef vector<int> VI; typedef long double LD; typedef set<int> si; typedef long long LL;  
int main() {   int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_12_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/jiian/A-small-practice.in",           "r", stdin);   int T, cas = 0;   cin >> T;   while (T--) {     string s;     int k, ans = 0;     cin >> s >> k;     for (int i = 0; i + k <= s.size(); i++) {       if (s[i] == '-') {         for (int j = 0; j < k; j++)           s[i + j] = s[i + j] == '-' ? '+' : '-';         ans++;       }     }     cout << "Case #" << ++cas << ": ";     if (s == string(s.size(), '+'))       cout << ans << "\n";     else       puts("IMPOSSIBLE");   }   return ret_val; }
#include <bits/stdc++.h> #include <iomanip> #include <iostream> #include <stdio.h> using namespace std;  
inline void apkymcyeyo(std::string &s, int &i, int &j) {   s[i + j] = s[i + j] == '-' ? '+' : '-';   j++; }  inline void rnewuudytw(int &t, std::string &s, int &i) {   int j = 0;   while (j < t)     apkymcyeyo(s, i, j); }  
int main() {    int solve, b = 0;   cin >> solve;   for (; solve--;) {     string s;     int t, ans = 0;     cin >> s >> t;     for (int i = 0; i + t <= s.size(); i++) {       if (s[i] == '-') {         rnewuudytw(t, s, i);         ans++;       }     }     cout << "Case #" << ++b << ": ";     if (s == string(s.size(), '+'))       cout << ans << "\n";     else       puts("IMPOSSIBLE");   }   return 0; }
#include <bits/stdc++.h> using namespace std;
typedef long long LL;  inline void omwnyhbmbd(int &cas) {   string s;   int k, ans = 0;   cin >> s >> k;   for (int i = 0; i + k <= s.size(); i++) {     if (s[i] == '-') {       {         int j = 0;         while (j < k) {           s[i + j] = s[i + j] == '-' ? '+' : '-';           j++;         }       }       ans++;     }   }   printf("Case #%d: ", ++cas);   if (s == string(s.size(), '+'))     printf("%d\n", ans);   else     puts("IMPOSSIBLE"); }  
int main() {   int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_12_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/jiian/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_12_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/jiian/outer_temp/jiian/A-small-practice_transformation.out",           "w", stdout);   int tt, cas = 0;   cin >> tt;   while (tt--)     omwnyhbmbd(cas);   return ret_val; }
#include <algorithm> #include <bitset> #include <cassert> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
typedef vector<int> vi; typedef vector<int> VI; typedef long double LD; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef unsigned long long ull; typedef set<int> si; typedef vector<vector<int>> vvi;  int N, a; int s[200]; int r[200][200]; int b[200]; int tb[200];  int solve[200][200]; int mm[200][200];  bool dfs(int cur, int less, int most) { return false; }  
int main(void) {    int x = 0;   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_13_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/iPeter/A-small-practice.in",           "r", stdin);   int t;   cin >> t;   for (int c = 1; c <= t; c++) {     cin >> N >> a;     for (int y = 0; y < N; ++y)       cin >> s[y];     for (int y = 0; y < N; ++y) {       for (int j = 0; j < a; ++j) {         cin >> r[y][j];       }       sort(r[y], r[y] + a);       {         int j = 0;         while (j < a) {           solve[y][j] = ceil(1.0 * r[y][j] / (1.1 * s[y]));           mm[y][j] = floor(1.0 * r[y][j] / (0.9 * s[y]));           ++j;         }       }     }       int ans = 0;     memset(b, 0, sizeof(b));       while (1) {       bool stop = false;       for (int y = 0; y < N; ++y) {         if (b[y] >= a)           stop = true;       }       if (stop)         break;        int cur = 0;       for (int y = 0; y < N; ++y) {         cur = max(cur, solve[y][b[y]]);       }        bool ok = true;       for (int y = 0; y < N; ++y) {         for (int j = b[y]; j <= a; ++j) {           if (j == a || cur < solve[y][j]) {             b[y] = j;             ok = false;             break;           }           if (solve[y][j] > mm[y][j]) {             continue;           }           if (cur <= mm[y][j]) {             tb[y] = j;             break;           }         }       }        if (!ok)         continue;        ++ans;       for (int y = 0; y < N; ++y) {         b[y] = tb[y] + 1;       }     }      cout << "Case #" << c << ": " << ans << "\n";   }   return x; }
#include <algorithm> #include <cstdio> #include <cstring> #include <iostream> using namespace std; 
char s[2000]; inline void qmqwgktwbr(int &j, int &n) {   if (s[j] == '-') {     n = -1;   } }  
int main(void) {   ios::sync_with_stdio(false);    int t;   cin >> t;   for (int tt = 1; tt <= t; tt++) {     int n = 0, k;     cin >> s >> k;     for (int solve = strlen(s) - 1; solve + 1 >= k; --solve) {       if (s[solve] == '-') {         ++n;         {           int j = 0;           while (j < k) {             s[solve - j] = (s[solve - j] == '-' ? '+' : '-');             ++j;           }         }       }      }     for (int j = 0; j < k; ++j)       qmqwgktwbr(j, n);      if (n < 0) {       printf("Case #%d: IMPOSSIBLE\n", tt);       continue;     }     printf("Case #%d: %d\n", tt, n);   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> using namespace std; 
char s[2000]; 
int main(void) {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_13_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/iPeter/A-small-practice.in", "r", stdin);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_13_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/iPeter/outer_temp/iPeter/A-small-practice_transformation.out",           "w", stdout);    int ret_val = 0;   int t;   scanf("%d", &t);   for (int tt = 1; tt <= t; tt++) {     int n = 0, k;     scanf("%s%d", s, &k);     for (int i = strlen(s) - 1; i + 1 >= k; --i) {       if (s[i] == '-') {         ++n;         for (int j = 0; j < k; ++j) {           s[i - j] = (s[i - j] == '-' ? '+' : '-');         }       }      }     for (int j = 0; j < k; ++j) {       if (s[j] == '-') {         n = -1;       }     }      if (n < 0) {       printf("Case #%d: IMPOSSIBLE\n", tt);       continue;     }     printf("Case #%d: %d\n", tt, n);   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <fstream> #include <iomanip> #include <iostream> #include <utility> using namespace std; 
ifstream fin;  typedef double dbl;  char uokc_Var[2000]; 
int main(void) {   fin.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_12_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/iPeter/A-small-practice.in");    int ret_val = 0;   int t;   fin >> t;   int tc;   for (tc = 1; tc <= t; tc++) {     int n = 0, k;     fin >> uokc_Var >> k;     {       int i = strlen(uokc_Var) - 1;       while (i + 1 >= k) {         if (uokc_Var[i] == '-') {           ++n;           for (int m = 0; m < k; ++m) {             uokc_Var[i - m] = (uokc_Var[i - m] == '-' ? '+' : '-');           }         }          --i;       }     }     int m;     for (m = 0; m < k; ++m) {       if (uokc_Var[m] == '-') {         n = -1;       }     }      if (n < 0) {       cout << "Case #" << tc << ": IMPOSSIBLE\n";       continue;     }     cout << "Case #" << tc << ": " << n << "\n";   }   return ret_val; }
#include <bits/stdc++.h> #include <fstream> #include <iostream>  using namespace std; 
inline void msxmnxgpnc(long long &ans, long long &base, long long &mod,                        long long &p) {   if (p & 1)     ans = (ans * base) % mod;   base = (base * base) % mod;   p /= 2; }  long long get(long long base, long long p, long long mod = (1000000007LL)) {   long long ans = 1;   while (p)     msxmnxgpnc(ans, base, mod, p);   return ans; }  long long solve(long long a, long long b) {   if (b == 0)     return a;   return solve(b, a % b); }  int n, p, tc[55][55], req[55], DP[10][1024];  int dp(int i, int mask) {   if (i == p)     return 0;   int &ans = DP[i][mask];   if (ans != -1)     return ans;   ans = dp(i + 1, mask);   for (int j = 0; j < p; j++) {     if ((mask >> j) & 1)       continue;     int z = tc[0][i] / req[0];     for (int x = z + 5; x >= z - 5 && x >= 1; x--) {       int lo1 = ceil(1LL * x * req[0] * 0.9),           hi1 = floor(1LL * x * req[0] * 1.1);       int lo2 = ceil(1LL * x * req[1] * 0.9),           hi2 = floor(1LL * x * req[1] * 1.1);       if (tc[0][i] >= lo1 && tc[0][i] <= hi1 && tc[1][j] >= lo2 &&           tc[1][j] <= hi2)         ans = max(ans, 1 + dp(i + 1, mask | (1 << j)));     }   }    return ans; }  
int main() {   int ret_val = 0;   ios::sync_with_stdio(false);    cin.tie(0);   int t, x = 1;   cin >> t;   while (t--) {      cin >> n >> p;     for (int i = 0; i < n; i++)       cin >> req[i];     for (int i = 0; i < n; i++)       for (int j = 0; j < p; j++)         cin >> tc[i][j];      if (n == 1) {       int ans = 0;       for (int i = 0; i < p; i++) {         int ok = 0;         for (int x = 2000000; x >= 1; x--) {           int lo = ceil(1LL * x * req[0] * 0.9),               hi = floor(1LL * x * req[0] * 1.1);           if (tc[0][i] >= lo && tc[0][i] <= hi) {             ok = true;             break;           }         }         ans += ok;       }        cout << "Case #" << x++ << ": " << ans << endl;       continue;     }      memset(DP, -1, sizeof(DP));     cout << "Case #" << x++ << ": " << dp(0, 0) << endl;   }   return ret_val; }
#include <bits/stdc++.h> #include <stdio.h>  using namespace std; 
typedef pair<int, int> ii; 
int main() {   int ret_val = 0;   ios_base::sync_with_stdio(0);   cin.tie(0);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_14_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/satyaki3794/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_14_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/satyaki3794/outer_temp/satyaki3794/A-small-practice_transformation.out",           "w", stdout);   int t, x = 1;   cin >> t;   while (t--) {      string str;     cin >> str;      int k;     cin >> k;      int n = (int)str.length(), ans = 0;     for (int i = 0; i + k - 1 < n; i++)       if (str[i] == '-') {         ans++;         for (int j = i; j < i + k; j++)           if (str[j] == '-')             str[j] = '+';           else             str[j] = '-';       }      for (int i = 0; i < n; i++)       if (str[i] == '-')         ans = -1;      if (ans == -1)       printf("Case #%d: IMPOSSIBLE\n", x++);     else       printf("Case #%d: %d\n", x++, ans);   }   return ret_val; }
#include <bits/stdc++.h>  using namespace std; 
typedef double dbl; typedef unsigned long long ull; typedef pair<int, int> ii;  long long pwr(long long base, long long p, long long mod = (1000000007LL)) {   long long ans = 1;   while (p) {     if (p & 1)       ans = (ans * base) % mod;     base = (base * base) % mod;     p /= 2;   }   return ans; }  long long gcd(long long a, long long b) {   if (b == 0)     return a;   return gcd(b, a % b); }  
int main() {   int ret_val = 0;   cin.tie(0);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_13_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/satyaki3794/A-small-practice.in",           "r", stdin);   int t, x = 1;   cin >> t;   for (; t--;) {      string str;     cin >> str;      int k;     cin >> k;      int n = (int)str.length(), ans = 0;     for (int i = 0; i + k - 1 < n; i++)       if (str[i] == '-') {         ans++;         int j;         {           j = i;           while (j < i + k) {             if (str[j] == '-')               str[j] = '+';             else               str[j] = '-';             j++;           }         }       }      {       int i = 0;       while (i < n) {         if (str[i] == '-')           ans = -1;         i++;       }     }      if (ans == -1)       cout << "Case #" << x++ << ": IMPOSSIBLE" << endl;     else       cout << "Case #" << x++ << ": " << ans << endl;   }   return ret_val; }
#include <bits/stdc++.h> #include <stdio.h>  using namespace std; 
typedef long long ll; typedef unsigned long long ull; typedef pair<int, int> ii;  ll pwr(ll base, ll p, ll mod = (1000000007LL)) {   ll ans = 1;   while (p) {     if (p & 1)       ans = (ans * base) % mod;     base = (base * base) % mod;     p /= 2;   }   return ans; }  
int main() {   int ret_val = 0;   ios_base::sync_with_stdio(0);   cin.tie(0);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_13_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/satyaki3794/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_13_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/satyaki3794/outer_temp/satyaki3794/A-small-practice_transformation.out",           "w", stdout);   int t, x = 1;   cin >> t;   while (t--) {      string str;     cin >> str;      int k;     cin >> k;      int n = (int)str.length(), ans = 0;     for (int i = 0; i + k - 1 < n; i++)       if (str[i] == '-') {         ans++;         for (int j = i; j < i + k; j++)           if (str[j] == '-')             str[j] = '+';           else             str[j] = '-';       }      for (int i = 0; i < n; i++)       if (str[i] == '-')         ans = -1;      if (ans == -1)       printf("Case #%d: IMPOSSIBLE\n", x++);     else       printf("Case #%d: %d\n", x++, ans);   }   return ret_val; }
#include <bits/stdc++.h> using namespace std; 
typedef double dbl;  inline void joycelmcxo(int &m1, int &m2) { swap(m1, m2); }  int main(int heoi_Var, char **argv) {   int ret_val = 0;   ifstream m("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_14_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/gultai4ukr/A-small-practice.in");   ofstream fout("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_14_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out");   int t;   m >> t;   for (int testcase = 0; testcase < t; ++testcase) {     int n, p;     m >> n >> p;     vector<int> need(n);     for (int i = 0; i < n; ++i) {       m >> need[i];     }     vector<vector<int>> q(n, vector<int>(p));     for (int i = 0; i < n; ++i) {       for (int j = 0; j < p; ++j) {         m >> q[i][j];       }     }      assert(n < 3);     int ans = 0;     if (n == 1) {       for (int i = 0; i < p; ++i) {         int tc = q[0][i] / need[0];         long double fr1 = 1.0L * q[0][i] / (tc * need[0]);         if (0.9L <= fr1 && fr1 <= 1.1L) {           ans++;           continue;         }         long double fr2 = 1.0L * q[0][i] / ((tc + 1) * need[0]);         if (0.9L <= fr2 && fr2 <= 1.1L) {           ans++;         }       }     } else {       vector<int> perm(p);       for (int i = 0; i < p; ++i) {         perm[i] = i;       }       do {         int cur = 0;         for (int i = 0; i < p; ++i) {           int m1 = q[0][i] / need[0];           int m2 = q[1][i] / need[1];           if (m2 < m1)             joycelmcxo(m1, m2);           for (int tc = m1; tc < m2 + 2; ++tc) {             long double fr01 = 1.0L * q[0][i] / (tc * need[0]);             long double fr11 = 1.0L * q[1][perm[i]] / (tc * need[1]);             long double fr02 = 1.0L * q[0][i] / ((tc + 1) * need[0]);             long double fr12 = 1.0L * q[1][perm[i]] / ((tc + 1) * need[1]);             if (0.9L <= fr01 && fr01 <= 1.1L && 0.9L <= fr11 && fr11 <= 1.1L) {               cur++;               break;             } else if (0.9L <= fr02 && fr02 <= 1.1L && 0.9L <= fr12 &&                        fr12 <= 1.1L) {               cur++;               break;             }           }         }         ans = max(ans, cur);       } while (next_permutation(perm.begin(), perm.end()));     }      fout << "Case #" << testcase + 1 << ": " << ans << endl;   }   m.close();   fout.close();   return ret_val; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> #include <string> #include <utility> using namespace std; 
typedef double dbl; typedef pair<int, int> pii;  
int main(int argc, char **argv) {   int ret_val = 0;    ofstream hvss_Var("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_14_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out");   int t;   cin >> t;    for (int m = 0; m < t; ++m) {     string s;     int xspi_Var;     cin >> s >> xspi_Var;     int n = s.size();      vector<bool> tc;     for (int i = 0; i < n; ++i) {       tc.push_back(s[i] == '+');     }      int cnt = 0;     for (int i = 0; i < n - xspi_Var + 1; ++i) {       if (!tc[i]) {         for (int drpi_Var = i; drpi_Var < i + xspi_Var; ++drpi_Var) {           tc[drpi_Var] = !tc[drpi_Var];         }         cnt++;       }       }      for (int i = n - xspi_Var; i < n; ++i) {       if (!tc[i]) {         cnt = -1;       }     }      hvss_Var << "Case #" << m + 1 << ": ";     if (cnt == -1)       hvss_Var << "IMPOSSIBLE" << endl;     else {       hvss_Var << cnt << endl;     }   }    hvss_Var.close();   return ret_val; }
#include <bits/stdc++.h> #include <cassert> #include <cctype> #include <climits> #include <complex> #include <cstdio> #include <cstdlib> #include <ctime> #include <functional> #include <iostream> #include <list> #include <numeric> #include <set> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;
const double eps = 1e-9;  typedef set<int> si; typedef vector<vector<int>> vvi; typedef long double ld; typedef long long ll; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef vector<int> VI; typedef long double LD;  
int main(int argc, char **argv) {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_14_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/gultai4ukr/A-small-practice.in",           "r", stdin);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_14_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out",           "w", stdout);    int ret_val = 0;    int get;   scanf("%d ", &get);   for (int testcase = 0; testcase < get; ++testcase) {     string s;     int k;     cin >> s >> k;     int solve = s.size();      vector<bool> v;     for (int i = 0; i < solve; ++i)       v.push_back(s[i] == '+');      int cnt = 0;     for (int i = 0; i < solve - k + 1; ++i) {       if (!v[i]) {         for (int j = i; j < i + k; ++j)           v[j] = !v[j];          cnt++;       }       }      for (int i = solve - k; i < solve; ++i) {       if (!v[i]) {         cnt = -1;       }     }      printf("Case #%d: ", testcase + 1);     if (cnt == -1) {       printf("IMPOSSIBLE\n");     } else {       printf("%d\n", cnt);     }   }    return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <cassert> #include <climits> #include <complex> #include <cstdio> #include <cstdlib> #include <ctime> #include <iostream> #include <iterator> #include <map> #include <numeric> #include <queue> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility> using namespace std; 
int main(int c, char **ans) {   ios::sync_with_stdio(false);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_14_Usenix_RF_1.0_True_MCTS_Classic_True/try/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_14_Usenix_RF_1.0_True_MCTS_Classic_True/try/gultai4ukr/A-small-practice.in",           "r", stdin);    int t;   scanf("%d ", &t);   int testcase;   for (testcase = 0; testcase < t; ++testcase) {     char s[1000];     int k;     scanf("%s %d ", s, &k);     int n = strlen(s);      vector<bool> v;     int i;     {       i = 0;       while (i < n) {         v.push_back(s[i] == '+');         ++i;       }     }      int cnt = 0;     for (int i = 0; i < n - k + 1; ++i) {       if (!v[i]) {         for (int j = i; j < i + k; ++j) {           v[j] = !v[j];         }         cnt++;       }          }      for (int i = n - k; i < n; ++i) {       if (!v[i]) {         cnt = -1;       }     }      cout << "Case #" << testcase + 1 << ": ";     if (cnt == -1) {       cout << "IMPOSSIBLE" << endl;     } else {       cout << cnt << endl;     }   }    return 0; }
#include <bits/stdc++.h> #include <stdio.h>  using namespace std;
typedef float td_f; typedef double dbl; typedef vector<int> vi; typedef long long ll; typedef long double ld; typedef pair<int, int> pii; typedef pair<pii, int> para; const int inf = 1e9 + 7; const int maxN = 50; const int M = 50; const int N = 50;  int t, n, p; int req[maxN], minim[maxN][maxN], arr[maxN][maxN], dlbi_Var[maxN][maxN]; bool graph[maxN][maxN];  bool przeciecie(int i, int m) {   if (minim[1][i] == inf || minim[2][m] == inf)     return false;   if (minim[1][i] >= minim[2][m])     if (minim[1][i] <= dlbi_Var[2][m])       return true;   if (dlbi_Var[1][i] >= minim[2][m] && dlbi_Var[1][i] <= dlbi_Var[2][m])     return true;   return false; }   bool bpm(bool bpGraph[M][N], int u, bool seen[], int matchR[]) {    for (int v = 0; v < N; v++) {      if (bpGraph[u][v] && !seen[v]) {       seen[v] = 1;        if (matchR[v] < 0 || bpm(bpGraph, matchR[v], seen, matchR)) {         matchR[v] = u;         return true;       }     }   }   return false; }   int maxBPM(bool bpGraph[M][N]) {    int matchR[N];     memset(matchR, -1, sizeof(matchR));    int result = 0;    for (int u = 0; u < M; u++) {       bool seen[N];     memset(seen, 0, sizeof(seen));       if (bpm(bpGraph, u, seen, matchR))       result++;   }   return result; }  inline void wxrdmnaeej(int &ans) {   int m = (1);   for (; m <= ((p));) {     if (minim[1][m] != inf)       ans++;     ++m;   } }  
int main() {   int ret_val = 0;    cin >> t;   for (int test = (1); test <= ((t)); ++test) {     cin >> n >> p;     for (int i = (1); i <= ((n)); ++i) {       cin >> req[i];     }      for (int tc = (1); tc <= ((n)); ++tc)       for (int m = (1); m <= ((p)); ++m) {         minim[tc][m] = dlbi_Var[tc][m] = inf;       }     for (int i = (1); i <= ((40)); ++i) {       for (int m = (1); m <= ((40)); ++m) {         graph[i][m] = 0;         minim[i][m] = dlbi_Var[i][m] = inf;       }     }     for (int i = (1); i <= ((n)); ++i)       for (int m = (1); m <= ((p)); ++m)         cin >> arr[i][m];      for (int tc = (1); tc <= ((n)); ++tc) {       for (int m = (1); m <= ((p)); ++m) {         td_f weight = req[tc];         int owyi_Var = 1;         for (; weight <= 2 * arr[tc][m];) {           if (arr[tc][m] >= 0.9 * weight && arr[tc][m] <= 1.1 * weight) {             minim[tc][m] = min(minim[tc][m], owyi_Var);             dlbi_Var[tc][m] = owyi_Var;           }           weight += req[tc];           owyi_Var++;         }       }     }      printf("Case #%d: ", test);     if (n == 1) {       int ans = 0;       wxrdmnaeej(ans);       printf("%d\n", ans);     } else {       for (int i = (1); i <= ((p)); ++i)         for (int m = (1); m <= ((p)); ++m)           if (przeciecie(i, m)) {             graph[i][m] = true;        printf("%d\n", maxBPM(graph));     }   }   return ret_val; }
#include <bits/stdc++.h>  using namespace std; 
typedef vector<int> vi; typedef long long ll; typedef long double ld; typedef pair<int, int> pii; typedef pair<pii, int> para; const int inf = 1e9 + 7; const int maxN = 1e6 + 5;  int t, k; string s;  
int main() {   int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_15_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/Mucosolvan/A-small-practice.in",           "r", stdin);   cin >> t;   for (int x = (1); x <= ((t)); ++x) {     cin >> s >> k;     int ans = 0;     for (int i = (0); i <= (((int)s.size() - k + 1) - 1); ++i) {       if (s[i] == '-') {         for (int j = (i); j <= (i + k - 1); ++j)           if (s[j] == '+')             s[j] = '-';           else             s[j] = '+';         ans++;       }     }     {       int i = (0);       while (i <= (((int)s.size()) - 1)) {         if (s[i] == '-') {           ans = -1;           break;         }         ++i;       }     }     cout << "Case #" << x << ": ";     if (ans == -1)       cout << "IMPOSSIBLE\n";     else       cout << ans << endl;   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <cassert> #include <climits> #include <complex> #include <cstdio> #include <cstdlib> #include <ctime> #include <iterator> #include <map> #include <numeric> #include <queue> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility>  using namespace std;  
typedef long double ld; typedef pair<int, int> pii; typedef pair<pii, int> para; const int inf = 1e9 + 7; const int maxN = 1e6 + 5;  int t, N; string s;  inline void solve(int &get, int &c) {   if (s[get] == '-') {     int j;     for (j = (get); j <= (get + N - 1); ++j)       if (s[j] == '+')         s[j] = '-';       else         s[j] = '+';     c++;   } }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_15_Usenix_RF_1.0_True_MCTS_Classic_True/try/Mucosolvan/A-small-practice.in",           "r", stdin);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_15_Usenix_RF_1.0_True_MCTS_Classic_True/try/Mucosolvan/outer_temp/Mucosolvan/A-small-practice_transformation.out",           "w", stdout);    cin >> t;   int x;   for (x = (1); x <= ((t)); ++x) {     cin >> s >> N;     int c = 0;     int get;     for (get = (0); get <= (((int)s.size() - N + 1) - 1); ++get)       solve(get, c);     {       int get = (0);       for (; get <= (((int)s.size()) - 1);) {         if (s[get] == '-') {           c = -1;           break;         }         ++get;       }     }     printf("Case #%d: ", x);     if (c == -1)       printf("IMPOSSIBLE\n");     else       printf("%d\n", c);   }   return 0; }
#include <bits/stdc++.h> #include <fstream> #include <set>  using namespace std; 
ofstream fout;  ifstream fin;  typedef set<int> si; typedef vector<int> VI; typedef long long LL; typedef long double LD; typedef pair<int, int> pii; typedef pair<pii, int> para; const int inf = 1e9 + 7; const int maxN = 1e6 + 5;  int t, a; string s;  inline void fjvgdwruax(int &i, int &solve) {   for (int j = (i); j <= (i + a - 1); ++j)     if (s[j] == '+')       s[j] = '-';     else       s[j] = '+';   solve++; }  
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_15_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Mucosolvan/outer_temp/Mucosolvan/A-small-practice_transformation.out");    fin.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_15_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Mucosolvan/A-small-practice.in");    int ret_val = 0;    fin >> t;   for (int x = (1); x <= ((t)); ++x) {     fin >> s >> a;     int solve = 0;     for (int i = (0); i <= (((int)s.size() - a + 1) - 1); ++i) {       if (s[i] == '-')         fjvgdwruax(i, solve);     }     for (int i = (0); i <= (((int)s.size()) - 1); ++i)       if (s[i] == '-') {         solve = -1;         break;       }     fout << "Case #" << x << ": ";     if (solve == -1)       fout << "IMPOSSIBLE\n";     else       fout << solve << endl;   }   return ret_val; }
#include <bits/stdc++.h> #include <bitset> #include <complex> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdlib.h>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std;  
typedef vector<int> vi; typedef vector<vi> vvi; typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long LL;            typedef unsigned long long ULL;  typedef unsigned uint;  const double pi = acos(-1.0);  const double eps = 1e-11;      const int MAXI = 0x7fffffff; const int dx[] = {1, 0, -1, 0}; const int dy[] = {0, 1, 0, -1}; const char dz[] = "SENW"; struct debugger {   template <typename T> debugger &operator,(const T &v) {     cerr << v << " ";     return *this;   } } dbg;  void debugarr(int *arr, int n) {   cout << "[";   for (int i = 0; i < n; i++)     cout << arr[i] << " ";   cout << "]" << endl; }  int req[110], lb[110], ub[110]; int q[110][110]; inline void gnjncwtstz(int &p, int &i, int &j) {   for (j = 0; j < p; j++) {     scanf("%d", &q[i][j]);     ;   } } 
int main() {   ios::sync_with_stdio(true);    freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_16_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/lazyBit/A-small-practice.in",           "r", stdin);   ;   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_16_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);   ;    int n, i, j, k, l, m, t, s = 0, d, r, ans, p;   scanf("%d", &t);   ;   int c = 1;   while (t--) {     memset((req), (0), sizeof(req));     memset((lb), (0), sizeof(lb));     memset((ub), (0), sizeof(ub));     memset((q), (0), sizeof(q));     scanf("%d", &n);     ;     scanf("%d", &p);     ;     {       i = 0;       while (i < n) {         scanf("%d", &req[i]);         ;         i++;       }     }     for (i = 0; i < n; i++)       gnjncwtstz(p, i, j);     for (i = 0; i < n; i++) {       sort(q[i], q[i] + p);     }     for (i = 0; i < n; i++) {       double nt = (9 * req[i]) / 10.0;       lb[i] = (int)nt;       if (lb[i] < nt)         lb[i]++;       ub[i] = (11 * req[i]) / 10;     }     int ns;     ans = 0;     bool vis[52][52];     memset((vis), (0), sizeof(vis));      for (i = 0; i < n; i++) {       for (j = 0; j < p; j++) {         if (q[i][j] < lb[i])           continue;         ns = q[i][j] / lb[i];         int mx = q[i][j] / ub[i];         if (mx * ub[i] < q[i][j]) {           mx++;         }         swap(mx, ns);         while (ns <= mx) {           bool f = 1;             vector<pair<int, int>> v;           v.clear();           for (int m = i + 1; m < n; m++) {             f = 0;             for (int o = 0; o < p; o++) {                   if (!vis[m][o] && ns * lb[m] <= q[m][o] &&                   ns * ub[m] >= q[m][o]) {                 vis[m][o] = true;                 v.push_back(make_pair(m, o));                 f = 1;                 break;               }             }              if (f == 0)               break;           }           if (f == 0) {             for (int o = 0; o < v.size(); o++) {               vis[v[o].first][v[o].second] = false;             }           } else {             ans++;              break;           }           ns++;         }       }       break;     }     printf("Case #%d: %d\n", c++, ans);   }   return (0); }
#include <bitset> #include <cctype> #include <climits> #include <complex> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std;
const int MOD = 1000000007;  typedef vector<int> vi; typedef vector<vi> vvi; typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long LL;            typedef unsigned long long ULL;     struct debugger {};  char str[50];  bool containszero(int l) {   int i = 0;   while (str[i] == '0') {     i++;   }   for (; i < l;) {     if (str[i] == '0')       return true;     i++;   }   return false; } 
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_16_Usenix_RF_1.0_True_MCTS_Classic_True/try/lazyBit/A-small-practice.in",           "r", stdin);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_16_Usenix_RF_1.0_True_MCTS_Classic_True/try/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);     int n, i, j, k, l, y, t, s = 0, d;   scanf("%d", &t);   ;   int c = 1;   while (t--) {     scanf("%s ", str);     scanf("%d ", &k);     int ans = 0;     l = strlen(str);     for (i = 0; i + k - 1 < l; i++) {       if (str[i] == '+')         continue;       s = 0;       {         j = i;         while (s < k) {           if (str[j] == '-')             str[j] = '+';           else             str[j] = '-';           s++, j++;         }       }       ans++;     }     for (i = 0; i < l; i++) {       if (str[i] == '-')         break;     }     if (i < l) {       printf("Case #%d: IMPOSSIBLE\n", c++);     } else {       printf("Case #%d: %d\n", c++, ans);     }   }   return (0); }
#include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <complex> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std;
const double eps = 1e-9; ofstream fout;  ifstream fin;  typedef vector<int> vi;  typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long LL;            typedef unsigned long long ULL;  typedef unsigned uint;    struct debugger {   template <typename T> debugger &solve(const T &v) {     cerr << v << " ";     return *this;   } };  void debugarr(int *arr, int n) {   fout << "[";   for (int i = 0; i < n; i++)     fout << arr[i] << " ";   fout << "]" << endl; }  char str[50];  bool containszero(int l) {   int i = 0;   for (; str[i] == '0';) {     i++;   }   for (; i < l;) {     if (str[i] == '0')       return true;     i++;   }   return false; } 
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_16_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out");    fin.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_16_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/lazyBit/A-small-practice.in");    ios::sync_with_stdio(true);     int n, i, x, l, m, t, s = 0, d;   fin >> t;   ;   int c = 1;   for (; t--;) {     fin >> str;     fin >> x;     int ans = 0;     l = strlen(str);     for (i = 0; i + x - 1 < l; i++) {       if (str[i] == '+')         continue;       s = 0;       for (int j = i; s < x; s++, j++) {         if (str[j] == '-')           str[j] = '+';         else           str[j] = '-';       }       ans++;     }     for (i = 0; i < l; i++) {       if (str[i] == '-')         break;     }     if (i < l) {       fout << "Case #" << c++ << ": IMPOSSIBLE\n";     } else {       fout << "Case #" << c++ << ": " << ans << "\n";     }   }   return (0); }
#include <bitset> #include <deque> #include <iomanip> #include <iostream> #include <queue> #include <set> #include <sstream> #include <stack>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std;
typedef long double LD; typedef set<int> si; typedef vector<int> vi; typedef vector<vi> vvi; typedef pair<int, int> pii; typedef vector<pii> vii; typedef vector<string> vs;  typedef long long LL;            typedef unsigned long long ull;    struct debugger {   template <typename T> debugger &operator,(const T &v) {     cerr << v << " ";     return *this;   } };  inline void fqzjununlb(int &n, int *q) {   int i = 0;   while (i < n) {     cout << q[i] << " ";     i++;   } }  void debugarr(int *q, int n) {   cout << "[";   fqzjununlb(n, q);   cout << "]" << endl; }  char str[50];  bool containszero(int x) {   int i = 0;   while (str[i] == '0') {     i++;   }   while (i < x) {     if (str[i] == '0')       return true;     i++;   }   return false; } inline void vsojqwxitu(int &j) { str[j] = '+'; }  inline void cnmnxmvofy(int &j) {   if (str[j] == '-')     vsojqwxitu(j);   else     str[j] = '-'; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_16_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_16_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/lazyBit/A-small-practice.in",           "r", stdin);     int n, i, b, x, tc, t, s = 0, d;   cin >> t;   ;   int c = 1;   while (t--) {     cin >> str;     cin >> b;     int ans = 0;     x = strlen(str);     for (i = 0; i + b - 1 < x; i++) {       if (str[i] == '+')         continue;       s = 0;       for (int j = i; s < b; s++, j++)         cnmnxmvofy(j);       ans++;     }     for (i = 0; i < x; i++) {       if (str[i] == '-')         break;     }     if (i < x) {       printf("Case #%d: IMPOSSIBLE\n", c++);     } else {       printf("Case #%d: %d\n", c++, ans);     }   }   return (0); }
#include <bits/stdc++.h> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <ctime> #include <fstream> #include <iostream> #include <iterator> #include <list> #include <numeric> #include <queue> #include <set> #include <stdio.h> #include <stdlib.h> #include <utility> #include <vector>  using namespace std; 
const long double PI = 3.1415926535897932384626433832795; ifstream fin;  inline void ogigslpuww(std::string &get, int &j) { get[j] = '+'; }  int solve(int cc) {   int ret_val = 1;   string get;   int k;   bool sol = true;   int count = 0;   fin >> get >> k;   for (int i = 0; i < get.length(); i++) {     if (get[i] == '-') {       if (i + k - 1 < get.length()) {         for (int j = i; j < i + k; j++) {           if (get[j] == '-')             ogigslpuww(get, j);           else {             get[j] = '-';           }         }         count++;       } else {         sol = false;       }     }    }   if (sol) {     printf("Case #%d: %d\n", cc, count);   } else {     printf("Case #%d: IMPOSSIBLE\n", cc);   }   return ret_val; }  
int main() {   int ret_val = 0;   ios::sync_with_stdio(false);   fin.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_17_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Thanabhat/A-small-practice.in");   int t;   fin >> t;   for (int i = 0; i < t; i++) {     solve(i + 1);   }   return ret_val; }
#include <bits/stdc++.h> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <ctime> #include <fstream> #include <iostream> #include <iterator> #include <list> #include <numeric> #include <queue> #include <set> #include <stdio.h> #include <stdlib.h> #include <utility> #include <vector>  using namespace std; 
const long double PI = 3.1415926535897932384626433832795; ifstream fin;  inline void ogigslpuww(std::string &get, int &j) { get[j] = '+'; }  int solve(int cc) {   int ret_val = 1;   string get;   int k;   bool sol = true;   int count = 0;   fin >> get >> k;   for (int i = 0; i < get.length(); i++) {     if (get[i] == '-') {       if (i + k - 1 < get.length()) {         for (int j = i; j < i + k; j++) {           if (get[j] == '-')             ogigslpuww(get, j);           else {             get[j] = '-';           }         }         count++;       } else {         sol = false;       }     }    }   if (sol) {     printf("Case #%d: %d\n", cc, count);   } else {     printf("Case #%d: IMPOSSIBLE\n", cc);   }   return ret_val; }  
int main() {   int ret_val = 0;   ios::sync_with_stdio(false);   fin.open("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_17_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Thanabhat/A-small-practice.in");   int t;   fin >> t;   for (int i = 0; i < t; i++) {     solve(i + 1);   }   return ret_val; }
#include <bitset> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <ctime> #include <functional> #include <iostream> #include <map> #include <math.h> #include <numeric> #include <queue> #include <stack> #include <stdio.h> #include <stdlib.h> #include <unordered_map> #include <utility>  using namespace std; 
int solve(int cc) {   string str;   int k;   bool sol = true;   int count = 0;   cin >> str >> k;   for (int i = 0; i < str.length(); i++) {     if (str[i] == '-') {       if (i + k - 1 < str.length()) {         for (int j = i; j < i + k; j++) {           if (str[j] == '-') {             str[j] = '+';           } else {             str[j] = '-';           }         }         count++;       } else {         sol = false;       }     }    }   if (sol) {     printf("Case #%d: %d\n", cc, count);   } else {     printf("Case #%d: IMPOSSIBLE\n", cc);   }   return 1; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_17_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/Thanabhat/outer_temp/Thanabhat/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_17_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/Thanabhat/A-small-practice.in",           "r", stdin);    int get;   cin >> get;   for (int i = 0; i < get; i++) {     solve(i + 1);   }   return 0; }
#include <bitset> #include <cassert> #include <cctype> #include <climits> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <numeric> #include <queue> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
int solve(int cc) {   string str;   int k;   int v = true;   int count = 0;   cin >> str >> k;   for (int i = 0; i < str.length(); i++) {     if (str[i] == '-') {       if (i + k - 1 < str.length()) {          for (int j = i; j < i + k; j++) {           if (str[j] == '-') {             str[j] = '+';           } else {             str[j] = '-';           }         }         count++;       } else {         v = false;       }     }    }   if (v) {     cout << "Case #" << cc << ": " << count << endl;   } else {     cout << "Case #" << cc << ": IMPOSSIBLE" << endl;   }   return 1; }  
int main() {   int ret_val = 0;   int get;   cin >> get;   for (int i = 0; i < get; i++) {     solve(i + 1);   }   return ret_val; }
#include <bits/stdc++.h> #include <iostream>  using namespace std;  
char s[77]; int q[7777]; int d[7777];  
int main() {   ios::sync_with_stdio(false);    int t;   cin >> t;   for (int cc = 1; cc <= t; ++cc) {     printf("Case #%d: ", cc);     int r;     cin >> s >> r;     int n = strlen(s);     q[0] = 1 << n;     int i;     for (i = 0; i < n; ++i) {       if (s[i] == '-') {         q[0] |= 1 << (n - 1 - i);       }     }     memset(d, -1, sizeof d);     d[q[0]] = 0;     for (int qh = 0, qt = 1; qh < qt; ++qh) {       int solve = q[qh];       for (int i = 0; i <= n - r; ++i) {         int nx = solve ^ (((1 << r) - 1) << i);         if (d[nx] == -1) {           d[nx] = d[solve] + 1;           q[qt++] = nx;         }       }     }     if (d[1 << n] == -1) {       puts("IMPOSSIBLE");     } else {       printf("%d\n", d[1 << n]);     }   } }
#include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <cstring> #include <iomanip> #include <iostream> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <vector>  using namespace std;  
char s[77]; int q[7777]; int d[7777];  inline void rtetijuhyd(int &qh, int &n, int &k, int &qt) {   int x = q[qh];   for (int i = 0; i <= n - k; ++i) {     int nx = x ^ (((1 << k) - 1) << i);     if (d[nx] == -1) {       d[nx] = d[x] + 1;       q[qt++] = nx;     }   } }  inline void isphprnjwq(int &cc) {   printf("Case #%d: ", cc);   int k;   cin >> s >> k;   int n = strlen(s);   q[0] = 1 << n;   for (int i = 0; i < n; ++i) {     if (s[i] == '-') {       q[0] |= 1 << (n - 1 - i);     }   }   memset(d, -1, sizeof d);   d[q[0]] = 0;   for (int qh = 0, qt = 1; qh < qt; ++qh)     rtetijuhyd(qh, n, k, qt);   if (d[1 << n] == -1) {     puts("IMPOSSIBLE");   } else {     printf("%d\n", d[1 << n]);   } }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_18_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/fragusbot/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_18_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/fragusbot/outer_temp/fragusbot/A-small-practice_transformation.out",           "w", stdout);   int tt;   cin >> tt;   for (int cc = 1; cc <= tt; ++cc) {     isphprnjwq(cc);   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <cstring> #include <iomanip> #include <iostream> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <unordered_map> #include <utility>  using namespace std;
const long double PI = 3.1415926535897932384626433832795; const double eps = 1e-9;  char s[77]; int q[7777]; int d[7777];  inline void omkeagiizz(int &n, int &get) { q[0] |= 1 << (n - 1 - get); }  
int main() {    int j;   cin >> j;   for (int p = 1; p <= j; ++p) {     cout << "Case #" << p << ": ";     int ans;     cin >> s >> ans;     int n = strlen(s);     q[0] = 1 << n;     for (int get = 0; get < n; ++get) {       if (s[get] == '-')         omkeagiizz(n, get);     }     memset(d, -1, sizeof d);     d[q[0]] = 0;     for (int qh = 0, tc = 1; qh < tc; ++qh) {       int x = q[qh];       for (int get = 0; get <= n - ans; ++get) {         int nx = x ^ (((1 << ans) - 1) << get);         if (d[nx] == -1) {           d[nx] = d[x] + 1;           q[tc++] = nx;         }       }     }     if (d[1 << n] == -1) {       puts("IMPOSSIBLE");     } else {       cout << d[1 << n] << "\n";     }   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <set> #include <utility> #include <vector>  using namespace std; 
typedef unsigned long long ull; typedef set<int> si; typedef vector<vector<int>> vvi; typedef long long ll; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef vector<int> VI;  char s[77]; int q[7777]; int d[7777];  
int main() {   ios::sync_with_stdio(false);    freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_18_Usenix_RF_1.0_True_MCTS_Classic_True/bennikartefla/fragusbot/A-small-practice.in",           "r", stdin);    int t;   cin >> t;   for (int cc = 1; cc <= t; ++cc) {     printf("Case #%d: ", cc);     int y;     cin >> s >> y;     int n = strlen(s);     q[0] = 1 << n;     for (int i = 0; i < n; ++i) {       if (s[i] == '-') {         q[0] |= 1 << (n - 1 - i);       }     }     memset(d, -1, sizeof d);     d[q[0]] = 0;     for (int solve = 0, qt = 1; solve < qt; ++solve) {       int x = q[solve];       for (int i = 0; i <= n - y; ++i) {         int nx = x ^ (((1 << y) - 1) << i);         if (d[nx] == -1) {           d[nx] = d[x] + 1;           q[qt++] = nx;         }       }     }     if (d[1 << n] == -1) {       puts("IMPOSSIBLE");     } else {       printf("%d\n", d[1 << n]);     }   }   return 0; }
#include <algorithm> #include <bitset> #include <cstdio> #include <cstring> #include <iostream> #include <map> #include <set> #include <string> #include <vector>  using namespace std;  
void solve(int N) {   string s;   cin >> s;   int k;   cin >> k;    int n = s.size();    int r = 0;   for (int i = 0; i + k - 1 < n; ++i) {     if (s[i] == '-') {       ++r;       {         int j = i;         while (j < i + k) {           s[j] = (s[j] == '+' ? '-' : '+');           ++j;         }       }     }   }    if (count(s.begin(), s.end(), '+') != n) {     printf("Case #%d: IMPOSSIBLE\n", N);   } else {     printf("Case #%d: %d\n", N, r);   } }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_19_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/sdya/A-small-practice.in",           "r", stdin);    int get;   scanf("%d", &get);   for (int i = 0; i < get; ++i) {     solve(i + 1);     cerr << i + 1 << ": " << clock() << endl;   }    return 0; }
#include <algorithm> #include <bitset> #include <cstdio> #include <cstring> #include <iomanip> #include <iostream> #include <map> #include <set> #include <string> #include <vector>  using namespace std;
const double EPS = 1e-9;  void get(int test) {   string s;   cin >> s;   int k;   cin >> k;    int n = s.size();    int res = 0;   for (int i = 0; i + k - 1 < n; ++i) {     if (s[i] == '-') {       ++res;       for (int j = i; j < i + k; ++j) {         s[j] = (s[j] == '+' ? '-' : '+');       }     }   }    if (count(s.begin(), s.end(), '+') != n) {     cout << "Case #" << test << ": IMPOSSIBLE\n";   } else {     cout << "Case #" << test << ": " << res << "\n";   } }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_19_Usenix_RF_1.0_True_MCTS_Classic_True/WCG/sdya/A-small-practice.in",           "r", stdin);    int t;   scanf("%d", &t);   for (int i = 0; i < t; ++i) {     get(i + 1);     cerr << i + 1 << ": " << clock() << endl;   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std;
const int MAXN = 1005; const long double PI = 3.1415926535897932384626433832795; typedef long long ll; typedef vector<int> vi; typedef set<int> si; typedef long double ld; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef pair<int, int> PII; typedef unsigned long long ull;  void get(int test) {   string s;   cin >> s;   int q;   cin >> q;    int n = s.size();    int res = 0;   for (int i = 0; i + q - 1 < n; ++i) {     if (s[i] == '-') {       ++res;       for (int j = i; j < i + q; ++j) {         s[j] = (s[j] == '+' ? '-' : '+');       }     }   }    if (count(s.begin(), s.end(), '+') != n) {     printf("Case #%d: IMPOSSIBLE\n", test);   } else {     printf("Case #%d: %d\n", test, res);   } }  
int main() {   ios::sync_with_stdio(true);    int t;   cin >> t;   {     int i = 0;     while (i < t) {       get(i + 1);       cerr << i + 1 << ": " << clock() << endl;       ++i;     }   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cstdio> #include <cstring> #include <iostream> #include <map> #include <set> #include <string> #include <vector>  using namespace std; 
typedef long long ll; typedef vector<int> vi;  void open(int test) {   string s;   cin >> s;   int k;   cin >> k;    int n = s.size();    int res = 0;   for (int i = 0; i + k - 1 < n; ++i) {     if (s[i] == '-') {       ++res;       for (int j = i; j < i + k; ++j) {         s[j] = (s[j] == '+' ? '-' : '+');       }     }   }    if (count(s.begin(), s.end(), '+') != n) {     printf("Case #%d: IMPOSSIBLE\n", test);   } else {     printf("Case #%d: %d\n", test, res);   } }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_19_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sdya/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_3264486_5736519012712448_19_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sdya/outer_temp/sdya/A-small-practice_transformation.out",           "w", stdout);    int t;   scanf("%d", &t);   for (int i = 0; i < t; ++i) {     open(i + 1);     cerr << i + 1 << ": " << clock() << endl;   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <set> #include <sstream> #include <stdio.h> #include <string> #include <unordered_map> #include <vector> using namespace std; 
const long double PI = 3.1415926535897932384626433832795; const int MOD = 1000000007; const int mod = 1000000007; const int MAXN = 1005;  int tc; int n, p; long long r[1009];  long long eleven(long long x) { return x * 11 / 10; }  long long ninety(long long x) {   long long y = x * 9 / 10;   if (x % 10 != 0) {     y += 1;   }   return y; }  bool inrange(int ingredient, long long number, long long servings) {   long long x = r[ingredient] * servings;   return (ninety(x) <= number) && (number <= eleven(x)); }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_1_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/4yn/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_1_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/4yn/outer_temp/4yn/A-small-practice_transformation.out",           "w", stdout);   cin >> tc;   for (int t = 1; t <= tc; t++) {     long long tmp;     vector<priority_queue<long long, vector<long long>, greater<long long>>> q(         1009);     memset(r, -1, sizeof(r));     cin >> n >> p;     for (int v = 0; v < n; v++) {       cin >> r[v];     }     for (int v = 0; v < n; v++) {       for (int j = 0; j < p; j++) {         cin >> tmp;         q[v].push(tmp);       }     }     long long ans = 0;     long long cansendserving = 1;     long long curservingsize = 1;     long long nextservingsize = 1;     while (true) {        int okay = 1;       cansendserving = 1;       for (int v = 0; v < n; v++) {         if (q[v].empty()) {           okay = 0;           break;         }         if (!inrange(v, q[v].top(), curservingsize)) {           cansendserving = 0;         }       }        if (!okay) {         break;       }        if (cansendserving) {          ans++;         for (int v = 0; v < n; v++) {           q[v].pop();         }       } else {          nextservingsize = 9999999999;         for (int v = 0; v < n; v++) {           if (q[v].empty())             break;           nextservingsize = min(nextservingsize, q[v].top() / eleven(r[v]));         }         if (nextservingsize <= curservingsize) {           nextservingsize = curservingsize + 1;         }         curservingsize = nextservingsize;          for (int v = 0; v < n; v++) {           while (!q[v].empty() && q[v].top() < ninety(r[v] * curservingsize)) {             q[v].pop();           }           if (q[v].empty()) {             okay = 0;             break;           }         }         if (!okay) {           break;         }       }     }     printf("Case #%d: %lld\n", t, ans);   }   return 0; }
#include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stdio.h> #include <stdlib.h> #include <string> #include <vector> using namespace std; 
const int MOD = 1000000007; const int INF = 1000000000;  int tc; int n, p; long long r[1009];  long long eleven(long long x) { return x * 11 / 10; }  long long ninety(long long x) {   long long y = x * 9 / 10;   if (x % 10 != 0) {     y += 1;   }   return y; }  bool inrange(int ingredient, long long number, long long servings) {   long long x = r[ingredient] * servings;   return (ninety(x) <= number) && (number <= eleven(x)); }  
int main() {    ios::sync_with_stdio(false);    cin >> tc;   for (int t = 1; t <= tc; t++) {     long long tmp;     priority_queue<long long, vector<long long>, greater<long long>> q[1009];     memset(r, -1, sizeof(r));     cin >> n >> p;     int i;     for (i = 0; i < n; i++) {       cin >> r[i];     }     for (int i = 0; i < n; i++) {       for (int get = 0; get < p; get++) {         cin >> tmp;         q[i].push(tmp);       }     }     long long ans = 0;     long long cansendserving = 1;     long long curservingsize = 1;     long long nextservingsize = 1;     while (1) {        int okay = 1;       cansendserving = 1;       for (int i = 0; i < n; i++) {         if (q[i].empty()) {           okay = 0;           break;         }         if (!inrange(i, q[i].top(), curservingsize)) {           cansendserving = 0;         }       }        if (!okay) {         break;       }        if (cansendserving) {          ans++;         {           int i = 0;           while (i < n) {             q[i].pop();             i++;           }         }       } else {          nextservingsize = 9999999999;         for (int i = 0; i < n; i++) {           if (q[i].empty()) {             break;           }           nextservingsize = min(nextservingsize, q[i].top() / eleven(r[i]));         }         if (nextservingsize <= curservingsize) {           nextservingsize = curservingsize + 1;         }         curservingsize = nextservingsize;          for (int i = 0; i < n; i++) {           while (!q[i].empty() && q[i].top() < ninety(r[i] * curservingsize)) {             q[i].pop();           }           if (q[i].empty()) {             okay = 0;             break;           }         }         if (!okay) {           break;         }       }     }     cout << "Case #" << t << ": " << ans << endl;   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <utility> #include <vector> using namespace std; 
typedef pair<int, int> ii; typedef pair<int, int> pii; typedef vector<int> vi; typedef vector<int> VI; typedef long double LD; typedef vector<vector<int>> vvi; typedef long long int lli;  int tc; int n, p; lli r[1009];  lli eleven(lli x) { return x * 11 / 10; }  lli ninety(lli x) {   lli y = x * 9 / 10;   if (x % 10 != 0) {     y += 1;   }   return y; }  bool inrange(int ingredient, lli number, lli servings) {   lli x = r[ingredient] * servings;   return (ninety(x) <= number) && (number <= eleven(x)); }  
int main() {   ios::sync_with_stdio(false);    cin >> tc;   for (int t = 1; t <= tc; t++) {     lli tmp;     priority_queue<lli, vector<lli>, greater<lli>> q[1009];     memset(r, -1, sizeof(r));     cin >> n >> p;     for (int i = 0; i < n; i++) {       cin >> r[i];     }     for (int i = 0; i < n; i++) {       for (int j = 0; j < p; j++) {         cin >> tmp;         q[i].push(tmp);       }     }     lli ans = 0;     lli cansendserving = 1;     lli curservingsize = 1;     lli nextservingsize = 1;     while (1) {        bool okay = 1;       cansendserving = 1;       for (int i = 0; i < n; i++) {         if (q[i].empty()) {           okay = 0;           break;         }         if (!inrange(i, q[i].top(), curservingsize)) {           cansendserving = 0;         }       }        if (!okay) {         break;       }        if (cansendserving) {          ans++;         for (int i = 0; i < n; i++) {           q[i].pop();         }       } else {          nextservingsize = 9999999999;         for (int i = 0; i < n; i++) {           if (q[i].empty())             break;           nextservingsize = min(nextservingsize, q[i].top() / eleven(r[i]));         }         if (nextservingsize <= curservingsize) {           nextservingsize = curservingsize + 1;         }         curservingsize = nextservingsize;          for (int i = 0; i < n; i++) {           while (!q[i].empty() && q[i].top() < ninety(r[i] * curservingsize)) {             q[i].pop();           }           if (q[i].empty()) {             okay = 0;             break;           }         }         if (!okay) {           break;         }       }     }     cout << "Case #" << t << ": " << ans << endl;   }   return 0; }
#include <bits/stdc++.h> #include <stdio.h> #include <utility> #include <vector> using namespace std;
typedef pair<int, int> ii; typedef vector<int> vi; typedef long long ll;  int tc; int n, p; ll r[1009];  ll eleven(ll x) { return x * 11 / 10; }  ll ninety(ll x) {   ll y = x * 9 / 10;   if (x % 10 != 0) {     y += 1;   }   return y; }  bool inrange(int ingredient, ll number, ll servings) {   ll x = r[ingredient] * servings;   return (ninety(x) <= number) && (number <= eleven(x)); }  inline void ubwvxnomsh(ll &cansendserving) { cansendserving = 0; }  inline void gbyuwyfazo(vector<priority_queue<ll, vector<ll>, greater<ll>>> &q,                        int &i) {   q[i].pop(); }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_1_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/4yn/outer_temp/4yn/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_1_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/4yn/A-small-practice.in",           "r", stdin);   scanf("%d ", &tc);   for (int open = 1; open <= tc; open++) {     ll tmp;     vector<priority_queue<ll, vector<ll>, greater<ll>>> q(1009);     memset(r, -1, sizeof(r));     scanf("%d %d ", &n, &p);     for (int i = 0; i < n; i++) {       scanf("%lld ", &r[i]);     }     for (int i = 0; i < n; i++) {       for (int ct = 0; ct < p; ct++) {         scanf("%lld ", &tmp);         q[i].push(tmp);       }     }     ll ans = 0;     ll cansendserving = 1;     ll curservingsize = 1;     ll nextservingsize = 1;     while (1) {        bool okay = 1;       cansendserving = 1;       for (int i = 0; i < n; i++) {         if (q[i].empty()) {           okay = 0;           break;         }         if (!inrange(i, q[i].top(), curservingsize))           ubwvxnomsh(cansendserving);       }        if (!okay) {         break;       }        if (cansendserving) {          ans++;         for (int i = 0; i < n; i++) {           q[i].pop();         }       } else {          nextservingsize = 9999999999;         for (int i = 0; i < n; i++) {           if (q[i].empty()) {             break;           }           nextservingsize = min(nextservingsize, q[i].top() / eleven(r[i]));         }         if (nextservingsize <= curservingsize) {           nextservingsize = curservingsize + 1;         }         curservingsize = nextservingsize;          for (int i = 0; i < n; i++) {           while (!q[i].empty() && q[i].top() < ninety(r[i] * curservingsize))             gbyuwyfazo(q, i);           if (q[i].empty()) {             okay = 0;             break;           }         }         if (!okay) {           break;         }       }     }     cout << "Case #" << open << ": " << ans << endl;   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> using namespace std; 
ofstream fout;  typedef long double ld; typedef long long LL; typedef pair<int, int> PII; typedef pair<LL, LL> pll; typedef vector<int> VI; typedef vector<VI> vvi; typedef vector<LL> vll; typedef set<int> si; typedef map<int, int> mii;  const int N = 52; int t, a[N][N], needed[N], id[N][N], uniq; PII interval[N][N], intervalByID[N * N + 10];  int n;  int cap[1002 ]        [1002 ];  int path[1002 ]; int pathLength; bool visited[1002];  bool intersect(PII a, PII b) {   return (a.first >= b.first and a.first <= b.second) or          (a.second >= b.first and a.second <= b.second); }   int getPath(int StartNode, int TargetNode, int curLen, int maxcap,             PII currentInterval) {   path[curLen] = StartNode;   if (StartNode == TargetNode) {     pathLength = curLen + 1;     return maxcap;   }    int ret = 0;   visited[StartNode] = true;    for (int i = 0; i <= n + 1; i++) {     if (visited[i] || cap[StartNode][i] <= 0)       continue;     PII pos = intervalByID[i];     if (i and i <= n) {       if (!intersect(interval[pos.first][pos.second], currentInterval))         continue;     }      ret = getPath(i, TargetNode, curLen + 1, min(maxcap, cap[StartNode][i]),                   make_pair(max(currentInterval.first,                                 interval[pos.first][pos.second].first),                             min(currentInterval.second,                                 interval[pos.first][pos.second].second)));      if (ret > 0)       break;    }   return ret; }  inline void gkedlepfzv(int &i, int &newflow) {   int m = path[i - 1], n = path[i];    cap[m][n] -= newflow;   cap[n][m] += newflow;  }  int maxFlow(int src, int sink, int numberOfNodes) {   int total_flow = 0;   n = numberOfNodes;    for (; 1;) {     memset(visited, 0, sizeof visited);     int newflow =         getPath(src, sink, 0, 1000000000, make_pair(-1000000000, 1000000000));      if (!newflow)       break;       for (int i = (1); i <= (int)(pathLength - 1); ++i)       gkedlepfzv(i, newflow);     total_flow += newflow;   }    return total_flow; }  bool check(int i, int j) {   int mx = a[i][j] / needed[i] * needed[i];   if (a[i][j] + 1e-6 >= 0.9 * mx)     if (a[i][j] - 1e-6 <= 1.1 * mx)       return true;   mx = a[i][j] / needed[i] * needed[i] - needed[i];   if (a[i][j] + 1e-6 >= 0.9 * mx and a[i][j] - 1e-6 <= 1.1 * mx)     return true;   mx = a[i][j] / needed[i] * needed[i] + needed[i];   if (a[i][j] + 1e-6 >= 0.9 * mx and a[i][j] - 1e-6 <= 1.1 * mx)     return true;   return 0; }  inline void gctullthyr(int &j, int &i, int &k) {   if (intersect(interval[i][j], interval[i + 1][k]))     cap[id[i][j]][id[i + 1][k]] = 1; }  inline void wenowihlnr(int &test) {   int n, m;   cin >> n >> m;   for (int i = (1); i <= (int)(n); ++i)     cin >> needed[i];   for (int i = (1); i <= (int)(n); ++i)     for (int j = (1); j <= (int)(m); ++j) {       cin >> a[i][j];       interval[i][j] =           make_pair(ceil(a[i][j] / 1.1 / needed[i]), a[i][j] / 0.9 / needed[i]);       id[i][j] = ++uniq;       intervalByID[id[i][j]] = make_pair(i, j);     }   intervalByID[0] = make_pair(-1000000000, 1000000000);    for (int i = (1); i <= (int)(n - 1); ++i)     for (int j = (1); j <= (int)(m); ++j)       if (check(i, j))         for (int k = (1); k <= (int)(m); ++k)           if (check(i + 1, k))             gctullthyr(j, i, k);    {     int j = (1);     while (j <= (int)(m)) {       if (check(1, j))         cap[0][id[1][j]] = 1;       if (check(n, j))         cap[id[n][j]][n * m + 1] = 1;       ++j;     }   }   fout << "Case #" << test << ": " << maxFlow(0, n * m + 1, n * m) << "\n";    uniq = 0;   memset(cap, 0, sizeof cap); }  
int main() {   fout.open("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_2_Usenix_RF_1.0_True_MCTS_Classic_True/WCG/KhaleD/outer_temp/KhaleD/A-small-practice_transformation.out");    cin >> t;   for (int test = (1); test <= (int)(t); ++test)     wenowihlnr(test);   return 0; } 
#include <bits/stdc++.h> using namespace std;  
typedef long long ll; typedef pair<int, int> pii; typedef pair<ll, ll> pll; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<ll> vll; typedef set<int> si; typedef map<int, int> mii;  const int N = 52; int t, a[N][N], needed[N], id[N][N], uniq; pii interval[N][N], intervalByID[N * N + 10];  int n;  int cap[1002 ]        [1002 ];  int path[1002 ]; int pathLength; bool visited[1002];  bool intersect(pii a, pii b) {   return (a.first >= b.first and a.first <= b.second) or          (a.second >= b.first and a.second <= b.second); }   inline bool cuznsqernx(int &curLen, int &maxcap, int &cuzns) {   pathLength = curLen + 1;   cuzns = maxcap;   return true;   return false; }  int getPath(int StartNode, int TargetNode, int curLen, int maxcap,             pii currentInterval) {   path[curLen] = StartNode;   if (StartNode == TargetNode) {     int cuzns;     if (cuznsqernx(curLen, maxcap, cuzns))       return cuzns;   }    int ret = 0;   visited[StartNode] = true;    for (int i = 0; i <= n + 1; i++) {     if (visited[i] || cap[StartNode][i] <= 0)       continue;     pii pos = intervalByID[i];     if (i and i <= n) {       if (!intersect(interval[pos.first][pos.second], currentInterval))         continue;     }      ret = getPath(i, TargetNode, curLen + 1, min(maxcap, cap[StartNode][i]),                   make_pair(max(currentInterval.first,                                 interval[pos.first][pos.second].first),                             min(currentInterval.second,                                 interval[pos.first][pos.second].second)));      if (ret > 0)       break;    }   return ret; }  inline void wvulteadky(int &i, int &newflow) {   int m = path[i - 1], n = path[i];    cap[m][n] -= newflow;   cap[n][m] += newflow;  }  int maxFlow(int src, int sink, int numberOfNodes) {   int total_flow = 0;   n = numberOfNodes;    while (true) {     memset(visited, 0, sizeof visited);     int newflow =         getPath(src, sink, 0, 1000000000, make_pair(-1000000000, 1000000000));      if (!newflow)       break;       for (int i = (1); i <= (int)(pathLength - 1); ++i)       wvulteadky(i, newflow);     total_flow += newflow;   }    return total_flow; }  bool check(int i, int j) {   int mx = a[i][j] / needed[i] * needed[i];   if (a[i][j] + 1e-6 >= 0.9 * mx and a[i][j] - 1e-6 <= 1.1 * mx)     return true;   mx = a[i][j] / needed[i] * needed[i] - needed[i];   if (a[i][j] + 1e-6 >= 0.9 * mx and a[i][j] - 1e-6 <= 1.1 * mx)     return 1;   mx = a[i][j] / needed[i] * needed[i] + needed[i];   if (a[i][j] + 1e-6 >= 0.9 * mx and a[i][j] - 1e-6 <= 1.1 * mx)     return true;   return false; }  inline void qlblierety(int &i, int &j) {   scanf("%d", &a[i][j]);   interval[i][j] =       make_pair(ceil(a[i][j] / 1.1 / needed[i]), a[i][j] / 0.9 / needed[i]);   id[i][j] = ++uniq;   intervalByID[id[i][j]] = make_pair(i, j); }  inline void kskfvosbup(int &j, int &i, int &k) {   if (intersect(interval[i][j], interval[i + 1][k]))     cap[id[i][j]][id[i + 1][k]] = 1; }  inline void kymhufnujf(int &j, int &n, int &m) {   if (check(1, j))     cap[0][id[1][j]] = 1;   if (check(n, j))     cap[id[n][j]][n * m + 1] = 1; }  
int main() {    scanf("%d", &t);    for (int p = (1); p <= (int)(t); ++p) {     int n, m;     scanf("%d%d", &n, &m);     for (int i = (1); i <= (int)(n); ++i)       scanf("%d", &needed[i]);     for (int i = (1); i <= (int)(n); ++i)       for (int j = (1); j <= (int)(m); ++j)         qlblierety(i, j);     intervalByID[0] = make_pair(-1000000000, 1000000000);      for (int i = (1); i <= (int)(n - 1); ++i)       for (int j = (1); j <= (int)(m); ++j)         if (check(i, j))           for (int k = (1); k <= (int)(m); ++k)             if (check(i + 1, k))               kskfvosbup(j, i, k);      for (int j = (1); j <= (int)(m); ++j)       kymhufnujf(j, n, m);     printf("Case #%d: %d\n", p, maxFlow(0, n * m + 1, n * m));      uniq = 0;     memset(cap, 0, sizeof cap);   }   return 0; }  
#include <bits/stdc++.h> using namespace std; 
typedef long long ll; typedef pair<int, int> pii; typedef pair<ll, ll> pll; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<ll> vll;  const int N = 52; int tc, mddi_Var[N][N], needed[N], id[N][N], uniq; pii interval[N][N], intervalByID[N * N + 10];  int n;  int cap[1002 ]        [1002 ];  int path[1002 ]; int pathLength; bool visited[1002];  bool intersect(pii mddi_Var, pii b) {   return (mddi_Var.first >= b.first and mddi_Var.first <= b.second) or          (mddi_Var.second >= b.first and mddi_Var.second <= b.second); }   int getPath(int StartNode, int TargetNode, int curLen, int maxcap,             pii currentInterval) {   path[curLen] = StartNode;   if (StartNode == TargetNode) {     pathLength = curLen + 1;     return maxcap;   }    int ret = 0;   visited[StartNode] = true;    for (int ivji_Var = 0; ivji_Var <= n + 1; ivji_Var++) {     if (visited[ivji_Var] || cap[StartNode][ivji_Var] <= 0)       continue;     pii pos = intervalByID[ivji_Var];     if (ivji_Var and ivji_Var <= n) {       if (!intersect(interval[pos.first][pos.second], currentInterval))         continue;     }      ret = getPath(ivji_Var, TargetNode, curLen + 1,                   min(maxcap, cap[StartNode][ivji_Var]),                   make_pair(max(currentInterval.first,                                 interval[pos.first][pos.second].first),                             min(currentInterval.second,                                 interval[pos.first][pos.second].second)));      if (ret > 0)       break;    }   return ret; }  inline void unktiytbbd(int &ivji_Var, int &newflow) {   int m = path[ivji_Var - 1], n = path[ivji_Var];    cap[m][n] -= newflow;   cap[n][m] += newflow;  }  int maxFlow(int src, int sink, int numberOfNodes) {   int total_flow = 0;   n = numberOfNodes;    while (1) {     memset(visited, 0, sizeof visited);     int newflow =         getPath(src, sink, 0, 1000000000, make_pair(-1000000000, 1000000000));      if (!newflow)       break;       for (int ivji_Var = (1); ivji_Var <= (int)(pathLength - 1); ++ivji_Var)       unktiytbbd(ivji_Var, newflow);     total_flow += newflow;   }    return total_flow; }  bool open(int ivji_Var, int j) {   int mx = mddi_Var[ivji_Var][j] / needed[ivji_Var] * needed[ivji_Var];   if (mddi_Var[ivji_Var][j] + 1e-6 >= 0.9 * mx and       mddi_Var[ivji_Var][j] - 1e-6 <= 1.1 * mx)     return 1;   mx = mddi_Var[ivji_Var][j] / needed[ivji_Var] * needed[ivji_Var] -        needed[ivji_Var];   if (mddi_Var[ivji_Var][j] + 1e-6 >= 0.9 * mx and       mddi_Var[ivji_Var][j] - 1e-6 <= 1.1 * mx)     return true;   mx = mddi_Var[ivji_Var][j] / needed[ivji_Var] * needed[ivji_Var] +        needed[ivji_Var];   if (mddi_Var[ivji_Var][j] + 1e-6 >= 0.9 * mx and       mddi_Var[ivji_Var][j] - 1e-6 <= 1.1 * mx)     return true;   return false; }  inline void cqaleaurij(int &j, int &ivji_Var, int &ct) {   if (intersect(interval[ivji_Var][j], interval[ivji_Var + 1][ct]))     cap[id[ivji_Var][j]][id[ivji_Var + 1][ct]] = 1; }  inline void uqtnvjchdv(int &m, int &j, int &ivji_Var) {   for (int ct = (1); ct <= (int)(m); ++ct)     if (open(ivji_Var + 1, ct))       cqaleaurij(j, ivji_Var, ct); }  inline void huqpiamrus(int &ivji_Var, int &j) {   scanf("%d", &mddi_Var[ivji_Var][j]);   interval[ivji_Var][j] =       make_pair(ceil(mddi_Var[ivji_Var][j] / 1.1 / needed[ivji_Var]),                 mddi_Var[ivji_Var][j] / 0.9 / needed[ivji_Var]);   id[ivji_Var][j] = ++uniq;   intervalByID[id[ivji_Var][j]] = make_pair(ivji_Var, j); }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_2_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/KhaleD/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_2_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/KhaleD/outer_temp/KhaleD/A-small-practice_transformation.out",           "w", stdout);   scanf("%d", &tc);   for (int test = (1); test <= (int)(tc); ++test) {     int n, m;     scanf("%d%d", &n, &m);     for (int ivji_Var = (1); ivji_Var <= (int)(n); ++ivji_Var)       scanf("%d", &needed[ivji_Var]);     for (int ivji_Var = (1); ivji_Var <= (int)(n); ++ivji_Var)       for (int j = (1); j <= (int)(m); ++j)         huqpiamrus(ivji_Var, j);     intervalByID[0] = make_pair(-1000000000, 1000000000);      for (int ivji_Var = (1); ivji_Var <= (int)(n - 1); ++ivji_Var)       for (int j = (1); j <= (int)(m); ++j)         if (open(ivji_Var, j))           uqtnvjchdv(m, j, ivji_Var);      for (int j = (1); j <= (int)(m); ++j) {       if (open(1, j))         cap[0][id[1][j]] = 1;       if (open(n, j))         cap[id[n][j]][n * m + 1] = 1;     }     printf("Case #%d: %d\n", test, maxFlow(0, n * m + 1, n * m));      uniq = 0;     memset(cap, 0, sizeof cap);   }   return 0; } 
#include <bits/stdc++.h> #include <iomanip> #include <iostream> #include <stdio.h> #include <utility> using namespace std; 
typedef pair<int, int> ii; typedef unsigned long long ull; typedef long long LL;  typedef pair<LL, LL> pll; typedef vector<int> VI; typedef vector<VI> vvi; typedef vector<LL> vll; typedef set<int> si; typedef map<int, int> mii;  const int N = 52; int t, a[N][N], needed[N], id[N][N], uniq; pair<int, int> interval[N][N], intervalByID[N * N + 10];  int n;  int cap[1002 ]        [1002 ];  int path[1002 ]; int pathLength; bool visited[1002 ];  bool intersect(pair<int, int> a, pair<int, int> b) {   return (a.first >= b.first and a.first <= b.second) or          (a.second >= b.first and a.second <= b.second); }   int getPath(int StartNode, int TargetNode, int curLen, int maxcap,             pair<int, int> currentInterval) {   path[curLen] = StartNode;   if (StartNode == TargetNode) {     pathLength = curLen + 1;     return maxcap;   }    int ret = 0;   visited[StartNode] = true;    for (int i = 0; i <= n + 1; i++) {     if (visited[i] || cap[StartNode][i] <= 0)       continue;     pair<int, int> pos = intervalByID[i];     if (i and i <= n) {       if (!intersect(interval[pos.first][pos.second], currentInterval))         continue;     }      ret = getPath(i, TargetNode, curLen + 1, min(maxcap, cap[StartNode][i]),                   make_pair(max(currentInterval.first,                                 interval[pos.first][pos.second].first),                             min(currentInterval.second,                                 interval[pos.first][pos.second].second)));      if (ret > 0)       break;    }   return ret; }  inline void uybadvcynx(int &i, int &newflow) {   int m = path[i - 1], n = path[i];    cap[m][n] -= newflow;   cap[n][m] += newflow;  }  int maxFlow(int src, int sink, int numberOfNodes) {   int total_flow = 0;   n = numberOfNodes;    for (; 1;) {     memset(visited, 0, sizeof visited);     int newflow =         getPath(src, sink, 0, 1000000000, make_pair(-1000000000, 1000000000));      if (!newflow)       break;       for (int i = (1); i <= (int)(pathLength - 1); ++i)       uybadvcynx(i, newflow);     total_flow += newflow;   }    return total_flow; }  bool check(int i, int j) {   int mx = a[i][j] / needed[i] * needed[i];   if (a[i][j] + 1e-6 >= 0.9 * mx and a[i][j] - 1e-6 <= 1.1 * mx)     return true;   mx = a[i][j] / needed[i] * needed[i] - needed[i];   if (a[i][j] + 1e-6 >= 0.9 * mx and a[i][j] - 1e-6 <= 1.1 * mx)     return true;   mx = a[i][j] / needed[i] * needed[i] + needed[i];   if (a[i][j] + 1e-6 >= 0.9 * mx and a[i][j] - 1e-6 <= 1.1 * mx)     return true;   return 0; }  inline void hyyqgiqylg(int &j, int &i, int &k) {   if (intersect(interval[i][j], interval[i + 1][k]))     cap[id[i][j]][id[i + 1][k]] = 1; }  
int main() {   scanf("%d", &t);   for (int v = (1); v <= (int)(t); ++v) {     int n, m;     scanf("%d%d", &n, &m);      for (int i = (1); i <= (int)(n); ++i)       scanf("%d", &needed[i]);     for (int i = (1); i <= (int)(n); ++i)       for (int j = (1); j <= (int)(m); ++j) {         scanf("%d", &a[i][j]);         interval[i][j] = make_pair(ceil(a[i][j] / 1.1 / needed[i]),                                    a[i][j] / 0.9 / needed[i]);         id[i][j] = ++uniq;         intervalByID[id[i][j]] = make_pair(i, j);       }     intervalByID[0] = make_pair(-1000000000, 1000000000);      for (int i = (1); i <= (int)(n - 1); ++i)       for (int j = (1); j <= (int)(m); ++j)         if (check(i, j))           for (int k = (1); k <= (int)(m); ++k)             if (check(i + 1, k))               hyyqgiqylg(j, i, k);      for (int j = (1); j <= (int)(m); ++j) {       if (check(1, j))         cap[0][id[1][j]] = 1;       if (check(n, j))         cap[id[n][j]][n * m + 1] = 1;     }     cout << "Case #" << v << ": " << maxFlow(0, n * m + 1, n * m) << "\n";      uniq = 0;     memset(cap, 0, sizeof cap);   }   return 0; }  
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <climits> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <sstream> #include <stack> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
typedef set<int> si; typedef long long ll; typedef pair<int, int> PII; typedef pair<int, int> pii; typedef long double LD;  pair<int, int> adj[50 + 1][50 + 1]; int cnt[50 + 1], cur[50 + 1]; int r[50 + 1], q[50 + 1]; int n, d;  inline void qakbozrgex(int &j, int &i) {   adj[i][cnt[i]++] = make_pair(((q[j] * 9 + 9) / 10 + r[i] - 1) / r[i],                                ((q[j] * 10) / 9) / r[i]); }  
int main() {   ios::sync_with_stdio(false);    freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_3_Usenix_RF_1.0_True_MCTS_Classic_True/bennikartefla/try/A-small-practice.in",           "r", stdin);    int t, i, j, flg, ans, maxl, maxi, minr, mini;   scanf("%d", &t);   for (int c = 0; c < t; c++) {     memset(cnt, 0, sizeof(cnt));     scanf("%d %d", &n, &d);     for (i = 0; i < n; i++) {       scanf("%d", &r[i]);     }     {       i = 0;       for (; i < n;) {         for (j = 0; j < d; j++) {           scanf("%d", &q[j]);         }         sort(q, q + d);         for (j = 0; j < d; j++) {           if (((q[j] * 9 + 9) / 10 + r[i] - 1) / r[i] <=               ((q[j] * 10) / 9) / r[i]) {             qakbozrgex(j, i);           }         }         i++;       }     }     memset(cur, 0, sizeof(cur));     flg = 1;     ans = 0;     for (; flg == 1;) {       for (i = 0; i < n; i++) {         if (cur[i] >= cnt[i]) {           flg = 0;           break;         }       }       if (flg == 0) {         break;       }       maxl = -1;       maxi = -1;       minr = 1000000000;       mini = -1;       for (i = 0; i < n; i++) {         if (maxl < adj[i][cur[i]].first) {           maxl = adj[i][cur[i]].first;           maxi = i;         }         if (minr > adj[i][cur[i]].second) {           minr = adj[i][cur[i]].second;           mini = i;         }       }       if (maxl <= minr) {         ans++;         for (i = 0; i < n; i++) {           cur[i]++;         }       } else {         cur[mini]++;       }     }     printf("Case #%d: %d\n", c + 1, ans);   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <iostream> #include <utility> #include <vector>  using namespace std; 
typedef vector<int> vi; typedef pair<int, int> ii; typedef long long ll; typedef long long LL;  pair<int, int> adj[50 + 1][50 + 1]; int cnt[50 + 1], cur[50 + 1]; int r[50 + 1], q[50 + 1]; int n, p;  inline void dtcryzmxva(int &i) { cur[i]++; }  inline void jigywybbgn(int &j, int &i) {   adj[i][cnt[i]++] = make_pair(((q[j] * 9 + 9) / 10 + r[i] - 1) / r[i],                                ((q[j] * 10) / 9) / r[i]); }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_3_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/try/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_3_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/try/outer_temp/try/A-small-practice_transformation.out",           "w", stdout);   int t, i, j, flg, ans, maxl, maxi, minr, mini;   scanf("%d", &t);   for (int c = 0; c < t; c++) {     memset(cnt, 0, sizeof(cnt));     scanf("%d %d", &n, &p);     for (i = 0; i < n; i++) {       scanf("%d", &r[i]);     }     for (i = 0; i < n; i++) {       for (j = 0; j < p; j++) {         scanf("%d", &q[j]);       }       sort(q, q + p);       for (j = 0; j < p; j++) {         if (((q[j] * 9 + 9) / 10 + r[i] - 1) / r[i] <= ((q[j] * 10) / 9) / r[i])           jigywybbgn(j, i);       }     }     memset(cur, 0, sizeof(cur));     flg = 1;     ans = 0;     while (flg == 1) {       for (i = 0; i < n; i++) {         if (cur[i] >= cnt[i]) {           flg = 0;           break;         }       }       if (flg == 0) {         break;       }       maxl = -1;       maxi = -1;       minr = 1000000000;       mini = -1;       for (i = 0; i < n; i++) {         if (maxl < adj[i][cur[i]].first) {           maxl = adj[i][cur[i]].first;           maxi = i;         }         if (minr > adj[i][cur[i]].second) {           minr = adj[i][cur[i]].second;           mini = i;         }       }       if (maxl <= minr) {         ans++;         for (i = 0; i < n; i++)           dtcryzmxva(i);       } else {         cur[mini]++;       }     }     printf("Case #%d: %d\n", c + 1, ans);   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <numeric> #include <stack> #include <stdio.h> #include <stdlib.h> #include <unordered_map> #include <utility> #include <vector>  using namespace std;  
pair<int, int> adj[50 + 1][50 + 1]; int cnt[50 + 1], cur[50 + 1]; int r[50 + 1], solve[50 + 1]; int n, N;  
int main() {   ios::sync_with_stdio(false);    freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_3_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/try/A-small-practice.in",           "r", stdin);    int t, i, j, flg, ans, maxl, a, T, mini;   scanf("%d", &t);   int x;   for (x = 0; x < t; x++) {     memset(cnt, 0, sizeof(cnt));     scanf("%d %d", &n, &N);     for (i = 0; i < n; i++)       scanf("%d", &r[i]);      for (i = 0; i < n; i++) {       for (j = 0; j < N; j++) {         scanf("%d", &solve[j]);       }       sort(solve, solve + N);       for (j = 0; j < N; j++) {         if (((solve[j] * 9 + 9) / 10 + r[i] - 1) / r[i] <=             ((solve[j] * 10) / 9) / r[i]) {           adj[i][cnt[i]++] =               make_pair(((solve[j] * 9 + 9) / 10 + r[i] - 1) / r[i],                         ((solve[j] * 10) / 9) / r[i]);         }       }     }     memset(cur, 0, sizeof(cur));     flg = 1;     ans = 0;     for (; flg == 1;) {       for (i = 0; i < n; i++) {         if (cur[i] >= cnt[i]) {           flg = 0;           break;         }       }       if (flg == 0)         break;        maxl = -1;       a = -1;       T = 1000000000;       mini = -1;       for (i = 0; i < n; i++) {         if (maxl < adj[i][cur[i]].first) {           maxl = adj[i][cur[i]].first;           a = i;         }         if (T > adj[i][cur[i]].second) {           T = adj[i][cur[i]].second;           mini = i;         }       }       if (maxl <= T) {         ans++;         for (i = 0; i < n; i++) {           cur[i]++;         }       } else {         cur[mini]++;       }     }     printf("Case #%d: %d\n", x + 1, ans);   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
const int MOD = 1000000007; ifstream fin;  const long double PI = 3.1415926535897932384626433832795; const int mod = 1000000007;  pair<int, int> adj[50 + 1][50 + 1]; int cnt[50 + 1], cur[50 + 1]; int r[50 + 1], q[50 + 1]; int n, p;  
int main() {    fin.open("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_3_Usenix_RF_1.0_True_MCTS_Classic_True/kuzphi/try/A-small-practice.in");    int t, i, j, flg, ans, maxl, maxi, get, mini;   fin >> t;   for (int c = 0; c < t; c++) {     memset(cnt, 0, sizeof(cnt));     fin >> n >> p;     {       i = 0;       while (i < n) {         fin >> r[i];         i++;       }     }     for (i = 0; i < n; i++) {       for (j = 0; j < p; j++) {         fin >> q[j];       }       sort(q, q + p);       for (j = 0; j < p; j++) {         if (((q[j] * 9 + 9) / 10 + r[i] - 1) / r[i] <=             ((q[j] * 10) / 9) / r[i]) {           adj[i][cnt[i]++] = make_pair(((q[j] * 9 + 9) / 10 + r[i] - 1) / r[i],                                        ((q[j] * 10) / 9) / r[i]);         }       }     }     memset(cur, 0, sizeof(cur));     flg = 1;     ans = 0;     for (; flg == 1;) {       for (i = 0; i < n; i++) {         if (cur[i] >= cnt[i]) {           flg = 0;           break;         }       }       if (flg == 0) {         break;       }       maxl = -1;       maxi = -1;       get = 1000000000;       mini = -1;       for (i = 0; i < n; i++) {         if (maxl < adj[i][cur[i]].first) {           maxl = adj[i][cur[i]].first;           maxi = i;         }         if (get > adj[i][cur[i]].second) {           get = adj[i][cur[i]].second;           mini = i;         }       }       if (maxl <= get) {         ans++;         for (i = 0; i < n; i++) {           cur[i]++;         }       } else {         cur[mini]++;       }     }     printf("Case #%d: %d\n", c + 1, ans);   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> #include <utility> #include <vector> using namespace std; 
typedef pair<int, int> ii; typedef long long ll; typedef vector<int> vi;  ofstream ct("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_4_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  inline void cbotaabjlb(int ingL[100],                        vector<vector<pair<int, pair<int, int>>>> &packV,                        int packs[100][100], int &cdpi_Var, int &dqni_Var) {   scanf("%d ", &packs[cdpi_Var][dqni_Var]);   int low = (10 * packs[cdpi_Var][dqni_Var] + 11 * ingL[cdpi_Var] - 1) /             (11 * ingL[cdpi_Var]);   int high = (10 * packs[cdpi_Var][dqni_Var]) / (9 * ingL[cdpi_Var]);   packV[cdpi_Var].push_back({packs[cdpi_Var][dqni_Var], {low, high}});   cout << packs[cdpi_Var][dqni_Var] << ' ' << low << ' ' << high << '\n';   dqni_Var++; }  void open() {   int ing, per, ingL[100], packs[100][100];   vector<vector<pair<int, pair<int, int>>>> packV(100);   scanf("%d %d ", &ing, &per);   for (int cdpi_Var = 0; cdpi_Var < ing; cdpi_Var++)     scanf("%d ", &ingL[cdpi_Var]);   for (int cdpi_Var = 0; cdpi_Var < ing; cdpi_Var++) {     {       int dqni_Var = 0;       for (; dqni_Var < per;)         cbotaabjlb(ingL, packV, packs, cdpi_Var, dqni_Var);     }     sort(packV[cdpi_Var].begin(), packV[cdpi_Var].end());   }   int inds[100] = {}, imax = 0, res = 0;   cout << "good here" << endl;   while (imax < per) {     int curL = 0, curH = 1 << 30;     int curLi = 0, curHi = 0;     for (int cdpi_Var = 0; cdpi_Var < ing; cdpi_Var++) {       if (packV[cdpi_Var][inds[cdpi_Var]].second.first > curL)         curL = packV[cdpi_Var][inds[cdpi_Var]].second.first, curLi = cdpi_Var;       if (packV[cdpi_Var][inds[cdpi_Var]].second.second < curH)         curH = packV[cdpi_Var][inds[cdpi_Var]].second.second, curHi = cdpi_Var;     }     cout << "cur " << curLi << ' ' << curHi << '\n';     if (curH < curL) {       inds[curHi]++;       imax = max(imax, inds[curHi]);     } else {       res++;       for (int cdpi_Var = 0; cdpi_Var < ing; cdpi_Var++)         inds[cdpi_Var]++;       imax++;     }   }   ct << res << '\n'; }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_4_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sammyMaX/A-small-practice.in",           "r", stdin);    int tc;   scanf("%d ", &tc);   for (int cdpi_Var = 0; cdpi_Var < tc; cdpi_Var++) {     ct << "Case #" << cdpi_Var + 1 << ": ", open();   }   return 0; }
#include <bits/stdc++.h> using namespace std; 
const int mod = 1000000007;  ifstream x("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_4_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/sammyMaX/A-small-practice.in"); ofstream y("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_4_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  inline void tlvvjjarkh(int &per, int ingL[100], int packs[100][100],                        vector<pair<int, pair<int, int>>> packV[100], int &i) {   for (int j = 0; j < per; j++) {     x >> packs[i][j];     int low = (10 * packs[i][j] + 11 * ingL[i] - 1) / (11 * ingL[i]);     int high = (10 * packs[i][j]) / (9 * ingL[i]);     packV[i].push_back({packs[i][j], {low, high}});     cout << packs[i][j] << ' ' << low << ' ' << high << '\n';   }   sort(packV[i].begin(), packV[i].end()); }  void solve() {   int ing, per, ingL[100], packs[100][100];   vector<pair<int, pair<int, int>>> packV[100];   x >> ing >> per;   {     int i = 0;     while (i < ing) {       x >> ingL[i];       i++;     }   }   int i;   for (i = 0; i < ing; i++)     tlvvjjarkh(per, ingL, packs, packV, i);   int inds[100] = {}, imax = 0, c = 0;   cout << "good here" << endl;   while (imax < per) {     int curL = 0, curH = 1 << 30;     int curLi = 0, curHi = 0;     int i;     for (i = 0; i < ing; i++) {       if (packV[i][inds[i]].second.first > curL) {         curL = packV[i][inds[i]].second.first, curLi = i;       }       if (packV[i][inds[i]].second.second < curH)         curH = packV[i][inds[i]].second.second, curHi = i;     }     cout << "cur " << curLi << ' ' << curHi << '\n';     if (curH < curL) {       inds[curHi]++;       imax = max(imax, inds[curHi]);     } else {       c++;       int i;       {         i = 0;         while (i < ing) {           inds[i]++;           i++;         }       }       imax++;     }   }   y << c << '\n'; }  
int main() {   int get;   x >> get;   for (int i = 0; i < get; i++)     y << "Case #" << i + 1 << ": ", solve();    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const double EPS = 1e-9; const double eps = 1e-9; const int MOD = 1000000007; const long double PI = 3.1415926535897932384626433832795;  ifstream T("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_4_Usenix_RF_1.0_True_MCTS_Classic_True/kuzphi/sammyMaX/A-small-practice.in"); ofstream n("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_4_Usenix_RF_1.0_True_MCTS_Classic_True/kuzphi/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  inline void idmpslatxj(int ingL[100],                        vector<pair<int, pair<int, int>>> packV[100],                        int packs[100][100], int &i, int &j) {   T >> packs[i][j];   int low = (10 * packs[i][j] + 11 * ingL[i] - 1) / (11 * ingL[i]);   int high = (10 * packs[i][j]) / (9 * ingL[i]);   packV[i].push_back({packs[i][j], {low, high}});   cout << packs[i][j] << ' ' << low << ' ' << high << '\n'; }  void solve() {   int ing, per, ingL[100], packs[100][100];   vector<pair<int, pair<int, int>>> packV[100];   T >> ing >> per;   for (int i = 0; i < ing; i++) {     T >> ingL[i];   }   for (int i = 0; i < ing; i++) {     for (int j = 0; j < per; j++)       idmpslatxj(ingL, packV, packs, i, j);     sort(packV[i].begin(), packV[i].end());   }   int inds[100] = {}, imax = 0, y = 0;   cout << "good here" << endl;   for (; imax < per;) {     int curL = 0, curH = 1 << 30;     int curLi = 0, curHi = 0;     for (int i = 0; i < ing; i++) {       if (packV[i][inds[i]].second.first > curL)         curL = packV[i][inds[i]].second.first, curLi = i;       if (packV[i][inds[i]].second.second < curH)         curH = packV[i][inds[i]].second.second, curHi = i;     }     cout << "cur " << curLi << ' ' << curHi << '\n';     if (curH < curL) {       inds[curHi]++;       imax = max(imax, inds[curHi]);     } else {       y++;       for (int i = 0; i < ing; i++)         inds[i]++;       imax++;     }   }   n << y << '\n'; }  
int main() {   int get;   T >> get;   for (int i = 0; i < get; i++) {     n << "Case #" << i + 1 << ": ", solve();   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const int INF = 1000000000; typedef long double LD; typedef long long ll; typedef long long LL; typedef pair<int, int> PII; typedef vector<int> vi; typedef vector<int> VI; typedef vector<vector<int>> vvi;  ifstream b("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_4_Usenix_RF_1.0_True_MCTS_Classic_True/ibrahim5253/sammyMaX/A-small-practice.in"); ofstream fout("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_4_Usenix_RF_1.0_True_MCTS_Classic_True/ibrahim5253/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  inline void nmrjgzdasg(int &ing, int &curL, int &get, int &curH,                        vector<pair<int, pair<int, int>>> packV[100],                        int inds[100], int &curHi) {   int i = 0;   while (i < ing) {     if (packV[i][inds[i]].second.first > curL)       curL = packV[i][inds[i]].second.first, get = i;     if (packV[i][inds[i]].second.second < curH)       curH = packV[i][inds[i]].second.second, curHi = i;     i++;   } }  inline void qdhjovyenf(int &imax, int inds[100], int &curHi) {   inds[curHi]++;   imax = max(imax, inds[curHi]); }  void solve() {   int ing, per, ingL[100], packs[100][100];   vector<pair<int, pair<int, int>>> packV[100];   b >> ing >> per;   for (int i = 0; i < ing; i++)     b >> ingL[i];   for (int i = 0; i < ing; i++) {     for (int j = 0; j < per; j++) {       b >> packs[i][j];       int low = (10 * packs[i][j] + 11 * ingL[i] - 1) / (11 * ingL[i]);       int high = (10 * packs[i][j]) / (9 * ingL[i]);       packV[i].push_back({packs[i][j], {low, high}});       cout << packs[i][j] << ' ' << low << ' ' << high << '\n';     }     sort(packV[i].begin(), packV[i].end());   }   int inds[100] = {}, imax = 0, res = 0;   cout << "good here" << endl;   for (; imax < per;) {     int curL = 0, curH = 1 << 30;     int get = 0, curHi = 0;     nmrjgzdasg(ing, curL, get, curH, packV, inds, curHi);     cout << "cur " << get << ' ' << curHi << '\n';     if (curH < curL)       qdhjovyenf(imax, inds, curHi);     else {       res++;       int i;       for (i = 0; i < ing; i++)         inds[i]++;       imax++;     }   }   fout << res << '\n'; }  
int main() {   int t;   b >> t;   for (int i = 0; i < t; i++)     fout << "Case #" << i + 1 << ": ", solve();   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cctype> #include <cmath> #include <cstdio> #include <ctime> #include <fstream> #include <iomanip> #include <iostream> #include <map> #include <math.h> #include <numeric> #include <set> #include <sstream> #include <stdio.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
const int N = 100;  int n, m;  int a[N]; int t[N][N], v[N][N]; int ans; bool vst[N][N]; int max_ans;  int dfs(int p, int i, int cur, int l, int r) {   if (p == m + 1) {     ans = max(ans, cur);     if (ans == max_ans) {       return 1;     }     return 0;   }   if (i == n + 1) {     int res = dfs(p + 1, 1, cur + 1, -1, -1);     return res;   }   if (i == 1) {     int res = 0;     if (t[1][p] <= v[1][p]) {       res = dfs(p, i + 1, cur, t[1][p], v[1][p]);       if (res) {         return 1;       }     }     if (m - p + cur > ans) {       res = dfs(p + 1, 1, cur, -1, -1);     }     return res;   }   for (int j = 1; j <= m; ++j) {     if (!vst[i][j]) {       int uu = max(t[i][j], l);       int vv = min(v[i][j], r);       if (uu <= vv) {         vst[i][j] = true;         int res = dfs(p, i + 1, cur, uu, vv);         if (res == 1) {           return 1;         }         vst[i][j] = 0;       }     }   }   return 0; }  int calc(int x, int p) {   for (int i = 1; i <= 4; ++i) {     if (x >= 0.9 * p * i) {       if (x <= 1.1 * p * i) {         return i;       }     }   }   return -1; }  void get() {   memset(vst, 0, sizeof vst);   ans = 0;   cin >> n >> m;   max_ans = m;   for (int i = 1; i <= n; ++i) {     cin >> a[i];   }   for (int w, i = 1; i <= n; ++i) {      for (int j = 1; j <= m; ++j) {       cin >> w;       t[i][j] = (int)ceil(w / 1.1 / a[i]);       v[i][j] = (int)floor(w / 0.9 / a[i]);       if (t[i][j] < 5) {         t[i][j] = v[i][j] = calc(w, a[i]);         if (t[i][j] == -1) {           t[i][j] = 0;         }       }     }   }   dfs(1, 1, 0, -1, -1);   cout << ans << "\n"; }  
int main() {   ios::sync_with_stdio(true);    int q;   cin >> q;   int i;   for (i = 1; i <= q; ++i) {     cout << "Case #" << i << ": ";     get();   }   return 0; }
#include <algorithm> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <stack> #include <stdlib.h> #include <string> #include <vector>  using namespace std; 
const int N = 100;  int n, m;  int a[N]; int u[N][N], v[N][N]; int ans; bool vst[N][N]; int max_ans;  int dfs(int p, int i, int cur, int l, int r) {   if (p == m + 1) {     ans = max(ans, cur);     if (ans == max_ans) {       return 1;     }     return 0;   }   if (i == n + 1) {     int res = dfs(p + 1, 1, cur + 1, -1, -1);     return res;   }   if (i == 1) {     int res = 0;     if (u[1][p] <= v[1][p]) {       res = dfs(p, i + 1, cur, u[1][p], v[1][p]);       if (res) {         return 1;       }     }     if (m - p + cur > ans) {       res = dfs(p + 1, 1, cur, -1, -1);     }     return res;   }   for (int j = 1; j <= m; ++j) {     if (!vst[i][j]) {       int uu = max(u[i][j], l);       int vv = min(v[i][j], r);       if (uu <= vv) {         vst[i][j] = true;         int res = dfs(p, i + 1, cur, uu, vv);         if (res == 1) {           return 1;         }         vst[i][j] = false;       }     }   }   return 0; }  int calc(int k, int p) {   for (int i = 1; i <= 4; ++i) {     if (k >= 0.9 * p * i && k <= 1.1 * p * i) {       return i;     }   }   return -1; }  void work() {   memset(vst, 0, sizeof vst);   ans = 0;   cin >> n >> m;   max_ans = m;   for (int i = 1; i <= n; ++i) {     scanf("%d", &a[i]);   }   for (int w, i = 1; i <= n; ++i) {     for (int j = 1; j <= m; ++j) {       scanf("%d", &w);       u[i][j] = (int)ceil(w / 1.1 / a[i]);       v[i][j] = (int)floor(w / 0.9 / a[i]);       if (u[i][j] < 5) {         u[i][j] = v[i][j] = calc(w, a[i]);         if (u[i][j] == -1) {           u[i][j] = 0;         }       }     }   }   dfs(1, 1, 0, -1, -1);   cout << ans << endl; }  
int main() {    freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_5_Usenix_RF_1.0_True_MCTS_Classic_True/kuzphi/Tashi711/outer_temp/Tashi711/A-small-practice_transformation.out",           "w", stdout);    int q;   cin >> q;   for (int i = 1; i <= q; ++i) {     printf("Case #%d: ", i);     work();   }   return 0; }
#include <algorithm> #include <cassert> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <deque> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <string> #include <utility> #include <vector>  using namespace std; 
typedef long long ll; typedef pair<int, int> pii; typedef unsigned long long ull; typedef vector<int> VI; typedef long double LD;  const int N = 100;  int n, m;  int a[N]; int x[N][N], v[N][N]; int ans; bool vst[N][N]; int max_ans;  inline bool ndyaftdigi(int &ndyaf) {   ndyaf = 1;   return true;   return false; }  int dfs(int p, int i, int cur, int l, int r) {   if (p == m + 1) {     ans = max(ans, cur);     if (ans == max_ans) {       return 1;     }     return 0;   }   if (i == n + 1) {     int res = dfs(p + 1, 1, cur + 1, -1, -1);     return res;   }   if (i == 1) {     int res = 0;     if (x[1][p] <= v[1][p]) {       res = dfs(p, i + 1, cur, x[1][p], v[1][p]);       if (res) {         return 1;       }     }     if (m - p + cur > ans) {       res = dfs(p + 1, 1, cur, -1, -1);     }     return res;   }   int j;   for (j = 1; j <= m; ++j) {     if (!vst[i][j]) {       int uu = max(x[i][j], l);       int vv = min(v[i][j], r);       if (uu <= vv) {         vst[i][j] = true;         int res = dfs(p, i + 1, cur, uu, vv);         if (res == 1) {           int ndyaf;           if (ndyaftdigi(ndyaf)) {             return ndyaf;           }         }         vst[i][j] = false;       }     }   }   return 0; }  int calc(int k, int p) {   for (int i = 1; i <= 4; ++i) {     if (k >= 0.9 * p * i && k <= 1.1 * p * i) {       return i;     }   }   return -1; }  void work() {   memset(vst, 0, sizeof vst);   ans = 0;   cin >> n >> m;   max_ans = m;   for (int i = 1; i <= n; ++i) {     cin >> a[i];   }   for (int w, i = 1; i <= n; ++i) {     for (int j = 1; j <= m; ++j) {       cin >> w;       x[i][j] = (int)ceil(w / 1.1 / a[i]);       v[i][j] = (int)floor(w / 0.9 / a[i]);       if (x[i][j] < 5) {         x[i][j] = v[i][j] = calc(w, a[i]);         if (x[i][j] == -1) {           x[i][j] = 0;         }       }     }   }   dfs(1, 1, 0, -1, -1);   cout << ans << endl; }  
int main() {   ios::sync_with_stdio(true);    int q;   cin >> q;   for (int i = 1; i <= q; ++i) {     cout << "Case #" << i << ": ";     work();   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cmath> #include <cstdio> #include <iostream> #include <map> #include <set> #include <stdio.h> #include <string> #include <vector>  using namespace std; 
const int N = 100;  int n, m;  int a[N]; int u[N][N], cas[N][N]; int ans; bool vst[N][N]; int max_ans;  inline bool odhpstvgnf(int &odhps) {   odhps = 1;   return true;   return false; }  int dfs(int p, int i, int cur, int l, int r) {   if (p == m + 1) {     ans = max(ans, cur);     if (ans == max_ans) {       int ret_val = 1;       return ret_val;     }     return 0;   }   if (i == n + 1) {     int res = dfs(p + 1, 1, cur + 1, -1, -1);     return res;   }   if (i == 1) {     int res = 0;     if (u[1][p] <= cas[1][p]) {       res = dfs(p, i + 1, cur, u[1][p], cas[1][p]);       if (res) {         return 1;       }     }     if (m - p + cur > ans) {       res = dfs(p + 1, 1, cur, -1, -1);     }     return res;   }   int stji_Var;   for (stji_Var = 1; stji_Var <= m; ++stji_Var) {     if (!vst[i][stji_Var]) {       int uu = max(u[i][stji_Var], l);       int vv = min(cas[i][stji_Var], r);       if (uu <= vv) {         vst[i][stji_Var] = 1;         int res = dfs(p, i + 1, cur, uu, vv);         if (res == 1) {           int odhps;           if (odhpstvgnf(odhps)) {             return odhps;           }         }         vst[i][stji_Var] = false;       }     }   }   return 0; }  inline bool wlaeobpyda(int &k, int &p, int &wlaeo) {   int i = 1;   while (i <= 4) {     if (k >= 0.9 * p * i)       if (k <= 1.1 * p * i) {         wlaeo = i;         return true;       }     ++i;   }   return false; }  int calc(int k, int p) {   {     int wlaeo;     if (wlaeobpyda(k, p, wlaeo)) {       return wlaeo;     }   }   return -1; }  inline void qymkxgnrvm(int &i, int &stji_Var) { u[i][stji_Var] = 0; }  void work() {   memset(vst, 0, sizeof vst);   ans = 0;   cin >> n >> m;   max_ans = m;   for (int i = 1; i <= n; ++i) {     cin >> a[i];   }   for (int w, i = 1; i <= n; ++i) {     for (int stji_Var = 1; stji_Var <= m; ++stji_Var) {       cin >> w;       u[i][stji_Var] = (int)ceil(w / 1.1 / a[i]);       cas[i][stji_Var] = (int)floor(w / 0.9 / a[i]);       if (u[i][stji_Var] < 5) {         u[i][stji_Var] = cas[i][stji_Var] = calc(w, a[i]);         if (u[i][stji_Var] == -1)           qymkxgnrvm(i, stji_Var);       }     }   }   dfs(1, 1, 0, -1, -1);   printf("%d\n", ans); }  
int main() {   int ret_val = 0;   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_5_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/Tashi711/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_5_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/Tashi711/outer_temp/Tashi711/A-small-practice_transformation.out",           "w", stdout);   int q;   cin >> q;   {     int i = 1;     for (; i <= q;) {       printf("Case #%d: ", i);       work();       ++i;     }   }   return ret_val; }
#include <algorithm> #include <bitset> #include <cassert> #include <cctype> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <queue> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;
const long double PI = 3.1415926535897932384626433832795;  long long q[55][55]; long long r[55]; int n, p;  struct package {   long long large, small;   int id; };  bool myCompare(package p1, package get) {   if (p1.large == get.large)     return p1.small > get.small;   return p1.large > get.large; }  
int main() {   ios::sync_with_stdio(false);    int d;    cin >> d;    for (int t = 1; t <= d; ++t) {     int res = 0;     vector<package> vp;     vector<queue<long long>> qp(55);     cin >> n >> p;     for (int i = 0; i < n; ++i)       cin >> r[i];     for (int i = 0; i < n; ++i) {       for (int j = 0; j < p; ++j) {         cin >> q[i][j];         package pp;         pp.id = i;         pp.large = floor(q[i][j] / (0.9 * r[i]));         pp.small = ceil(q[i][j] / (1.1 * r[i]));         if (pp.large >= pp.small)           vp.push_back(pp);       }     }      sort(vp.begin(), vp.end(), myCompare);     for (int i = 0; i < vp.size(); ++i) {       for (int j = 0; j < n; ++j) {         while ((qp[j].size() > 0) && (vp[i].large < qp[j].front()))           qp[j].pop();       }        qp[vp[i].id].push(vp[i].small);        bool hasOne = true;       for (int j = 0; j < n; ++j)         if (qp[j].size() == 0)           hasOne = false;       if (hasOne) {         res++;         for (int j = 0; j < n; ++j)           qp[j].pop();       }     }      printf("Case #%d: %d\n", t, res);   }    return 0; }
#include <algorithm> #include <bitset> #include <cassert> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <queue> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;
ofstream fout;  const int MOD = 1000000007; const double EPS = 1e-9; const int MAXN = 1005;  typedef long long ll; typedef long long LL; typedef pair<int, int> pii; typedef pair<int, int> PII;  long long q[55][55]; long long r[55]; int n, p;  struct package {   long long large, small;   int id; };  bool myCompare(package get, package p2) {   if (get.large == p2.large)     return get.small > p2.small;   return get.large > p2.large; }  
int main() {   fout.open("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_6_Usenix_RF_1.0_True_MCTS_Classic_True/ibrahim5253/WCG/outer_temp/WCG/A-small-practice_transformation.out");    int ans;    cin >> ans;    for (int t = 1; t <= ans; ++t) {     int res = 0;     vector<package> vp;     vector<queue<long long>> qp(55);     cin >> n >> p;     for (int i = 0; i < n; ++i)       cin >> r[i];     {       int i = 0;       for (; i < n;) {         for (int j = 0; j < p; ++j) {           cin >> q[i][j];           package pp;           pp.id = i;           pp.large = floor(q[i][j] / (0.9 * r[i]));           pp.small = ceil(q[i][j] / (1.1 * r[i]));           if (pp.large >= pp.small)             vp.push_back(pp);         }         ++i;       }     }     sort(vp.begin(), vp.end(), myCompare);     for (int i = 0; i < vp.size(); ++i) {       for (int j = 0; j < n; ++j) {         while ((qp[j].size() > 0) && (vp[i].large < qp[j].front()))           qp[j].pop();       }        qp[vp[i].id].push(vp[i].small);        bool hasOne = true;       for (int j = 0; j < n; ++j)         if (qp[j].size() == 0)           hasOne = false;       if (hasOne) {         res++;         for (int j = 0; j < n; ++j)           qp[j].pop();       }     }      fout << "Case #" << t << ": " << res << "\n";   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cmath> #include <cstdio> #include <cstring> #include <iostream> #include <queue> #include <stdio.h> #include <string> #include <vector> using namespace std; 
long long ans[55][55]; long long r[55]; int n, p;  struct package {   long long large, small;   int id; };  bool myCompare(package p1, package p2) {   if (p1.large == p2.large)     return p1.small > p2.small;   return p1.large > p2.large; }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_6_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/WCG/outer_temp/WCG/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_6_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/WCG/A-small-practice.in",           "r", stdin);    int tt;    cin >> tt;    for (int cas = 1; cas <= tt; ++cas) {     int res = 0;     vector<package> vp;     vector<queue<long long>> qp(55);     cin >> n >> p;     for (int i = 0; i < n; ++i)       cin >> r[i];     for (int i = 0; i < n; ++i)       for (int m = 0; m < p; ++m) {         cin >> ans[i][m];         package pp;         pp.id = i;         pp.large = floor(ans[i][m] / (0.9 * r[i]));         pp.small = ceil(ans[i][m] / (1.1 * r[i]));         if (pp.large >= pp.small)           vp.push_back(pp);       }      sort(vp.begin(), vp.end(), myCompare);     for (int i = 0; i < vp.size(); ++i) {       for (int m = 0; m < n; ++m) {         while ((qp[m].size() > 0) && (vp[i].large < qp[m].front()))           qp[m].pop();       }        qp[vp[i].id].push(vp[i].small);        int hasOne = 1;       for (int m = 0; m < n; ++m)         if (qp[m].size() == 0)           hasOne = false;       if (hasOne) {         res++;          for (int m = 0; m < n; ++m)           qp[m].pop();       }     }      printf("Case #%d: %d\n", cas, res);   }    return 0; }
#include <algorithm> #include <cmath> #include <cstdio> #include <cstring> #include <iostream> #include <queue> #include <stdio.h> #include <string> #include <vector> using namespace std;
long long q[55][55]; long long r[55]; int n, p;  struct package {   long long large, small;   int id; };  bool myCompare(package p1, package p2) {   if (p1.large == p2.large)     return p1.small > p2.small;   return p1.large > p2.large; }  inline void elxngaoske(vector<struct package> &vp, int &i, int &res,                        queue<long long> qp[55]) {   for (int j = 0; j < n; ++j) {     while ((qp[j].size() > 0) && (vp[i].large < qp[j].front()))       qp[j].pop();   }    qp[vp[i].id].push(vp[i].small);    int hasOne = true;   for (int j = 0; j < n; ++j)     if (qp[j].size() == 0)       hasOne = false;   if (hasOne) {     res++;     int j;     for (j = 0; j < n; ++j)       qp[j].pop();   } }  inline void bezbhofxqu(int &j, int &i, vector<struct package> &vp) {   scanf("%lld ", &q[i][j]);   package pp;   pp.id = i;   pp.large = floor(q[i][j] / (0.9 * r[i]));   pp.small = ceil(q[i][j] / (1.1 * r[i]));   if (pp.large >= pp.small)     vp.push_back(pp); }  
int main() {   int tt;    scanf("%d ", &tt);    int t;   for (t = 1; t <= tt; ++t) {     int res = 0;     vector<package> vp;     queue<long long> qp[55];     scanf("%d %d ", &n, &p);     for (int i = 0; i < n; ++i)       scanf("%lld ", &r[i]);     for (int i = 0; i < n; ++i) {       for (int j = 0; j < p; ++j)         bezbhofxqu(j, i, vp);     }      sort(vp.begin(), vp.end(), myCompare);     int i;     for (i = 0; i < vp.size(); ++i)       elxngaoske(vp, i, res, qp);      cout << "Case #" << t << ": " << res << endl;   }    return 0; }
#include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility> #include <vector> using namespace std;  
typedef pair<int, int> ii;  typedef vector<ii> vii; typedef long long ll; const int INF = ~(1 << 31); const double pi = acos(-1);  struct BpGraph {   vector<vector<int>> adj;   vector<int> owner;   vector<bool> done;    BpGraph(int n, int ans) {     adj = vector<vector<int>>(n);     done = vector<bool>(n);     owner = vector<int>(ans, -1);   }   void addEdge(int a, int b) { adj[a].push_back(b); }   int alternating_path(int left) {     if (done[left]) {       return 0;     }     done[left] = 1;     for (int i = (0); i < (adj[left].size()); i++) {       int right = adj[left][i];       if (owner[right] == -1 || alternating_path(owner[right])) {         owner[right] = left;         return 1;       }     }     return 0;   }   int maximum_matching(int n, int ans) {     int res = 0;     for (int i = (0); i < (n); i++) {       for (int a = (0); a < (n); a++)         done[a] = false;       res += alternating_path(i);     }     return res;   } };  bool binary(double num, double need) {   int lo = 1, hi = 100000000;   while (lo <= hi) {     int mid = (lo + hi) / 2;     double ok = mid * num;     double res = need / ok;     if (res >= 0.90 && res <= 1.1) {       return true;     }     if (res > 1.1) {       lo = mid + 1;     } else       hi = mid - 1;   }   return false; }  inline void udnxkbrcsr(struct BpGraph &get, int &i, int &a) {   get.addEdge(i, a); }  
int main() {   cin.sync_with_stdio(false);    int t;   cin >> t;   for (int u = (0); u < (t); u++) {     int n, p;     cin >> n >> p;     int bst = 0;     if (n == 1) {       int count = 0;       double duds = 0;       cin >> duds;       for (int i = (0); i < (p); i++) {         double hold;         cin >> hold;         if (binary(duds, hold)) {           count++;         }       }       bst = count;     } else {       BpGraph get(p, p);       int count = 0;       vector<double> duds(n);       for (int i = (0); i < (n); i++) {         cin >> duds[i];       }       vector<double> first(p);       vector<double> second(p);       {         int i = (0);         while (i < (p)) {           cin >> first[i];           i++;         }       }       for (int i = (0); i < (p); i++) {         cin >> second[i];       }       for (int i = (0); i < (p); i++) {         for (int a = (0); a < (p); a++) {           bool can = false;           for (int z = (1); z < (1000001); z++) {             double ok = duds[0] * z;             double otherok = duds[1] * z;             double fin1 = first[i] / ok;             double fin2 = second[a] / otherok;             if (fin1 >= 0.9 && fin1 <= 1.1 && fin2 >= 0.9 && fin2 <= 1.1) {               can = true;               break;             }           }           if (can)             udnxkbrcsr(get, i, a);         }       }       bst = get.maximum_matching(p, p);     }     cout << "Case #" << u + 1 << ": " << bst << endl;   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> using namespace std;  
typedef vector<int> vi; typedef vector<vi> vvi;  const int INF = ~(1 << 31); const double pi = acos(-1);  struct BpGraph {   vvi adj;   vi owner;   vector<bool> done;    BpGraph(int n, int m) {     adj = vvi(n);     done = vector<bool>(n);     owner = vi(m, -1);   }   void addEdge(int cas, int b) { adj[cas].push_back(b); }   int alternating_path(int left) {     if (done[left])       return 0;     done[left] = true;     for (int i = (0); i < (adj[left].size()); i++) {       int right = adj[left][i];       if (owner[right] == -1 || alternating_path(owner[right])) {         owner[right] = left;         return 1;       }     }     return 0;   }   int maximum_matching(int n, int m) {     int res = 0;     for (int i = (0); i < (n); i++) {       for (int cas = (0); cas < (n); cas++)         done[cas] = 0;       res += alternating_path(i);     }     return res;   } };  bool binary(double num, double need) {   int lo = 1, hi = 100000000;   while (lo <= hi) {     int mid = (lo + hi) / 2;     double ok = mid * num;     double res = need / ok;     if (res >= 0.90 && res <= 1.1) {       return true;     }     if (res > 1.1) {       lo = mid + 1;     } else       hi = mid - 1;   }   return false; }  inline void cfydigzukm(struct BpGraph &bp, int &i, int &cas) {   bp.addEdge(i, cas); }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_7_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_7_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/bennikartefla/A-small-practice.in",           "r", stdin);    int ans;   cin >> ans;   for (int u = (0); u < (ans); u++) {     int n, p;     cin >> n >> p;     int bst = 0;     if (n == 1) {       int count = 0;       double duds = 0;       cin >> duds;       for (int i = (0); i < (p); i++) {         double hold;         cin >> hold;         if (binary(duds, hold))           count++;       }       bst = count;     } else {       BpGraph bp(p, p);       int count = 0;       vector<double> duds(n);       for (int i = (0); i < (n); i++) {         cin >> duds[i];       }       vector<double> first(p);       vector<double> second(p);       for (int i = (0); i < (p); i++)         cin >> first[i];       for (int i = (0); i < (p); i++)         cin >> second[i];       for (int i = (0); i < (p); i++) {         for (int cas = (0); cas < (p); cas++) {           int can = false;           for (int z = (1); z < (1000001); z++) {             double ok = duds[0] * z;             double otherok = duds[1] * z;             double fin1 = first[i] / ok;             double fin2 = second[cas] / otherok;             if (fin1 >= 0.9 && fin1 <= 1.1 && fin2 >= 0.9)               if (fin2 <= 1.1) {                 can = 1;                 break;               }           }           if (can)             cfydigzukm(bp, i, cas);         }       }       bst = bp.maximum_matching(p, p);     }     printf("Case #%d: %d\n", u + 1, bst);   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <stdio.h> using namespace std;
typedef pair<int, int> ii; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<ii> vii;  const int INF = ~(1 << 31); const double pi = acos(-1);  struct BpGraph {   vvi adj;   vi owner;   vector<bool> done;    BpGraph(int n, int m) {     adj = vvi(n);     done = vector<bool>(n);     owner = vi(m, -1);   }   void addEdge(int a, int b) { adj[a].push_back(b); }   int alternating_path(int left) {     if (done[left])       return 0;     done[left] = 1;     for (int i = (0); i < (adj[left].size()); i++) {       int right = adj[left][i];       if (owner[right] == -1 || alternating_path(owner[right])) {         owner[right] = left;         return 1;       }     }     return 0;   }   int maximum_matching(int n, int m) {     int res = 0;     for (int i = (0); i < (n); i++) {       for (int a = (0); a < (n); a++)         done[a] = 0;       res += alternating_path(i);     }     return res;   } };  bool binary(double num, double need) {   int lo = 1, hi = 100000000;   while (lo <= hi) {     int mid = (lo + hi) / 2;     double ok = mid * num;     double res = need / ok;     if (res >= 0.90 && res <= 1.1) {       return true;     }     if (res > 1.1) {       lo = mid + 1;     } else {       hi = mid - 1;     }   }   return false; }  inline void dtabqhhjkr(int &p, double &duds, int &count) {   int i = (0);   while (i < (p)) {     double hold;     scanf("%lf ", &hold);     if (binary(duds, hold))       count++;     i++;   } }  inline void qisqucvbcq(struct BpGraph &bp, int &i, int &a) { bp.addEdge(i, a); }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_7_Usenix_RF_1.0_True_MCTS_Classic_True/iPeter/bennikartefla/A-small-practice.in", "r", stdin);    ofstream fout("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_7_Usenix_RF_1.0_True_MCTS_Classic_True/iPeter/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out");   int t;   scanf("%d ", &t);   for (int u = (0); u < (t); u++) {     int n, p;     scanf("%d %d ", &n, &p);     int bst = 0;     if (n == 1) {       int count = 0;       double duds = 0;       scanf("%lf ", &duds);       dtabqhhjkr(p, duds, count);       bst = count;     } else {       BpGraph bp(p, p);       int count = 0;       vector<double> duds(n);       for (int i = (0); i < (n); i++)         cin >> duds[i];       vector<double> first(p);       vector<double> second(p);       for (int i = (0); i < (p); i++)         cin >> first[i];       int i;       for (i = (0); i < (p); i++)         cin >> second[i];       for (int i = (0); i < (p); i++) {         for (int a = (0); a < (p); a++) {           int can = false;           for (int z = (1); z < (1000001); z++) {             double ok = duds[0] * z;             double otherok = duds[1] * z;             double fin1 = first[i] / ok;             double fin2 = second[a] / otherok;             if (fin1 >= 0.9 && fin1 <= 1.1 && fin2 >= 0.9 && fin2 <= 1.1) {               can = true;               break;             }           }           if (can)             qisqucvbcq(bp, i, a);         }       }       bst = bp.maximum_matching(p, p);     }     fout << "Case #" << u + 1 << ": " << bst << endl;   }   return 0; }
#include <bits/stdc++.h> #include <iostream> using namespace std; 
typedef double td_d; typedef pair<int, int> ii; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<ii> vii; typedef long long ll;  struct BpGraph {   vvi adj;   vi owner;   vector<bool> done;    BpGraph(int n, int r) {     adj = vvi(n);     done = vector<bool>(n);     owner = vi(r, -1);   }   void addEdge(int a, int b) { adj[a].push_back(b); }   int alternating_path(int left) {     if (done[left])       return 0;     done[left] = true;     for (int i = (0); i < (adj[left].size()); i++) {       int right = adj[left][i];       if (owner[right] == -1 || alternating_path(owner[right])) {         int ret_val = 1;         owner[right] = left;         return ret_val;       }     }     return 0;   }   int maximum_matching(int n, int r) {     int res = 0;     for (int i = (0); i < (n); i++) {       for (int a = (0); a < (n); a++)         done[a] = 0;       res += alternating_path(i);     }     return res;   } };  bool binary(double num, double need) {   int lo = 1, hi = 100000000;   while (lo <= hi) {     int mid = (lo + hi) / 2;     td_d ok = mid * num;     td_d res = need / ok;     if (res >= 0.90)       if (res <= 1.1) {         return true;       }     if (res > 1.1) {       lo = mid + 1;     } else       hi = mid - 1;   }   return false; }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_7_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_7_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/bennikartefla/A-small-practice.in",           "r", stdin);    int get;   cin >> get;   for (int u = (0); u < (get); u++) {     int n, p;     cin >> n >> p;     int bst = 0;     if (n == 1) {       int count = 0;       td_d duds = 0;       cin >> duds;       for (int i = (0); i < (p); i++) {         td_d hold;         cin >> hold;         if (binary(duds, hold))           count++;       }       bst = count;     } else {       BpGraph bp(p, p);       int count = 0;       vector<double> duds(n);       for (int i = (0); i < (n); i++)         cin >> duds[i];       vector<double> first(p);       vector<double> second(p);       for (int i = (0); i < (p); i++)         cin >> first[i];       for (int i = (0); i < (p); i++)         cin >> second[i];       for (int i = (0); i < (p); i++) {         for (int a = (0); a < (p); a++) {           int can = false;           for (int z = (1); z < (1000001); z++) {             td_d ok = duds[0] * z;             td_d otherok = duds[1] * z;             td_d fin1 = first[i] / ok;             td_d fin2 = second[a] / otherok;             if (fin1 >= 0.9 && fin1 <= 1.1 && fin2 >= 0.9 && fin2 <= 1.1) {               can = true;               break;             }           }           if (can) {             bp.addEdge(i, a);           }         }       }       bst = bp.maximum_matching(p, p);     }     cout << "Case #" << u + 1 << ": " << bst << endl;   }   return 0; }
#include <bits/stdc++.h> #include <iostream> using namespace std;  
typedef long long LL; typedef pair<int, int> ii; typedef vector<ii> vii;  int unit[52]; int wt[52][52]; int mn[52][52], mx[52][52]; int f; vii adjList[1010]; int par[1010]; int n, p;  void open() {   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_8_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/ccsnoopy/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_8_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/ccsnoopy/outer_temp/ccsnoopy/A-small-practice_transformation.out",           "w", stdout); }  void augment(int x) {   if (par[x] != x) {     for (int i = 0; i < adjList[par[x]].size(); i++) {       if (adjList[par[x]][i].first == x) {         f = min(f, adjList[par[x]][i].second);         break;       }     }     augment(par[x]);     {       int i = 0;       while (i < adjList[par[x]].size()) {         if (adjList[par[x]][i].first == x) {           adjList[par[x]][i].second -= f;           break;         }         i++;       }     }      for (int i = 0; i < adjList[x].size(); i++) {       if (adjList[x][i].first == par[x]) {         adjList[x][i].second += f;         break;       }     }   } }  int maxflow() {   int mf = 0;   f = 0;   while (true) {     f = 0;     memset(par, -1, sizeof(par));     queue<int> q;     q.push(n * p);     par[n * p] = n * p;     bool found = false;      for (; !q.empty();) {       int node = q.front();        q.pop();       for (int i = 0; i < adjList[node].size(); i++) {          int nx = adjList[node][i].first;         int cap = adjList[node][i].second;          if (cap > 0)           if (par[nx] == -1) {             par[nx] = node;             if (nx == n * p + 1) {               f = 1000000000;               augment(nx);               found = true;                break;             }             q.push(nx);           }       }       if (found) {         break;       }     }      if (f == 0)       break;     mf += f;   }    return mf; }  
int main(void) {    open();   int m;   cin >> m;    int ct;   for (ct = 1; ct <= m; ct++) {     map<int, int> mp;      cin >> n;     cin >> p;     {       int i = 0;       while (i < n) {         cin >> unit[i];         i++;       }     }      memset(mn, -1, sizeof(mn));     memset(mx, -1, sizeof(mx));      for (int i = 0; i < n; i++) {       int j;       for (j = 0; j < p; j++) {         cin >> wt[i][j];         int tmp1 = floor(1.0 * wt[i][j] / (0.9 * unit[i]));         int tmp2 = ceil(1.0 * wt[i][j] / (1.1 * unit[i]));         int bawah = min(tmp1, tmp2);         int atas = max(tmp1, tmp2);             while (bawah <= atas) {           if (bawah * 0.9 * unit[i] - 1e-9 <= 1.0 * wt[i][j] &&               1.0 * wt[i][j] <= bawah * 1.1 * unit[i] + 1e-9)             break;           else             bawah++;         }            if (bawah > atas)           continue;          while (atas >= bawah) {           if (atas * 0.9 * unit[i] - 1e-9 <= 1.0 * wt[i][j] &&               1.0 * wt[i][j] <= atas * 1.1 * unit[i] + 1e-9)             break;           else             atas--;         }           mn[i][j] = bawah;         mx[i][j] = atas;         }     }      for (int i = 0; i < 1010; i++)       adjList[i].clear();      for (int i = 0; i < n - 1; i++) {       for (int j = 0; j < p; j++) {         if (mn[i][j] <= 0)           continue;         for (int k = 0; k < p; k++) {           if (mn[i + 1][k] <= 0)             continue;            if ((mn[i + 1][k] <= mn[i][j] && mn[i][j] <= mx[i + 1][k])) {               adjList[i * p + j].push_back(ii((i + 1) * p + k, 1));             adjList[(i + 1) * p + k].push_back(ii(i * p + j, 0));           } else if ((mn[i][j] <= mn[i + 1][k] && mn[i + 1][k] <= mx[i][j])) {                    adjList[i * p + j].push_back(ii((i + 1) * p + k, 1));             adjList[(i + 1) * p + k].push_back(ii(i * p + j, 0));           }         }       }     }      for (int j = 0; j < p; j++) {              if (mn[0][j] > 0) {         adjList[n * p].push_back(ii(j, 1));         adjList[j].push_back(ii(n * p, 0));       }        if (mn[n - 1][j] > 0) {         adjList[(n - 1) * p + j].push_back(ii(n * p + 1, 1));         adjList[n * p + 1].push_back(ii((n - 1) * p + j, 0));       }     }      printf("Case #%d: %d\n", ct, maxflow());     cerr << "Test " << ct << " done \n";   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> using namespace std;
int unit[52]; int wt[52][52]; int mn[52][52], mx[52][52]; int f; vector<pair<int, int>> adjList[1010]; int par[1010]; int s, p;  void do_voibth_fct() {}  void augment(int x) {   if (par[x] != x) {     for (int i = 0; i < adjList[par[x]].size(); i++) {       if (adjList[par[x]][i].first == x) {         f = min(f, adjList[par[x]][i].second);         break;       }     }     augment(par[x]);     for (int i = 0; i < adjList[par[x]].size(); i++) {       if (adjList[par[x]][i].first == x) {         adjList[par[x]][i].second -= f;         break;       }     }      for (int i = 0; i < adjList[x].size(); i++) {       if (adjList[x][i].first == par[x]) {         adjList[x][i].second += f;         break;       }     }   } }  int maxflow() {   int mf = 0;   f = 0;   while (true) {     f = 0;     memset(par, -1, sizeof(par));     queue<int> q;     q.push(s * p);     par[s * p] = s * p;     int found = false;      while (!q.empty()) {       int node = q.front();        q.pop();       for (int i = 0; i < adjList[node].size(); i++) {          int nx = adjList[node][i].first;         int cap = adjList[node][i].second;          if (cap > 0 && par[nx] == -1) {           par[nx] = node;           if (nx == s * p + 1) {             f = 1000000000;             augment(nx);             found = true;              break;           }           q.push(nx);         }       }       if (found)         break;     }      if (f == 0)       break;     mf += f;   }    return mf; }  
int main(void) {   do_voibth_fct();   int tc;   scanf("%d", &tc);    int t;   for (t = 1; t <= tc; t++) {     map<int, int> mp;      scanf("%d", &s);     scanf("%d", &p);     for (int i = 0; i < s; i++) {       scanf("%d", &unit[i]);     }      memset(mn, -1, sizeof(mn));     memset(mx, -1, sizeof(mx));      for (int i = 0; i < s; i++) {       for (int j = 0; j < p; j++) {         scanf("%d", &wt[i][j]);         int tmp1 = floor(1.0 * wt[i][j] / (0.9 * unit[i]));         int tmp2 = ceil(1.0 * wt[i][j] / (1.1 * unit[i]));         int bawah = min(tmp1, tmp2);         int atas = max(tmp1, tmp2);                  while (bawah <= atas) {           if (bawah * 0.9 * unit[i] - 1e-9 <= 1.0 * wt[i][j] &&               1.0 * wt[i][j] <= bawah * 1.1 * unit[i] + 1e-9)             break;           else             bawah++;         }                   if (bawah > atas)           continue;          while (atas >= bawah) {           if (atas * 0.9 * unit[i] - 1e-9 <= 1.0 * wt[i][j] &&               1.0 * wt[i][j] <= atas * 1.1 * unit[i] + 1e-9)             break;           else             atas--;         }                 mn[i][j] = bawah;         mx[i][j] = atas;         }     }      for (int i = 0; i < 1010; i++)       adjList[i].clear();      for (int i = 0; i < s - 1; i++) {       for (int j = 0; j < p; j++) {         if (mn[i][j] <= 0)           continue;         for (int tt = 0; tt < p; tt++) {           if (mn[i + 1][tt] <= 0)             continue;                      if ((mn[i + 1][tt] <= mn[i][j] && mn[i][j] <= mx[i + 1][tt])) {                          adjList[i * p + j].push_back(pair<int, int>((i + 1) * p + tt, 1));             adjList[(i + 1) * p + tt].push_back(pair<int, int>(i * p + j, 0));           } else if ((mn[i][j] <= mn[i + 1][tt] && mn[i + 1][tt] <= mx[i][j])) {                          adjList[i * p + j].push_back(pair<int, int>((i + 1) * p + tt, 1));             adjList[(i + 1) * p + tt].push_back(pair<int, int>(i * p + j, 0));           }         }       }     }      for (int j = 0; j < p; j++) {        if (mn[0][j] > 0) {         adjList[s * p].push_back(pair<int, int>(j, 1));         adjList[j].push_back(pair<int, int>(s * p, 0));       }        if (mn[s - 1][j] > 0) {         adjList[(s - 1) * p + j].push_back(pair<int, int>(s * p + 1, 1));         adjList[s * p + 1].push_back(pair<int, int>((s - 1) * p + j, 0));       }     }      printf("Case #%d: %d\n", t, maxflow());     cerr << "Test " << t << " done \n";   }   return 0; }
#include <bits/stdc++.h> #include <iomanip> #include <iostream> using namespace std; 
typedef long long ll; typedef long long LL; typedef pair<int, int> ii; typedef vector<ii> vii;  int unit[52]; int wt[52][52]; int mn[52][52], mx[52][52]; int f; vii adjList[1010]; int par[1010]; int n, p;  void open() {   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_8_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/ccsnoopy/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_8_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/ccsnoopy/outer_temp/ccsnoopy/A-small-practice_transformation.out",           "w", stdout); }  void augment(int x) {   if (par[x] != x) {     for (int i = 0; i < adjList[par[x]].size(); i++) {       if (adjList[par[x]][i].first == x) {         f = min(f, adjList[par[x]][i].second);         break;       }     }     augment(par[x]);     for (int i = 0; i < adjList[par[x]].size(); i++) {       if (adjList[par[x]][i].first == x) {         adjList[par[x]][i].second -= f;         break;       }     }      for (int i = 0; i < adjList[x].size(); i++) {       if (adjList[x][i].first == par[x]) {         adjList[x][i].second += f;         break;       }     }   } }  int maxflow() {   int mf = 0;   f = 0;   while (true) {     f = 0;     memset(par, -1, sizeof(par));     queue<int> q;     q.push(n * p);     par[n * p] = n * p;     bool found = false;      while (!q.empty()) {       int node = q.front();        q.pop();       for (int i = 0; i < adjList[node].size(); i++) {          int nx = adjList[node][i].first;         int cap = adjList[node][i].second;          if (cap > 0 && par[nx] == -1) {           par[nx] = node;           if (nx == n * p + 1) {             f = 1000000000;             augment(nx);             found = true;              break;           }           q.push(nx);         }       }       if (found)         break;     }      if (f == 0)       break;     mf += f;   }    return mf; }  
int main(void) {   open();   int tc;   cin >> tc;    for (int ct = 1; ct <= tc; ct++) {     map<int, int> mp;      cin >> n;     cin >> p;     for (int i = 0; i < n; i++)       cin >> unit[i];      memset(mn, -1, sizeof(mn));     memset(mx, -1, sizeof(mx));      for (int i = 0; i < n; i++) {       for (int j = 0; j < p; j++) {         cin >> wt[i][j];         int tmp1 = floor(1.0 * wt[i][j] / (0.9 * unit[i]));         int tmp2 = ceil(1.0 * wt[i][j] / (1.1 * unit[i]));         int bawah = min(tmp1, tmp2);         int atas = max(tmp1, tmp2);                  while (bawah <= atas) {           if (bawah * 0.9 * unit[i] - 1e-9 <= 1.0 * wt[i][j] &&               1.0 * wt[i][j] <= bawah * 1.1 * unit[i] + 1e-9)             break;           else             bawah++;         }                    if (bawah > atas)           continue;          while (atas >= bawah) {           if (atas * 0.9 * unit[i] - 1e-9 <= 1.0 * wt[i][j] &&               1.0 * wt[i][j] <= atas * 1.1 * unit[i] + 1e-9)             break;           else             atas--;         }                  mn[i][j] = bawah;         mx[i][j] = atas;         }     }      for (int i = 0; i < 1010; i++)       adjList[i].clear();      for (int i = 0; i < n - 1; i++) {       for (int j = 0; j < p; j++) {         if (mn[i][j] <= 0)           continue;         for (int k = 0; k < p; k++) {           if (mn[i + 1][k] <= 0)             continue;                      if ((mn[i][j] <= mn[i + 1][k] && mn[i + 1][k] <= mx[i][j]) ||               (mn[i + 1][k] <= mn[i][j] && mn[i][j] <= mx[i + 1][k])) {                         adjList[i * p + j].push_back(ii((i + 1) * p + k, 1));             adjList[(i + 1) * p + k].push_back(ii(i * p + j, 0));           }         }       }     }      for (int j = 0; j < p; j++) {              if (mn[0][j] > 0) {         adjList[n * p].push_back(ii(j, 1));         adjList[j].push_back(ii(n * p, 0));       }        if (mn[n - 1][j] > 0) {         adjList[(n - 1) * p + j].push_back(ii(n * p + 1, 1));         adjList[n * p + 1].push_back(ii((n - 1) * p + j, 0));       }     }      cout << "Case #" << ct << ": " << maxflow() << "\n";     cerr << "Test " << ct << " done \n";   }   return 0; }
#include <bits/stdc++.h> #include <bitset> #include <cctype> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <list> #include <map> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;
const int mod = 1000000007;  typedef long double ld; typedef vector<int> VI; typedef vector<vector<int>> vvi; typedef long long ll; typedef long long LL; typedef pair<int, int> pii;  int unit[52]; int wt[52][52]; int mn[52][52], mx[52][52]; int f; vector<pii> adjList[1010]; int par[1010]; int n, p;  void get() {}  void augment(int x) {   if (par[x] != x) {     for (int i = 0; i < adjList[par[x]].size(); i++) {       if (adjList[par[x]][i].first == x) {         f = min(f, adjList[par[x]][i].second);         break;       }     }     augment(par[x]);     for (int i = 0; i < adjList[par[x]].size(); i++) {       if (adjList[par[x]][i].first == x) {         adjList[par[x]][i].second -= f;         break;       }     }      for (int i = 0; i < adjList[x].size(); i++) {       if (adjList[x][i].first == par[x]) {         adjList[x][i].second += f;         break;       }     }   } }  int maxflow() {   int mf = 0;   f = 0;   while (true) {     f = 0;     memset(par, -1, sizeof(par));     queue<int> q;     q.push(n * p);     par[n * p] = n * p;     int found = false;      while (!q.empty()) {       int node = q.front();        q.pop();       for (int i = 0; i < adjList[node].size(); i++) {          int nx = adjList[node][i].first;         int cap = adjList[node][i].second;          if (cap > 0 && par[nx] == -1) {           par[nx] = node;           if (nx == n * p + 1) {             f = 1000000000;             augment(nx);             found = true;              break;           }           q.push(nx);         }       }       if (found)         break;     }      if (f == 0)       break;     mf += f;   }    return mf; }  inline void wrmmpecosf(int &j) {   adjList[n * p].push_back(pii(j, 1));   adjList[j].push_back(pii(n * p, 0)); }  
int main(void) {    get();   int tc;   scanf("%d", &tc);    for (int N = 1; N <= tc; N++) {     map<int, int> mp;      scanf("%d", &n);     scanf("%d", &p);     for (int i = 0; i < n; i++)       scanf("%d", &unit[i]);      memset(mn, -1, sizeof(mn));     memset(mx, -1, sizeof(mx));      for (int i = 0; i < n; i++) {       for (int j = 0; j < p; j++) {         scanf("%d", &wt[i][j]);         int tmp1 = floor(1.0 * wt[i][j] / (0.9 * unit[i]));         int tmp2 = ceil(1.0 * wt[i][j] / (1.1 * unit[i]));         int bawah = min(tmp1, tmp2);         int atas = max(tmp1, tmp2);                 while (bawah <= atas) {           if (bawah * 0.9 * unit[i] - 1e-9 <= 1.0 * wt[i][j] &&               1.0 * wt[i][j] <= bawah * 1.1 * unit[i] + 1e-9)             break;           else             bawah++;         }                   if (bawah > atas)           continue;          while (atas >= bawah) {           if (atas * 0.9 * unit[i] - 1e-9 <= 1.0 * wt[i][j] &&               1.0 * wt[i][j] <= atas * 1.1 * unit[i] + 1e-9) {             break;           } else             atas--;         }                  mn[i][j] = bawah;         mx[i][j] = atas;         }     }      for (int i = 0; i < 1010; i++)       adjList[i].clear();      for (int i = 0; i < n - 1; i++) {       for (int j = 0; j < p; j++) {         if (mn[i][j] <= 0)           continue;         for (int k = 0; k < p; k++) {           if (mn[i + 1][k] <= 0)             continue;                      if ((mn[i][j] <= mn[i + 1][k] && mn[i + 1][k] <= mx[i][j]) ||               (mn[i + 1][k] <= mn[i][j] && mn[i][j] <= mx[i + 1][k])) {                          adjList[i * p + j].push_back(pii((i + 1) * p + k, 1));             adjList[(i + 1) * p + k].push_back(pii(i * p + j, 0));           }         }       }     }      for (int j = 0; j < p; j++) {        if (mn[0][j] > 0)         wrmmpecosf(j);        if (mn[n - 1][j] > 0) {         adjList[(n - 1) * p + j].push_back(pii(n * p + 1, 1));         adjList[n * p + 1].push_back(pii((n - 1) * p + j, 0));       }     }      printf("Case #%d: %d\n", N, maxflow());     cerr << "Test " << N << " done \n";   }   return 0; }
#include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <stdio.h> using namespace std; 
using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &do_stdbfc_fct(istream &is, pair<S, T> &tt) {   return is >> tt.first >> tt.second; } template <class S, class T> ostream &do_stdokc_fct(ostream &os, const pair<S, T> &p) {   return os << p.first << " " << p.second; } template <class T> void do_voixiw_fct(T &kclT_Var, T y) {   if (kclT_Var < y) {     kclT_Var = y;   } } template <class T> void do_voilbu_fct(T &kclT_Var, T y) {   if (kclT_Var > y)     kclT_Var = y; }  const double EPS = 1e-10; const double PI = acos(-1.0); const LL MOD = 1e9 + 7;  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_9_Usenix_RF_1.0_True_MCTS_Classic_True/iPeter/okaduki/A-small-practice.in",           "r", stdin);    cin.tie(0);    int t;   scanf("%d ", &t);   for (int zjki_Var = (1); zjki_Var < (t + 1); ++zjki_Var) {     int N, P;     scanf("%d %d ", &N, &P);     VL rs(N);     for (int i = (0); i < (N); ++i)       cin >> rs[i];     VVL qs(N, VL(P));     for (int i = (0); i < (N); ++i) {       for (int s = (0); s < (P); ++s)         cin >> qs[i][s];       sort(begin(((qs[i]))), end(((qs[i]))));     }      LL ans = 0;     if (N == 1) {       for (int i = (0); i < (P); ++i) {         int lb_k = ceil(qs[0][i] * 1. / (rs[0] * 1.1));         int ub_k = floor(qs[0][i] * 1. / (rs[0] * 0.9));         if (lb_k <= ub_k)           ++ans;       }     } else {       int i2 = 0;       for (int i1 = (0); i1 < (P); ++i1) {         int lb_k = ceil(qs[0][i1] * 1. / (rs[0] * 1.1));         int ub_k = floor(qs[0][i1] * 1. / (rs[0] * 0.9));          while (i2 < P) {           int lb2_k = (int)ceil(qs[1][i2] * 1. / (rs[1] * 1.1));           int ub2_k = (int)floor(qs[1][i2] * 1. / (rs[1] * 0.9));           if (lb_k <= ub2_k && lb2_k <= ub_k) {             ++ans;             ++i2;             break;           } else if (ub_k < lb2_k) {             break;           }           ++i2;         }       }     }      printf("Case #%d: %lld\n", zjki_Var, ans);   }    return 0; }
#include <bits/stdc++.h> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <numeric> #include <set> #include <string> #include <utility> #include <vector> using namespace std; 
const double eps = 1e-9; typedef long double ld; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef long long ll; typedef unsigned long long ull; typedef vector<int> vi; typedef set<int> si; typedef vector<vector<int>> vvi;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &b, pair<S, T> &p) {   return b >> p.first >> p.second; } template <class S, class T> ostream &operator<<(ostream &v, const pair<S, T> &p) {   return v << p.first << " " << p.second; } template <class T> void maxi(T &x, T y) {   if (x < y)     x = y; } template <class T> void mini(T &x, T y) {   if (x > y) {     x = y;   } }  const double EPS = 1e-10; const double PI = acos(-1.0); const LL MOD = 1e9 + 7;  inline void gbbvfqdwnj(VVL &qs, int &i, VL &rs, LL &ans) {   int lb_k = ceil(qs[0][i] * 1. / (rs[0] * 1.1));   int ub_k = floor(qs[0][i] * 1. / (rs[0] * 0.9));   if (lb_k <= ub_k)     ++ans; }  inline void yljyhpsosy(int &P, VVL &qs, int &i) {   for (int j = (0); j < (P); ++j)     cin >> qs[i][j];   sort(begin(((qs[i]))), end(((qs[i]))));   ++i; }  
int main() {   ios::sync_with_stdio(0);    freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_9_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/okaduki/outer_temp/okaduki/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_9_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/okaduki/A-small-practice.in",           "r", stdin);    cin.tie(0);    int T;   cin >> T;   {     int t_ = (1);     while (t_ < (T + 1)) {       int N, P;       cin >> N >> P;       VL rs(N);       for (int i = (0); i < (N); ++i)         cin >> rs[i];       VVL qs(N, VL(P));       {         int i = (0);         while (i < (N))           yljyhpsosy(P, qs, i);       }        LL ans = 0;       if (N == 1) {         for (int i = (0); i < (P); ++i)           gbbvfqdwnj(qs, i, rs, ans);       } else {         int i2 = 0;         for (int i1 = (0); i1 < (P); ++i1) {           int lb_k = ceil(qs[0][i1] * 1. / (rs[0] * 1.1));           int ub_k = floor(qs[0][i1] * 1. / (rs[0] * 0.9));            while (i2 < P) {             int lb2_k = (int)ceil(qs[1][i2] * 1. / (rs[1] * 1.1));             int ub2_k = (int)floor(qs[1][i2] * 1. / (rs[1] * 0.9));             if (lb_k <= ub2_k && lb2_k <= ub_k) {               ++ans;               ++i2;               break;             } else if (ub_k < lb2_k) {               break;             }             ++i2;           }         }       }        cout << "Case #" << t_ << ": " << ans << endl;       ++t_;     }   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
typedef long double ld; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef vector<int> vi; typedef long double LD;  const double eps = 1e-9; ifstream fin;  ofstream fout;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &is, pair<S, T> &p) {   return is >> p.first >> p.second; } template <class S, class T> ostream &operator<<(ostream &os, const pair<S, T> &p) {   return os << p.first << " " << p.second; } template <class T> void maxi(T &x, T y) {   if (x < y) {     x = y;   } } template <class T> void solve(T &x, T y) {   if (x > y) {     x = y;   } }  const double EPS = 1e-10; const double PI = acos(-1.0); const LL MOD = 1e9 + 7;  inline void pmqxjryiah(VVL &qs, int &i, VL &rs, LL &ans) {   int lb_k = ceil(qs[0][i] * 1. / (rs[0] * 1.1));   int ub_k = floor(qs[0][i] * 1. / (rs[0] * 0.9));   if (lb_k <= ub_k)     ++ans; }  
int main() {   fin.open("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_9_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/okaduki/A-small-practice.in");    fout.open("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_9_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/okaduki/outer_temp/okaduki/A-small-practice_transformation.out");    cin.tie(0);    int T;   fin >> T;   {     int t_ = (1);     while (t_ < (T + 1)) {       int N, P;       fin >> N >> P;       VL rs(N);       for (int i = (0); i < (N); ++i)         fin >> rs[i];       VVL qs(N, VL(P));       {         int i = (0);         while (i < (N)) {           for (int j = (0); j < (P); ++j)             fin >> qs[i][j];           sort(begin(((qs[i]))), end(((qs[i]))));           ++i;         }       }        LL ans = 0;       if (N == 1) {         {           int i = (0);           while (i < (P)) {             pmqxjryiah(qs, i, rs, ans);             ++i;           }         }       } else {         int i2 = 0;         for (int i1 = (0); i1 < (P); ++i1) {           int lb_k = ceil(qs[0][i1] * 1. / (rs[0] * 1.1));           int ub_k = floor(qs[0][i1] * 1. / (rs[0] * 0.9));            while (i2 < P) {             int lb2_k = (int)ceil(qs[1][i2] * 1. / (rs[1] * 1.1));             int ub2_k = (int)floor(qs[1][i2] * 1. / (rs[1] * 0.9));             if (lb_k <= ub2_k && lb2_k <= ub_k) {               ++ans;               ++i2;               break;             } else if (ub_k < lb2_k) {               break;             }             ++i2;           }         }       }        fout << "Case #" << t_ << ": " << ans << endl;       ++t_;     }   }    return 0; }
#include <bits/stdc++.h> #include <utility> #include <vector> using namespace std;
typedef long long ll; typedef pair<int, int> pii; typedef vector<int> vi; typedef long double LD;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &is, pair<S, T> &p) {   return is >> p.first >> p.second; } template <class S, class T> ostream &get(ostream &os, const pair<S, T> &p) {   return os << p.first << " " << p.second; } template <class T> void maxi(T &x, T y) {   if (x < y)     x = y; }  inline void vlabcikuzk(VVL &qs, int &i, VL &rs, LL &ans) {   int lb_k = ceil(qs[0][i] * 1. / (rs[0] * 1.1));   int ub_k = floor(qs[0][i] * 1. / (rs[0] * 0.9));   if (lb_k <= ub_k)     ++ans; }  inline void degxfhtyfn(int &P, VVL &qs, int &i) {    for (int j = (0); j < (P); ++j)     cin >> qs[i][j];    sort(begin(((qs[i]))), end(((qs[i])))); }  inline void mzueslitjj(VVL &qs, int &i, VL &rs, LL &ans) {   vlabcikuzk(qs, i, rs, ans); }  
int main() {   cin.tie(0);   ios_base::sync_with_stdio(0);    int T;   cin >> T;   {     int s = (1);     while (s < (T + 1)) {       int N, P;       cin >> N >> P;       VL rs(N);       for (int i = (0); i < (N); ++i)         cin >> rs[i];       VVL qs(N, VL(P));       for (int i = (0); i < (N); ++i)         degxfhtyfn(P, qs, i);        LL ans = 0;       if (N == 1) {         for (int i = (0); i < (P); ++i)           mzueslitjj(qs, i, rs, ans);       } else {         int i2 = 0;         for (int i1 = (0); i1 < (P); ++i1) {           int lb_k = ceil(qs[0][i1] * 1. / (rs[0] * 1.1));           int ub_k = floor(qs[0][i1] * 1. / (rs[0] * 0.9));            while (i2 < P) {             int lb2_k = (int)ceil(qs[1][i2] * 1. / (rs[1] * 1.1));             int ub2_k = (int)floor(qs[1][i2] * 1. / (rs[1] * 0.9));             if (lb_k <= ub2_k && lb2_k <= ub_k) {               ++ans;               ++i2;               break;             } else if (ub_k < lb2_k) {               break;             }             ++i2;           }         }       }        cout << "Case #" << s << ": " << ans << endl;       ++s;     }   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <limits> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
int T; typedef long double LD; typedef long long ll; typedef pair<int, int> pii; typedef unsigned long long ull; typedef set<int> si;  int cs, ans;  int Hd, Ad, Hk, Ak, B, x; struct Rec {   int Hd, Ad, Hk, Ak;   Rec(int Hd, int Ad, int Hk, int Ak) : Hd(Hd), Ad(Ad), Hk(Hk), Ak(Ak) {}   Rec() {} }; int operator<(Rec a, Rec b) {   if (a.Hd == b.Hd && a.Ad == b.Ad)     if (a.Hk == b.Hk)       return a.Ak < b.Ak;   if (a.Hd == b.Hd && a.Ad == b.Ad)     return a.Hk < b.Hk;   if (a.Hd == b.Hd)     return a.Ad < b.Ad;   return a.Hd < b.Hd; } map<Rec, int> dis;  inline bool ltybrpmbaf() {   return true;   return false; }  void Push(queue<Rec> &Q, Rec w, int turn) {   w.Hd -= w.Ak;   if (w.Hd <= 0) {     if (ltybrpmbaf()) {       return;     }   }    if (dis.find(w) != dis.end())     return;   dis[w] = turn;   Q.push(w); } 
int main() {   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_10_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/kuzphi/outer_temp/kuzphi/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_10_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/kuzphi/A-small-practice.in",           "r", stdin);    ios::sync_with_stdio(true);    cin >> T;   while (T--) {     cout << "Case #" << ++cs << ": ";     cin >> Hd >> Ad >> Hk >> Ak >> B >> x;     if ((Ak - x) > Hd) {       puts("IMPOSSIBLE");       continue;     }     queue<Rec> Q;     Q.push(Rec(Hd, Ad, Hk, Ak));     dis.clear();     dis[Rec(Hd, Ad, Hk, Ak)] = 0;     int ck = 1;     while (Q.size()) {       Rec nxt = Q.front();       Q.pop();       int turn = dis[nxt] + 1;       Rec cure = nxt;       cure.Hd = Hd;       Push(Q, cure, turn);        Rec attack = nxt;       attack.Hk -= nxt.Ad;        if (attack.Hk <= 0) {          ans = turn;         ck = 0;         break;       }       Push(Q, attack, turn);        Rec buff = nxt;       buff.Ad += B;       Push(Q, buff, turn);        Rec debuff = nxt;       debuff.Ak = max(0, debuff.Ak - x);       Push(Q, debuff, turn);     }     if (!ck)       cout << ans << endl;     else       puts("IMPOSSIBLE");   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <limits> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
int T; const int mod = 1000000007;  ifstream fin;  int cs, ans;  int Hd, Ad, Hk, Ak, B, D; struct Rec {   int Hd, Ad, Hk, Ak;   Rec(int Hd, int Ad, int Hk, int Ak) : Hd(Hd), Ad(Ad), Hk(Hk), Ak(Ak) {}   Rec() {} }; int operator<(Rec a, Rec b) {   if (a.Hd == b.Hd && a.Ad == b.Ad && a.Hk == b.Hk)     return a.Ak < b.Ak;   if (a.Hd == b.Hd && a.Ad == b.Ad)     return a.Hk < b.Hk;   if (a.Hd == b.Hd)     return a.Ad < b.Ad;   return a.Hd < b.Hd; } map<Rec, int> dis;  void Push(queue<Rec> &Q, Rec t, int turn) {   t.Hd -= t.Ak;   if (t.Hd <= 0)     return;    if (dis.find(t) != dis.end())     return;   dis[t] = turn;   Q.push(t); } 
int main() {    fin.open("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_10_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/kuzphi/A-small-practice.in");    fin >> T;   while (T--) {     printf("Case #%d: ", ++cs);     fin >> Hd >> Ad >> Hk >> Ak >> B >> D;     if ((Ak - D) > Hd) {       puts("IMPOSSIBLE");       continue;     }     queue<Rec> Q;     Q.push(Rec(Hd, Ad, Hk, Ak));     dis.clear();     dis[Rec(Hd, Ad, Hk, Ak)] = 0;     int ck = 1;     while (Q.size()) {       Rec nxt = Q.front();       Q.pop();       int turn = dis[nxt] + 1;       Rec cure = nxt;       cure.Hd = Hd;       Push(Q, cure, turn);        Rec attack = nxt;       attack.Hk -= nxt.Ad;           if (attack.Hk <= 0) {          ans = turn;         ck = 0;         break;       }       Push(Q, attack, turn);        Rec buff = nxt;       buff.Ad += B;       Push(Q, buff, turn);        Rec debuff = nxt;       debuff.Ak = max(0, debuff.Ak - D);       Push(Q, debuff, turn);     }     if (!ck) {       printf("%d\n", ans);     } else       puts("IMPOSSIBLE");   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <limits> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;  
int T;  const int MAXN = 1005; ifstream fin;  typedef set<int> si; typedef long long ll; typedef pair<int, int> ii; typedef unsigned long long ull; typedef vector<int> vi; typedef long double ld; typedef vector<vector<int>> vvi;  int cs, ans;  int Hd, Ad, Hk, Ak, B, x; struct Rec {   int Hd, Ad, Hk, Ak;   Rec(int Hd, int Ad, int Hk, int Ak) : Hd(Hd), Ad(Ad), Hk(Hk), Ak(Ak) {}   Rec() {} }; int operator<(Rec a, Rec b) {   if (a.Hd == b.Hd && a.Ad == b.Ad && a.Hk == b.Hk)     return a.Ak < b.Ak;   if (a.Hd == b.Hd)     if (a.Ad == b.Ad)       return a.Hk < b.Hk;   if (a.Hd == b.Hd)     return a.Ad < b.Ad;   return a.Hd < b.Hd; } map<Rec, int> dis;  void Push(queue<Rec> &Q, Rec w, int turn) {   w.Hd -= w.Ak;   if (w.Hd <= 0)     return;    if (dis.find(w) != dis.end())     return;   dis[w] = turn;   Q.push(w); } 
int main() {   fin.open("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_10_Usenix_RF_1.0_True_MCTS_Classic_True/Mucosolvan/kuzphi/A-small-practice.in");    ios::sync_with_stdio(true);    fin >> T;   while (T--) {     cout << "Case #" << ++cs << ": ";     fin >> Hd >> Ad >> Hk >> Ak >> B >> x;     if ((Ak - x) > Hd) {       puts("IMPOSSIBLE");       continue;     }     queue<Rec> Q;     Q.push(Rec(Hd, Ad, Hk, Ak));     dis.clear();     dis[Rec(Hd, Ad, Hk, Ak)] = 0;     int ck = 1;     while (Q.size()) {       Rec nxt = Q.front();       Q.pop();       int turn = dis[nxt] + 1;       Rec cure = nxt;       cure.Hd = Hd;       Push(Q, cure, turn);        Rec attack = nxt;       attack.Hk -= nxt.Ad;             if (attack.Hk <= 0) {          ans = turn;         ck = 0;         break;       }       Push(Q, attack, turn);        Rec buff = nxt;       buff.Ad += B;       Push(Q, buff, turn);        Rec debuff = nxt;       debuff.Ak = max(0, debuff.Ak - x);       Push(Q, debuff, turn);     }     if (!ck)       cout << ans << endl;     else       puts("IMPOSSIBLE");   }   return 0; }
#include <algorithm> #include <bitset> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iostream> #include <limits> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;  
int T;typedef long double ld; typedef long long LL; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef vector<int> vi; typedef long double LD;  int cs, ans;  int Hd, Ad, Hk, Ak, B, D; struct Rec {   int Hd, Ad, Hk, Ak;   Rec(int Hd, int Ad, int Hk, int Ak) : Hd(Hd), Ad(Ad), Hk(Hk), Ak(Ak) {}   Rec() {} }; int operator<(Rec a, Rec b) {   if (a.Hd == b.Hd && a.Ad == b.Ad)     if (a.Hk == b.Hk)       return a.Ak < b.Ak;   if (a.Hd == b.Hd && a.Ad == b.Ad)     return a.Hk < b.Hk;   if (a.Hd == b.Hd)     return a.Ad < b.Ad;   return a.Hd < b.Hd; } map<Rec, int> dis;  void Push(queue<Rec> &Q, Rec w, int turn) {   w.Hd -= w.Ak;   if (w.Hd <= 0)     return;     if (dis.find(w) != dis.end())     return;   dis[w] = turn;   Q.push(w); } 
int main() {   int ret_val = 0;   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_10_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/kuzphi/A-small-practice.in",           "r", stdin);   cin >> T;   while (T--) {     printf("Case #%d: ", ++cs);     cin >> Hd >> Ad >> Hk >> Ak >> B >> D;     if ((Ak - D) > Hd) {       puts("IMPOSSIBLE");       continue;     }     queue<Rec> Q;     Q.push(Rec(Hd, Ad, Hk, Ak));     dis.clear();     dis[Rec(Hd, Ad, Hk, Ak)] = 0;     int ck = 1;     while (Q.size()) {       Rec nxt = Q.front();       Q.pop();       int turn = dis[nxt] + 1;       Rec cure = nxt;       cure.Hd = Hd;       Push(Q, cure, turn);        Rec attack = nxt;       attack.Hk -= nxt.Ad;             if (attack.Hk <= 0) {          ans = turn;         ck = 0;         break;       }       Push(Q, attack, turn);        Rec buff = nxt;       buff.Ad += B;       Push(Q, buff, turn);        Rec debuff = nxt;       debuff.Ak = max(0, debuff.Ak - D);       Push(Q, debuff, turn);     }     if (!ck)       cout << ans << endl;     else       puts("IMPOSSIBLE");   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
ofstream fout;  ifstream fin;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  bool is_set(int i, ll mask) { return (mask >> i) & 1; }  int get(ll mask) {   int ans = 0;   for (int i = 0; i < 64; ++i)     if (is_set(i, mask))       ++ans;   return ans; }  int first_bit(ll mask) {   int ret_val = -1;   int i = 0;   while (i < 64)     if (is_set(i++, mask))       return i - 1;   return ret_val; }  
int main() {   fout.open("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_11_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ibrahim5253/outer_temp/ibrahim5253/A-small-practice_transformation.out");    fin.open("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_11_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ibrahim5253/A-small-practice.in");    int t;   fin >> t;   int i;   for (i = 1; i <= t; ++i) {     int n, p;     fin >> n >> p;     vector<ll> w(n);     for (int i = 0; i < n; ++i)       fin >> w[i];     pair<ll, ll> a[n][p];     for (int i = 0; i < n; ++i) {       for (int j = 0; j < p; ++j) {         ll W;         fin >> W;         ll low = ceil(W / (w[i] * 1.1)), high = W / (w[i] * 0.9);         a[i][j] = make_pair(low, high);       }     }     if (n == 1) {       int ans = 0;       for (int i = 0; i < p; ++i)         if (a[0][i].first <= a[0][i].second)           ans++;       fout << "Case #" << i << ": " << ans << "\n";       continue;     }     int s[p];     for (int i = 0; i < p; ++i)       s[i] = i;     int ans = 0;     do {       int val = 0;       int i;       for (i = 0; i < p; ++i) {         if (a[1][s[i]].first > a[1][s[i]].second)           continue;         else if (a[0][i].first > a[0][i].second)           continue;          if (a[0][i].first >= a[1][s[i]].first &&                 a[0][i].first <= a[1][s[i]].second ||             a[1][s[i]].first >= a[0][i].first &&                 a[1][s[i]].first <= a[0][i].second)           val++;       }       ans = max(ans, val);     } while (next_permutation(s, s + p));     fout << "Case #" << i << ": " << ans << "\n";    }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
typedef long double ld; typedef pair<int, int> ii; typedef pair<int, int> PII;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  ll gcd(ll a, ll b) {   ll t;   while ((t = a % b) != 0) {     a = b;     b = t;   }   return b; }  ll fast_exp(ll x, ll n, ll N) {   if (n == 0)     return 1;   ll t = fast_exp(x, n / 2, N);   if (n % 2 == 0)     return (t * t) % N;   else     return (((t * t) % N) * x) % N; }  bool is_set(int i, ll mask) { return (mask >> i) & 1; }  int first_bit(ll mask) {   int i = 0;   while (i < 64)     if (is_set(i++, mask))       return i - 1;    return -1; }  
int main() {   ios::sync_with_stdio(0);   int t;   cin >> t;   for (int i = 1; i <= t; ++i) {     int n, p;     cin >> n >> p;     ll w[n];     for (int i = 0; i < n; ++i)       cin >> w[i];     pair<ll, ll> a[n][p];     {       int i = 0;       while (i < n) {         for (int j = 0; j < p; ++j) {           ll W;           cin >> W;           ll low = ceil(W / (w[i] * 1.1)), high = W / (w[i] * 0.9);           a[i][j] = make_pair(low, high);         }         ++i;       }     }     if (n == 1) {       int ans = 0;       {         int i = 0;         while (i < p) {           if (a[0][i].first <= a[0][i].second)             ans++;           ++i;         }       }       cout << "Case #" << i << ": " << ans << "\n";       continue;     }     int s[p];     for (int i = 0; i < p; ++i)       s[i] = i;     int ans = 0;     do {       int val = 0;       for (int i = 0; i < p; ++i) {         if (a[0][i].first > a[0][i].second ||             a[1][s[i]].first > a[1][s[i]].second)           continue;         if (a[0][i].first >= a[1][s[i]].first &&                 a[0][i].first <= a[1][s[i]].second ||             a[1][s[i]].first >= a[0][i].first &&                 a[1][s[i]].first <= a[0][i].second)           val++;       }       ans = max(ans, val);     } while (next_permutation(s, s + p));     cout << "Case #" << i << ": " << ans << "\n";    }   return 0; }
#include <algorithm> #include <bitset> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
const long double PI = 3.1415926535897932384626433832795; typedef vector<int> VI; typedef long long LL; typedef long double ld; typedef pair<int, int> PII; typedef long double LD;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  ll gcd(ll a, ll b) {   ll t;   while ((t = a % b) != 0) {     a = b;     b = t;   }   return b; }  ll fast_exp(ll d, ll n, ll m) {   if (n == 0)     return 1;   ll t = fast_exp(d, n / 2, m);   if (n % 2 == 0)     return (t * t) % m;   else     return (((t * t) % m) * d) % m; }  bool get(int i, ll mask) { return (mask >> i) & 1; }  int count_bits(ll mask) {   int ans = 0;   for (int i = 0; i < 64; ++i)     if (get(i, mask))       ++ans;   return ans; }  int first_bit(ll mask) {   int i = 0;   while (i < 64) {     if (get(i++, mask))       return i - 1;   }   return -1; } 
int main() {   int ret_val = 0;   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_11_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/ibrahim5253/A-small-practice.in",           "r", stdin);   int t;   scanf("%d ", &t);   for (int i = 1; i <= t; ++i) {     int n, p;     scanf("%d %d ", &n, &p);     vector<ll> w(n);     for (int i = 0; i < n; ++i)       scanf("%lld ", &w[i]);     pair<ll, ll> a[n][p];     for (int i = 0; i < n; ++i) {       for (int j = 0; j < p; ++j) {         ll W;         scanf("%lld ", &W);         ll low = ceil(W / (w[i] * 1.1)), high = W / (w[i] * 0.9);         a[i][j] = make_pair(low, high);       }     }     if (n == 1) {       int ans = 0;       for (int i = 0; i < p; ++i) {         if (a[0][i].first <= a[0][i].second)           ans++;       }       printf("Case #%d: %d\n", i, ans);       continue;     }     int s[p];     for (int i = 0; i < p; ++i)       s[i] = i;     int ans = 0;     do {       int val = 0;       for (int i = 0; i < p; ++i) {         if (a[0][i].first > a[0][i].second ||             a[1][s[i]].first > a[1][s[i]].second)           continue;         if (a[1][s[i]].first >= a[0][i].first &&             a[1][s[i]].first <= a[0][i].second)           val++;         else if (a[0][i].first >= a[1][s[i]].first &&                  a[0][i].first <= a[1][s[i]].second)           val++;       }       ans = max(ans, val);     } while (next_permutation(s, s + p));     printf("Case #%d: %d\n", i, ans);     }   return ret_val; }
#include <algorithm> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std;
const int MOD = 1000000007;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  ll solve(ll a, ll b) {   ll t;   while ((t = a % b) != 0) {     a = b;     b = t;   }   return b; }  ll fast_exp(ll tc, ll n, ll N) {   if (n == 0)     return 1;   ll t = fast_exp(tc, n / 2, N);   if (n % 2 == 0)     return (t * t) % N;   else     return (((t * t) % N) * tc) % N; }  bool is_set(int i, ll d) { return (d >> i) & 1; }  int count_bits(ll d) {   int ans = 0;   {     int i = 0;     while (i < 64) {       if (is_set(i, d))         ++ans;       ++i;     }   }   return ans; }  int first_bit(ll d) {   int i = 0;   while (i < 64)     if (is_set(i++, d))       return i - 1;   return -1; }  inline void grkafoojpu(int &n, ll w[n]) {   int i = 0;   while (i < n) {     cin >> w[i];     ++i;   } }  
int main() {    int t;   cin >> t;   for (int i = 1; i <= t; ++i) {     int n, p;     cin >> n >> p;     ll w[n];     grkafoojpu(n, w);     pair<ll, ll> a[n][p];     for (int i = 0; i < n; ++i) {       for (int j = 0; j < p; ++j) {         ll W;         cin >> W;         ll low = ceil(W / (w[i] * 1.1)), high = W / (w[i] * 0.9);         a[i][j] = make_pair(low, high);       }     }     if (n == 1) {       int ans = 0;       for (int i = 0; i < p; ++i)         if (a[0][i].first <= a[0][i].second)           ans++;       printf("Case #%d: %d\n", i, ans);       continue;     }     int s[p];     for (int i = 0; i < p; ++i)       s[i] = i;     int ans = 0;     do {       int val = 0;       int i;       for (i = 0; i < p; ++i) {         if (a[1][s[i]].first > a[1][s[i]].second)           continue;         else if (a[0][i].first > a[0][i].second)           continue;          if (a[0][i].first >= a[1][s[i]].first &&                 a[0][i].first <= a[1][s[i]].second ||             a[1][s[i]].first >= a[0][i].first &&                 a[1][s[i]].first <= a[0][i].second)           val++;       }       ans = max(ans, val);     } while (next_permutation(s, s + p));     printf("Case #%d: %d\n", i, ans);     }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <utility> #include <vector> using namespace std; 
const int MOD = 1000000007; const long double PI = 3.1415926535897932384626433832795; typedef long double ld; typedef long long ll; typedef pair<int, int> PII; typedef vector<int> vi; typedef long double LD;  using LL = long long; using pii = pair<int, int>;  int T, y;  
int main() {   ios::sync_with_stdio(0);    cin >> T;   while (T--) {     vector<vector<pii>> v;     vector<int> R;     int n, p;     cin >> n >> p;     for (int i = 0, x; i < n; i++)       cin >> x, R.push_back(x);     int mx = p;     for (int i = 0; i < n; i++) {       v.push_back(vector<pii>());       for (int j = 0, x; j < p; j++) {         cin >> x;         int a = ceil(1 / 1.1 * x / R[i]), b = floor(1 / 0.9 * x / R[i]);          if (a <= b)           v.back().emplace_back(a, b);       }       sort(v[i].begin(), v[i].end());     }     int ans = 0;     while (1) {       int t = 0, mxv = 1e9, mnid, solve, flag = 0;       for (int i = 0; i < n; i++)         if (v[i].size()) {           auto x = v[i].back();           if (x.first > t)             t = x.first, mnid = i;           if (x.second < mxv)             mxv = x.second, solve = i;         } else           flag = 1;       if (flag)         break;        if (t <= mxv) {         ans++;         for (int i = 0; i < n; i++)           v[i].pop_back();       } else         v[mnid].pop_back();     }     printf("Case #%d: %d\n", ++y, ans);   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const double EPS = 1e-9; const int INF = 1000000000;  typedef long double ld; typedef long double LD; typedef pair<int, int> ii; typedef unsigned long long ull; typedef vector<int> VI; typedef set<int> si; typedef vector<vector<int>> vvi;  using LL = long long; using pii = pair<int, int>;  int T, c;  
int main() {   int d = 0;   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_12_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/jiian/A-small-practice.in",           "r", stdin);   scanf("%d ", &T);   while (T--) {     vector<vector<pii>> v;     vector<int> R;     int n, p;     scanf("%d %d ", &n, &p);     for (int i = 0, x; i < n; i++)       scanf("%d ", &x), R.push_back(x);     int mx = p;     for (int i = 0; i < n; i++) {       v.push_back(vector<pii>());       for (int j = 0, x; j < p; j++) {         scanf("%d ", &x);         int a = ceil(1 / 1.1 * x / R[i]), b = floor(1 / 0.9 * x / R[i]);          if (a <= b)           v.back().emplace_back(a, b);       }       sort(v[i].begin(), v[i].end());     }     int ans = 0;     while (1) {       int mnv = 0, mxv = 1e9, mnid, mxid, flag = 0;       for (int i = 0; i < n; i++)         if (v[i].size()) {           auto x = v[i].back();           if (x.first > mnv)             mnv = x.first, mnid = i;           if (x.second < mxv)             mxv = x.second, mxid = i;         } else           flag = 1;       if (flag)         break;        if (mnv <= mxv) {         ans++;         for (int i = 0; i < n; i++)           v[i].pop_back();       } else         v[mnid].pop_back();     }     printf("Case #%d: %d\n", ++c, ans);   }   return d; }
#include <bits/stdc++.h> #include <fstream> #include <iomanip> #include <iostream> using namespace std;
ifstream fin;  using LL = long long; using pii = pair<int, int>;  int T, q;  inline void ixzeabefjr(vector<vector<pii>> &v, int &get, int &mnid, int &mxv,                        int &mxid, int &solve) {   auto y = v[solve].back();   if (y.first > get)     get = y.first, mnid = solve;   if (y.second < mxv)     mxv = y.second, mxid = solve; }  inline void faolncksrp(int &flag) { flag = 1; }  inline void rqbhoqpqpb(int &y, vector<int> &R, int &solve,                        vector<vector<pii>> &v) {   fin >> y;   int a = ceil(1 / 1.1 * y / R[solve]), r = floor(1 / 0.9 * y / R[solve]);    if (a <= r)     v.back().emplace_back(a, r); }  
int main() {   fin.open("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_12_Usenix_RF_1.0_True_MCTS_Classic_True/Thanabhat/jiian/A-small-practice.in");    fin >> T;   for (; T--;) {     vector<vector<pii>> v;     vector<int> R;     int n, p;     fin >> n >> p;     for (int solve = 0, y; solve < n; solve++)       fin >> y, R.push_back(y);     int mx = p;     for (int solve = 0; solve < n; solve++) {       v.push_back(vector<pii>());       for (int j = 0, y; j < p; j++)         rqbhoqpqpb(y, R, solve, v);       sort(v[solve].begin(), v[solve].end());     }     int ans = 0;     for (; 1;) {       int get = 0, mxv = 1e9, mnid, mxid, flag = 0;       for (int solve = 0; solve < n; solve++)         if (v[solve].size())           ixzeabefjr(v, get, mnid, mxv, mxid, solve);         else           faolncksrp(flag);       if (flag)         break;        if (get <= mxv) {         ans++;         for (int solve = 0; solve < n; solve++)           v[solve].pop_back();       } else {         v[mnid].pop_back();       }     }     cout << "Case #" << ++q << ": " << ans << "\n";   }   return 0; }
#include <bits/stdc++.h> #include <iostream> using namespace std; 
using LL = long long; using pii = pair<int, int>;  int tt, cas;  inline void agfytecgdw(int &cc, int &p, vector<int> &R,                        vector<vector<pii>> &v) {   int i = 0;   while (i < cc) {     v.push_back(vector<pii>());     for (int j = 0, x; j < p; j++) {       cin >> x;       int a = ceil(1 / 1.1 * x / R[i]), b = floor(1 / 0.9 * x / R[i]);        if (a <= b)         v.back().emplace_back(a, b);     }     sort(v[i].begin(), v[i].end());     i++;   } }  
int main() {   ios::sync_with_stdio(false);    int ret_val = 0;   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_12_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/jiian/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_12_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/jiian/outer_temp/jiian/A-small-practice_transformation.out",           "w", stdout);   cin >> tt;   while (tt--) {     vector<vector<pii>> v;     vector<int> R;     int cc, p;     cin >> cc >> p;     for (int i = 0, x; i < cc; i++)       cin >> x, R.push_back(x);     int mx = p;     agfytecgdw(cc, p, R, v);     int ans = 0;     while (true) {       int mnv = 0, mxv = 1e9, mnid, mxid, flag = 0;       for (int i = 0; i < cc; i++)         if (v[i].size()) {           auto x = v[i].back();           if (x.first > mnv)             mnv = x.first, mnid = i;           if (x.second < mxv)             mxv = x.second, mxid = i;         } else           flag = 1;       if (flag)         break;        if (mnv <= mxv) {         ans++;         for (int i = 0; i < cc; i++)           v[i].pop_back();       } else {         v[mnid].pop_back();       }     }     printf("Case #%d: %d\n", ++cas, ans);   }   return ret_val; }
#include <algorithm> #include <bitset> #include <cassert> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
typedef vector<int> vi; typedef vector<int> VI; typedef long double LD; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef unsigned long long ull; typedef set<int> si; typedef vector<vector<int>> vvi;  int N, a; int s[200]; int r[200][200]; int b[200]; int tb[200];  int solve[200][200]; int mm[200][200];  bool dfs(int cur, int less, int most) { return false; }  
int main(void) {    int x = 0;   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_13_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/iPeter/A-small-practice.in",           "r", stdin);   int t;   cin >> t;   for (int c = 1; c <= t; c++) {     cin >> N >> a;     for (int y = 0; y < N; ++y)       cin >> s[y];     for (int y = 0; y < N; ++y) {       for (int j = 0; j < a; ++j) {         cin >> r[y][j];       }       sort(r[y], r[y] + a);       {         int j = 0;         while (j < a) {           solve[y][j] = ceil(1.0 * r[y][j] / (1.1 * s[y]));           mm[y][j] = floor(1.0 * r[y][j] / (0.9 * s[y]));           ++j;         }       }     }       int ans = 0;     memset(b, 0, sizeof(b));       while (1) {       bool stop = false;       for (int y = 0; y < N; ++y) {         if (b[y] >= a)           stop = true;       }       if (stop)         break;        int cur = 0;       for (int y = 0; y < N; ++y) {         cur = max(cur, solve[y][b[y]]);       }        bool ok = true;       for (int y = 0; y < N; ++y) {         for (int j = b[y]; j <= a; ++j) {           if (j == a || cur < solve[y][j]) {             b[y] = j;             ok = false;             break;           }           if (solve[y][j] > mm[y][j]) {             continue;           }           if (cur <= mm[y][j]) {             tb[y] = j;             break;           }         }       }        if (!ok)         continue;        ++ans;       for (int y = 0; y < N; ++y) {         b[y] = tb[y] + 1;       }     }      cout << "Case #" << c << ": " << ans << "\n";   }   return x; }
#include <algorithm> #include <cmath> #include <cstdio> #include <cstring> #include <iostream> using namespace std; 
 int N, P; int s[200]; int r[200][200]; int b[200]; int tb[200];  int ll[200][200]; int mm[200][200];  bool dfs(int cur, int less, int most) { return 0; }  inline void snivvmezuj(int &i, int &solve) { cin >> r[i][solve]; }  
 int main(void) {   int t;   cin >> t;   for (int tt = 1; tt <= t; tt++) {     cin >> N >> P;     for (int i = 0; i < N; ++i)       cin >> s[i];     for (int i = 0; i < N; ++i) {       for (int solve = 0; solve < P; ++solve)         snivvmezuj(i, solve);       sort(r[i], r[i] + P);       for (int solve = 0; solve < P; ++solve) {         ll[i][solve] = ceil(1.0 * r[i][solve] / (1.1 * s[i]));         mm[i][solve] = floor(1.0 * r[i][solve] / (0.9 * s[i]));       }     }          int ans = 0;     memset(b, 0, sizeof(b));        while (1) {       bool stop = false;       for (int i = 0; i < N; ++i) {         if (b[i] >= P)           stop = true;       }       if (stop)         break;        int cur = 0;       for (int i = 0; i < N; ++i) {         cur = max(cur, ll[i][b[i]]);       }        bool ok = true;       for (int i = 0; i < N; ++i) {         for (int solve = b[i]; solve <= P; ++solve) {           if (cur < ll[i][solve]) {             b[i] = solve;             ok = false;             break;           } else if (solve == P) {             b[i] = solve;             ok = false;             break;           }           if (ll[i][solve] > mm[i][solve]) {             continue;           }           if (cur <= mm[i][solve]) {             tb[i] = solve;             break;           }         }       }         if (!ok)         continue;        ++ans;       for (int i = 0; i < N; ++i) {         b[i] = tb[i] + 1;       }     }      printf("Case #%d: %d\n", tt, ans);   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cmath> #include <cstdio> #include <cstring> using namespace std;
int N, P; int s[200]; int r[200][200]; int b[200]; int tb[200];  int ll[200][200]; int mm[200][200];  bool dfs(int cur, int less, int most) { return 0; }  
int main(void) {   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_13_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/iPeter/outer_temp/iPeter/A-small-practice_transformation.out",           "w", stdout);    int ret_val = 0;   int cc;   scanf("%d", &cc);   for (int tt = 1; tt <= cc; tt++) {     scanf("%d%d", &N, &P);     for (int i = 0; i < N; ++i)       scanf("%d", &s[i]);     for (int i = 0; i < N; ++i) {       for (int j = 0; j < P; ++j) {         scanf("%d", &r[i][j]);       }       sort(r[i], r[i] + P);       for (int j = 0; j < P; ++j) {         ll[i][j] = ceil(1.0 * r[i][j] / (1.1 * s[i]));         mm[i][j] = floor(1.0 * r[i][j] / (0.9 * s[i]));       }     }        int ans = 0;     memset(b, 0, sizeof(b));        while (1) {       bool stop = false;       for (int i = 0; i < N; ++i) {         if (b[i] >= P)           stop = true;       }       if (stop)         break;        int cur = 0;       for (int i = 0; i < N; ++i) {         cur = max(cur, ll[i][b[i]]);       }        bool ok = true;       for (int i = 0; i < N; ++i) {         for (int j = b[i]; j <= P; ++j) {           if (j == P || cur < ll[i][j]) {             b[i] = j;             ok = false;             break;           }           if (ll[i][j] > mm[i][j]) {             continue;           }           if (cur <= mm[i][j]) {             tb[i] = j;             break;           }         }       }         if (!ok)         continue;        ++ans;       for (int i = 0; i < N; ++i) {         b[i] = tb[i] + 1;       }     }      printf("Case #%d: %d\n", tt, ans);   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <cmath> #include <cstdio> #include <cstring> #include <iomanip> #include <iostream> using namespace std;
typedef double dbl;  int N, P; int tc[200]; int r[200][200]; int b[200]; int tb[200];  int ll[200][200]; int mm[200][200];  
int main(void) {   int ret_val = 0;   int t;   cin >> t;   {     int tt = 1;     while (tt <= t) {       cin >> N >> P;       for (int i = 0; i < N; ++i)         cin >> tc[i];       for (int i = 0; i < N; ++i) {         for (int j = 0; j < P; ++j) {           cin >> r[i][j];         }         sort(r[i], r[i] + P);         {           int j = 0;           while (j < P) {             ll[i][j] = ceil(1.0 * r[i][j] / (1.1 * tc[i]));             mm[i][j] = floor(1.0 * r[i][j] / (0.9 * tc[i]));             ++j;           }         }       }           int ans = 0;       memset(b, 0, sizeof(b));           for (; 1;) {         int stop = false;         for (int i = 0; i < N; ++i) {           if (b[i] >= P)             stop = 1;         }         if (stop)           break;          int cur = 0;         for (int i = 0; i < N; ++i)           cur = max(cur, ll[i][b[i]]);          bool ok = true;         int i;         for (i = 0; i < N; ++i) {           for (int j = b[i]; j <= P; ++j) {             if (cur < ll[i][j]) {               b[i] = j;               ok = false;               break;             } else if (j == P) {               b[i] = j;               ok = 0;               break;             }             if (ll[i][j] > mm[i][j]) {               continue;             }             if (cur <= mm[i][j]) {               tb[i] = j;               break;             }           }         }           if (!ok)           continue;          ++ans;         for (int i = 0; i < N; ++i) {           b[i] = tb[i] + 1;         }       }        cout << "Case #" << tt << ": " << ans << "\n";       tt++;     }   }   return ret_val; }
#include <bits/stdc++.h> #include <fstream> #include <iostream>  using namespace std;  
inline void msxmnxgpnc(long long &ans, long long &base, long long &mod,                        long long &p) {   if (p & 1)     ans = (ans * base) % mod;   base = (base * base) % mod;   p /= 2; }  long long get(long long base, long long p, long long mod = (1000000007LL)) {   long long ans = 1;   while (p)     msxmnxgpnc(ans, base, mod, p);   return ans; }  long long solve(long long a, long long b) {   if (b == 0)     return a;   return solve(b, a % b); }  int n, p, tc[55][55], req[55], DP[10][1024];  int dp(int i, int mask) {   if (i == p)     return 0;   int &ans = DP[i][mask];   if (ans != -1)     return ans;   ans = dp(i + 1, mask);   for (int j = 0; j < p; j++) {     if ((mask >> j) & 1)       continue;     int z = tc[0][i] / req[0];     for (int x = z + 5; x >= z - 5 && x >= 1; x--) {       int lo1 = ceil(1LL * x * req[0] * 0.9),           hi1 = floor(1LL * x * req[0] * 1.1);       int lo2 = ceil(1LL * x * req[1] * 0.9),           hi2 = floor(1LL * x * req[1] * 1.1);       if (tc[0][i] >= lo1 && tc[0][i] <= hi1 && tc[1][j] >= lo2 &&           tc[1][j] <= hi2)         ans = max(ans, 1 + dp(i + 1, mask | (1 << j)));     }   }    return ans; }  
int main() {   int ret_val = 0;   ios::sync_with_stdio(false);    cin.tie(0);   int t, x = 1;   cin >> t;   while (t--) {      cin >> n >> p;     for (int i = 0; i < n; i++)       cin >> req[i];     for (int i = 0; i < n; i++)       for (int j = 0; j < p; j++)         cin >> tc[i][j];      if (n == 1) {       int ans = 0;       for (int i = 0; i < p; i++) {         int ok = 0;         for (int x = 2000000; x >= 1; x--) {           int lo = ceil(1LL * x * req[0] * 0.9),               hi = floor(1LL * x * req[0] * 1.1);           if (tc[0][i] >= lo && tc[0][i] <= hi) {             ok = true;             break;           }         }         ans += ok;       }        cout << "Case #" << x++ << ": " << ans << endl;       continue;     }      memset(DP, -1, sizeof(DP));     cout << "Case #" << x++ << ": " << dp(0, 0) << endl;   }   return ret_val; }
#include <bits/stdc++.h> #include <stdio.h>  using namespace std; 
long long pwr(long long base, long long p, long long mod = (1000000007LL)) {   long long ans = 1;   while (p) {     if (p & 1)       ans = (ans * base) % mod;     base = (base * base) % mod;     p /= 2;   }   return ans; }  long long gcd(long long a, long long b) {   if (b == 0)     return a;   return gcd(b, a % b); }  int n, p, cc[55][55], req[55], DP[10][1024];  int dp(int i, int mask) {   if (i == p) {     int ret_val = 0;     return ret_val;   }   int &ans = DP[i][mask];   if (ans != -1)     return ans;   ans = dp(i + 1, mask);   for (int j = 0; j < p; j++) {     if ((mask >> j) & 1)       continue;     int z = cc[0][i] / req[0];     for (int x = z + 5; x >= z - 5 && x >= 1; x--) {       int lo1 = ceil(1LL * x * req[0] * 0.9),           hi1 = floor(1LL * x * req[0] * 1.1);       int lo2 = ceil(1LL * x * req[1] * 0.9),           hi2 = floor(1LL * x * req[1] * 1.1);       if (cc[0][i] >= lo1 && cc[0][i] <= hi1 && cc[1][j] >= lo2 &&           cc[1][j] <= hi2)         ans = max(ans, 1 + dp(i + 1, mask | (1 << j)));     }   }    return ans; }  
int main() {   int ret_val = 0;   cin.tie(0);   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_14_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/satyaki3794/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_14_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/satyaki3794/outer_temp/satyaki3794/A-small-practice_transformation.out",           "w", stdout);   int tt, x = 1;   scanf("%d ", &tt);   while (tt--) {      scanf("%d %d ", &n, &p);     for (int i = 0; i < n; i++)       scanf("%d ", &req[i]);     for (int i = 0; i < n; i++)       for (int j = 0; j < p; j++)         scanf("%d ", &cc[i][j]);      if (n == 1) {       int ans = 0;       for (int i = 0; i < p; i++) {         bool ok = 0;         for (int x = 2000000; x >= 1; x--) {           int lo = ceil(1LL * x * req[0] * 0.9),               hi = floor(1LL * x * req[0] * 1.1);           if (cc[0][i] >= lo && cc[0][i] <= hi) {             ok = true;             break;           }         }         ans += ok;       }        printf("Case #%d: %d\n", x++, ans);       continue;     }      memset(DP, -1, sizeof(DP));     printf("Case #%d: %d\n", x++, dp(0, 0));   }   return ret_val; }
#include <bits/stdc++.h> #include <fstream>  using namespace std; 
ofstream fout;  typedef int &td_i;  long long gcd(long long a, long long b) {   if (b == 0)     return a;   return gcd(b, a % b); }  int n, p, arr[55][55], req[55], DP[10][1024];  inline bool zojetjagek(int &zojet) {   int ret_val = 0;   zojet = ret_val;   return true;   return false; }  int dp(int i, int mask) {   if (i == p) {     int zojet;     if (zojetjagek(zojet)) {       return zojet;     }   }   td_i ans = DP[i][mask];   if (ans != -1)     return ans;   ans = dp(i + 1, mask);   int j;   for (j = 0; j < p; j++) {     if ((mask >> j) & 1)       continue;     int z = arr[0][i] / req[0];     for (int tc = z + 5; tc >= z - 5 && tc >= 1; tc--) {       int lo1 = ceil(1LL * tc * req[0] * 0.9),           hi1 = floor(1LL * tc * req[0] * 1.1);       int lo2 = ceil(1LL * tc * req[1] * 0.9),           hi2 = floor(1LL * tc * req[1] * 1.1);       if (arr[0][i] >= lo1 && arr[0][i] <= hi1 && arr[1][j] >= lo2 &&           arr[1][j] <= hi2)         ans = max(ans, 1 + dp(i + 1, mask | (1 << j)));     }   }    return ans; }  
int main() {   fout.open("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_13_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/satyaki3794/outer_temp/satyaki3794/A-small-practice_transformation.out");    int ret_val = 0;   cin.tie(0);    int t, tc = 1;   cin >> t;   for (; t--;) {      cin >> n >> p;     for (int i = 0; i < n; i++)       cin >> req[i];     for (int i = 0; i < n; i++)       for (int j = 0; j < p; j++) {         cin >> arr[i][j];       }      if (n == 1) {       int ans = 0;       for (int i = 0; i < p; i++) {         bool ok = 0;         for (int tc = 2000000; tc >= 1; tc--) {           int lo = ceil(1LL * tc * req[0] * 0.9),               hi = floor(1LL * tc * req[0] * 1.1);           if (arr[0][i] >= lo && arr[0][i] <= hi) {             ok = true;             break;           }         }         ans += ok;       }        fout << "Case #" << tc++ << ": " << ans << endl;       continue;     }      memset(DP, -1, sizeof(DP));     fout << "Case #" << tc++ << ": " << dp(0, 0) << endl;   }   return ret_val; }
#include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <functional> #include <iostream> #include <list> #include <numeric> #include <queue> #include <set> #include <stdio.h> #include <string> #include <vector>  using namespace std; 
typedef vector<int> VI; typedef long double LD; typedef set<int> si; typedef vector<vector<int>> vvi; typedef long long ll; typedef pair<int, int> pii; typedef pair<int, pii> iii;  ll pwr(ll base, ll p, ll mod = (1000000007LL)) {   ll ans = 1;   while (p) {     if (p & 1)       ans = (ans * base) % mod;     base = (base * base) % mod;     p /= 2;   }   return ans; }  int n, p, arr[55][55], req[55], DP[10][1024];  int dp(int i, int mask) {   if (i == p)     return 0;   int &ans = DP[i][mask];   if (ans != -1)     return ans;   ans = dp(i + 1, mask);   for (int j = 0; j < p; j++) {     if ((mask >> j) & 1)       continue;     int z = arr[0][i] / req[0];     for (int x = z + 5; x >= z - 5 && x >= 1; x--) {       int lo1 = ceil(1LL * x * req[0] * 0.9),           hi1 = floor(1LL * x * req[0] * 1.1);       int lo2 = ceil(1LL * x * req[1] * 0.9),           hi2 = floor(1LL * x * req[1] * 1.1);       if (arr[0][i] >= lo1 && arr[0][i] <= hi1 && arr[1][j] >= lo2 &&           arr[1][j] <= hi2)         ans = max(ans, 1 + dp(i + 1, mask | (1 << j)));     }   }    return ans; }  
int main() {   ios::sync_with_stdio(0);    cin.tie(0);    freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_13_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/satyaki3794/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_13_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/satyaki3794/outer_temp/satyaki3794/A-small-practice_transformation.out",           "w", stdout);    int t, x = 1;   scanf("%d ", &t);    while (t--) {      scanf("%d %d ", &n, &p);     for (int i = 0; i < n; i++)       scanf("%d ", &req[i]);     for (int i = 0; i < n; i++)       for (int j = 0; j < p; j++)         scanf("%d ", &arr[i][j]);      if (n == 1) {       int ans = 0;       for (int i = 0; i < p; i++) {         int ok = false;         for (int x = 2000000; x >= 1; x--) {           int lo = ceil(1LL * x * req[0] * 0.9),               hi = floor(1LL * x * req[0] * 1.1);           if (arr[0][i] >= lo && arr[0][i] <= hi) {             ok = true;             break;           }         }         ans += ok;       }        printf("Case #%d: %d\n", x++, ans);       continue;     }      memset(DP, -1, sizeof(DP));     printf("Case #%d: %d\n", x++, dp(0, 0));   }    return 0; }
#include <bits/stdc++.h> using namespace std;  
typedef double dbl;  inline void joycelmcxo(int &m1, int &m2) { swap(m1, m2); }  int main(int heoi_Var, char **argv) {   int ret_val = 0;   ifstream m("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_14_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/gultai4ukr/A-small-practice.in");   ofstream fout("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_14_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out");   int t;   m >> t;   for (int testcase = 0; testcase < t; ++testcase) {     int n, p;     m >> n >> p;     vector<int> need(n);     for (int i = 0; i < n; ++i) {       m >> need[i];     }     vector<vector<int>> q(n, vector<int>(p));     for (int i = 0; i < n; ++i) {       for (int j = 0; j < p; ++j) {         m >> q[i][j];       }     }      assert(n < 3);     int ans = 0;     if (n == 1) {       for (int i = 0; i < p; ++i) {         int tc = q[0][i] / need[0];         long double fr1 = 1.0L * q[0][i] / (tc * need[0]);         if (0.9L <= fr1 && fr1 <= 1.1L) {           ans++;           continue;         }         long double fr2 = 1.0L * q[0][i] / ((tc + 1) * need[0]);         if (0.9L <= fr2 && fr2 <= 1.1L) {           ans++;         }       }     } else {       vector<int> perm(p);       for (int i = 0; i < p; ++i) {         perm[i] = i;       }       do {         int cur = 0;         for (int i = 0; i < p; ++i) {           int m1 = q[0][i] / need[0];           int m2 = q[1][i] / need[1];           if (m2 < m1)             joycelmcxo(m1, m2);           for (int tc = m1; tc < m2 + 2; ++tc) {             long double fr01 = 1.0L * q[0][i] / (tc * need[0]);             long double fr11 = 1.0L * q[1][perm[i]] / (tc * need[1]);             long double fr02 = 1.0L * q[0][i] / ((tc + 1) * need[0]);             long double fr12 = 1.0L * q[1][perm[i]] / ((tc + 1) * need[1]);             if (0.9L <= fr01 && fr01 <= 1.1L && 0.9L <= fr11 && fr11 <= 1.1L) {               cur++;               break;             } else if (0.9L <= fr02 && fr02 <= 1.1L && 0.9L <= fr12 &&                        fr12 <= 1.1L) {               cur++;               break;             }           }         }         ans = max(ans, cur);       } while (next_permutation(perm.begin(), perm.end()));     }      fout << "Case #" << testcase + 1 << ": " << ans << endl;   }   m.close();   fout.close();   return ret_val; }
#include <bits/stdc++.h> using namespace std;  
typedef double dbl;  inline void joycelmcxo(int &m1, int &m2) { swap(m1, m2); }  
int main(int heoi_Var, char **argv) {   int ret_val = 0;   ifstream m("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_14_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/gultai4ukr/A-small-practice.in");   ofstream fout("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_14_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out");   int t;   m >> t;   for (int testcase = 0; testcase < t; ++testcase) {     int n, p;     m >> n >> p;     vector<int> need(n);     for (int i = 0; i < n; ++i) {       m >> need[i];     }     vector<vector<int>> q(n, vector<int>(p));     for (int i = 0; i < n; ++i) {       for (int j = 0; j < p; ++j) {         m >> q[i][j];       }     }      assert(n < 3);     int ans = 0;     if (n == 1) {       for (int i = 0; i < p; ++i) {         int tc = q[0][i] / need[0];         long double fr1 = 1.0L * q[0][i] / (tc * need[0]);         if (0.9L <= fr1 && fr1 <= 1.1L) {           ans++;           continue;         }         long double fr2 = 1.0L * q[0][i] / ((tc + 1) * need[0]);         if (0.9L <= fr2 && fr2 <= 1.1L) {           ans++;         }       }     } else {       vector<int> perm(p);       for (int i = 0; i < p; ++i) {         perm[i] = i;       }       do {         int cur = 0;         for (int i = 0; i < p; ++i) {           int m1 = q[0][i] / need[0];           int m2 = q[1][i] / need[1];           if (m2 < m1)             joycelmcxo(m1, m2);           for (int tc = m1; tc < m2 + 2; ++tc) {             long double fr01 = 1.0L * q[0][i] / (tc * need[0]);             long double fr11 = 1.0L * q[1][perm[i]] / (tc * need[1]);             long double fr02 = 1.0L * q[0][i] / ((tc + 1) * need[0]);             long double fr12 = 1.0L * q[1][perm[i]] / ((tc + 1) * need[1]);             if (0.9L <= fr01 && fr01 <= 1.1L && 0.9L <= fr11 && fr11 <= 1.1L) {               cur++;               break;             } else if (0.9L <= fr02 && fr02 <= 1.1L && 0.9L <= fr12 &&                        fr12 <= 1.1L) {               cur++;               break;             }           }         }         ans = max(ans, cur);       } while (next_permutation(perm.begin(), perm.end()));     }      fout << "Case #" << testcase + 1 << ": " << ans << endl;   }   m.close();   fout.close();   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <numeric> #include <queue> #include <set> #include <stack> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
typedef long double td_ld;  const double EPS = 1e-9; const int MOD = 1000000007; const double eps = 1e-9;  inline void mqcrotvohx(int &m1, int &m2) { swap(m1, m2); }  inline void iibotwsgrw(std::ifstream &fin, vector<vector<int>> &q, int &i,                        int &j) {   fin >> q[i][j]; }  inline void fyeijunwsm(int &p, vector<int> &perm, int &i) {   i = 0;   for (; i < p;) {     perm[i] = i;     ++i;   } }  
int main(int argc, char **argv) {   ifstream fin("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_14_Usenix_RF_1.0_True_MCTS_Classic_True/try/gultai4ukr/A-small-practice.in");    int t;   fin >> t;   for (int testcase = 0; testcase < t; ++testcase) {     int n, p;     fin >> n >> p;     vector<int> need(n);     int i;     for (i = 0; i < n; ++i) {       fin >> need[i];     }     vector<vector<int>> q(n, vector<int>(p));     for (int i = 0; i < n; ++i) {       for (int j = 0; j < p; ++j)         iibotwsgrw(fin, q, i, j);     }      assert(n < 3);     int ans = 0;     if (n == 1) {       for (int i = 0; i < p; ++i) {         int k = q[0][i] / need[0];         td_ld fr1 = 1.0L * q[0][i] / (k * need[0]);         if (0.9L <= fr1 && fr1 <= 1.1L) {           ans++;           continue;         }         td_ld fr2 = 1.0L * q[0][i] / ((k + 1) * need[0]);         if (0.9L <= fr2 && fr2 <= 1.1L) {           ans++;         }       }     } else {       vector<int> perm(p);       int i;       fyeijunwsm(p, perm, i);        do {         int cur = 0;         for (int i = 0; i < p; ++i) {           int m1 = q[0][i] / need[0];           int m2 = q[1][i] / need[1];           if (m2 < m1)             mqcrotvohx(m1, m2);           for (int k = m1; k < m2 + 2; ++k) {             td_ld fr01 = 1.0L * q[0][i] / (k * need[0]);             td_ld fr11 = 1.0L * q[1][perm[i]] / (k * need[1]);             td_ld fr02 = 1.0L * q[0][i] / ((k + 1) * need[0]);             td_ld fr12 = 1.0L * q[1][perm[i]] / ((k + 1) * need[1]);             if (0.9L <= fr01 && fr01 <= 1.1L && 0.9L <= fr11 && fr11 <= 1.1L) {               cur++;               break;             } else {               if (0.9L <= fr02 && fr02 <= 1.1L && 0.9L <= fr12 &&                   fr12 <= 1.1L) {                 cur++;                 break;               }             }           }         }         ans = max(ans, cur);       } while (next_permutation(perm.begin(), perm.end()));     }      cout << "Case #" << testcase + 1 << ": " << ans << endl;   }    fin.close();    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
typedef long double td_ld;  const int MOD = 1000000007;  inline void fafdtybknv(int &m1, int &m2) { swap(m1, m2); }  inline void qgdguwbzga(int &ans) { ans++; }  
int main(int y, char **argv) {    ofstream fout("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_14_Usenix_RF_1.0_True_MCTS_Classic_True/kuzphi/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out");    int t;   cin >> t;   for (int testcase = 0; testcase < t; ++testcase) {     int n, p;     cin >> n >> p;     vector<int> need(n);     for (int i = 0; i < n; ++i) {       cin >> need[i];     }     vector<vector<int>> q(n, vector<int>(p));     for (int i = 0; i < n; ++i) {       for (int j = 0; j < p; ++j) {         cin >> q[i][j];       }     }      assert(n < 3);     int ans = 0;     if (n == 1) {       {         int i = 0;         while (i < p) {           int k = q[0][i] / need[0];           td_ld fr1 = 1.0L * q[0][i] / (k * need[0]);           if (0.9L <= fr1)             if (fr1 <= 1.1L) {               ans++;               ++i;               continue;             }           td_ld fr2 = 1.0L * q[0][i] / ((k + 1) * need[0]);           if (0.9L <= fr2 && fr2 <= 1.1L)             qgdguwbzga(ans);           ++i;         }       }     } else {       vector<int> perm(p);       {         int i = 0;         while (i < p) {           perm[i] = i;           ++i;         }       }       do {         int cur = 0;         for (int i = 0; i < p; ++i) {           int m1 = q[0][i] / need[0];           int m2 = q[1][i] / need[1];           if (m2 < m1)             fafdtybknv(m1, m2);           for (int k = m1; k < m2 + 2; ++k) {             td_ld fr01 = 1.0L * q[0][i] / (k * need[0]);             td_ld fr11 = 1.0L * q[1][perm[i]] / (k * need[1]);             td_ld fr02 = 1.0L * q[0][i] / ((k + 1) * need[0]);             td_ld fr12 = 1.0L * q[1][perm[i]] / ((k + 1) * need[1]);             if (0.9L <= fr01 && fr01 <= 1.1L && 0.9L <= fr11 && fr11 <= 1.1L) {               cur++;               break;             } else if (0.9L <= fr02 && fr02 <= 1.1L && 0.9L <= fr12 &&                        fr12 <= 1.1L) {               cur++;               break;             }           }         }         ans = max(ans, cur);       } while (next_permutation(perm.begin(), perm.end()));     }      fout << "Case #" << testcase + 1 << ": " << ans << endl;   }    fout.close();   return 0; }
#include <bits/stdc++.h> #include <stdio.h>  using namespace std; 
typedef float td_f; typedef double dbl; typedef vector<int> vi; typedef long long ll; typedef long double ld; typedef pair<int, int> pii; typedef pair<pii, int> para; const int inf = 1e9 + 7; const int maxN = 50; const int M = 50; const int N = 50;  int t, n, p; int req[maxN], minim[maxN][maxN], arr[maxN][maxN], dlbi_Var[maxN][maxN]; bool graph[maxN][maxN];  bool przeciecie(int i, int m) {   if (minim[1][i] == inf || minim[2][m] == inf)     return false;   if (minim[1][i] >= minim[2][m])     if (minim[1][i] <= dlbi_Var[2][m])       return true;   if (dlbi_Var[1][i] >= minim[2][m] && dlbi_Var[1][i] <= dlbi_Var[2][m])     return true;   return false; }   bool bpm(bool bpGraph[M][N], int u, bool seen[], int matchR[]) {    for (int v = 0; v < N; v++) {      if (bpGraph[u][v] && !seen[v]) {       seen[v] = 1;        if (matchR[v] < 0 || bpm(bpGraph, matchR[v], seen, matchR)) {         matchR[v] = u;         return true;       }     }   }   return false; }   int maxBPM(bool bpGraph[M][N]) {    int matchR[N];     memset(matchR, -1, sizeof(matchR));    int result = 0;    for (int u = 0; u < M; u++) {       bool seen[N];     memset(seen, 0, sizeof(seen));       if (bpm(bpGraph, u, seen, matchR))       result++;   }   return result; }  inline void wxrdmnaeej(int &ans) {   int m = (1);   for (; m <= ((p));) {     if (minim[1][m] != inf)       ans++;     ++m;   } }  
int main() {   int ret_val = 0;    cin >> t;   for (int test = (1); test <= ((t)); ++test) {     cin >> n >> p;     for (int i = (1); i <= ((n)); ++i) {       cin >> req[i];     }      for (int tc = (1); tc <= ((n)); ++tc)       for (int m = (1); m <= ((p)); ++m) {         minim[tc][m] = dlbi_Var[tc][m] = inf;       }     for (int i = (1); i <= ((40)); ++i) {       for (int m = (1); m <= ((40)); ++m) {         graph[i][m] = 0;         minim[i][m] = dlbi_Var[i][m] = inf;       }     }     for (int i = (1); i <= ((n)); ++i)       for (int m = (1); m <= ((p)); ++m)         cin >> arr[i][m];      for (int tc = (1); tc <= ((n)); ++tc) {       for (int m = (1); m <= ((p)); ++m) {         td_f weight = req[tc];         int owyi_Var = 1;         for (; weight <= 2 * arr[tc][m];) {           if (arr[tc][m] >= 0.9 * weight && arr[tc][m] <= 1.1 * weight) {             minim[tc][m] = min(minim[tc][m], owyi_Var);             dlbi_Var[tc][m] = owyi_Var;           }           weight += req[tc];           owyi_Var++;         }       }     }      printf("Case #%d: ", test);     if (n == 1) {       int ans = 0;       wxrdmnaeej(ans);       printf("%d\n", ans);     } else {       for (int i = (1); i <= ((p)); ++i)         for (int m = (1); m <= ((p)); ++m)           if (przeciecie(i, m)) {             graph[i][m] = true;        printf("%d\n", maxBPM(graph));     }   }   return ret_val; }
#include <bits/stdc++.h> #include <stdio.h>  using namespace std; 
typedef vector<int> vi; typedef long long ll; typedef long double ld; typedef pair<int, int> pii; typedef pair<pii, int> para; const int inf = 1e9 + 7; const int maxN = 50; const int M = 50; const int N = 50;  int t, n, p; int req[maxN], minim[maxN][maxN], arr[maxN][maxN], maxim[maxN][maxN]; bool graph[maxN][maxN];  bool przeciecie(int i, int j) {   if (minim[1][i] == inf || minim[2][j] == inf)     return false;   if (minim[1][i] >= minim[2][j] && minim[1][i] <= maxim[2][j])     return true;   if (maxim[1][i] >= minim[2][j] && maxim[1][i] <= maxim[2][j])     return true;   return false; }   bool bpm(bool bpGraph[M][N], int u, bool seen[], int matchR[]) {    for (int v = 0; v < N; v++) {      if (bpGraph[u][v] && !seen[v]) {       seen[v] = true;          if (matchR[v] < 0 || bpm(bpGraph, matchR[v], seen, matchR)) {         matchR[v] = u;         return true;       }     }   }   return false; }   int maxBPM(bool bpGraph[M][N]) {    int matchR[N];     memset(matchR, -1, sizeof(matchR));    int result = 0;    for (int u = 0; u < M; u++) {        bool seen[N];     memset(seen, 0, sizeof(seen));       if (bpm(bpGraph, u, seen, matchR))       result++;   }   return result; }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_15_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/Mucosolvan/outer_temp/Mucosolvan/A-small-practice_transformation.out",           "w", stdout);    int ret_val = 0;    scanf("%d ", &t);   for (int test = (1); test <= ((t)); ++test) {     scanf("%d %d ", &n, &p);     for (int i = (1); i <= ((n)); ++i) {       scanf("%d ", &req[i]);     }      for (int x = (1); x <= ((n)); ++x)       for (int j = (1); j <= ((p)); ++j) {         minim[x][j] = maxim[x][j] = inf;       }     for (int i = (1); i <= ((40)); ++i) {       for (int j = (1); j <= ((40)); ++j) {         graph[i][j] = 0;         minim[i][j] = maxim[i][j] = inf;       }     }     for (int i = (1); i <= ((n)); ++i)       for (int j = (1); j <= ((p)); ++j)         scanf("%d ", &arr[i][j]);      for (int x = (1); x <= ((n)); ++x) {       for (int j = (1); j <= ((p)); ++j) {         float weight = req[x];         int cnt = 1;         while (weight <= 2 * arr[x][j]) {           if (arr[x][j] >= 0.9 * weight && arr[x][j] <= 1.1 * weight) {             minim[x][j] = min(minim[x][j], cnt);             maxim[x][j] = cnt;           }           weight += req[x];           cnt++;         }       }     }      cout << "Case #" << test << ": ";     if (n == 1) {       int ans = 0;       for (int j = (1); j <= ((p)); ++j) {         if (minim[1][j] != inf)           ans++;       }       cout << ans << endl;     } else {       for (int i = (1); i <= ((p)); ++i)         for (int j = (1); j <= ((p)); ++j)           if (przeciecie(i, j)) {             graph[i][j] = 1;            cout << maxBPM(graph) << endl;     }   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
const int mod = 1000000007; const int MOD = 1000000007; typedef float td_f; typedef set<int> si; typedef vector<int> vi; typedef long long LL; typedef long double LD; typedef pair<int, int> PII; typedef pair<PII, int> para; const int inf = 1e9 + 7; const int maxN = 50; const int M = 50; const int N = 50;  int t, n, p; int req[maxN], minim[maxN][maxN], arr[maxN][maxN], b[maxN][maxN]; bool graph[maxN][maxN];  bool przeciecie(int i, int j) {   if (minim[1][i] == inf || minim[2][j] == inf)     return false;   if (minim[1][i] >= minim[2][j] && minim[1][i] <= b[2][j])     return true;   if (b[1][i] >= minim[2][j] && b[1][i] <= b[2][j])     return true;   return false; }   bool get(bool bpGraph[M][N], int u, bool seen[], int matchR[]) {    for (int v = 0; v < N; v++) {      if (bpGraph[u][v] && !seen[v]) {       seen[v] = true;          if (get(bpGraph, matchR[v], seen, matchR)) {         matchR[v] = u;         return true;       } else if (matchR[v] < 0) {         matchR[v] = u;         return 1;       }     }   }   return false; }   int maxBPM(bool bpGraph[M][N]) {    int matchR[N];     memset(matchR, -1, sizeof(matchR));    int result = 0;    for (int u = 0; u < M; u++) {        bool seen[N];     memset(seen, 0, sizeof(seen));       if (get(bpGraph, u, seen, matchR))       result++;   }   return result; }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_15_Usenix_RF_1.0_True_MCTS_Classic_True/try/Mucosolvan/A-small-practice.in",           "r", stdin);    freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_15_Usenix_RF_1.0_True_MCTS_Classic_True/try/Mucosolvan/outer_temp/Mucosolvan/A-small-practice_transformation.out",           "w", stdout);    scanf("%d ", &t);   for (int test = (1); test <= ((t)); ++test) {     scanf("%d %d ", &n, &p);     for (int i = (1); i <= ((n)); ++i) {       scanf("%d ", &req[i]);     }      for (int x = (1); x <= ((n)); ++x)       for (int j = (1); j <= ((p)); ++j) {         minim[x][j] = b[x][j] = inf;       }     for (int i = (1); i <= ((40)); ++i) {       for (int j = (1); j <= ((40)); ++j) {         graph[i][j] = 0;         minim[i][j] = b[i][j] = inf;       }     }     for (int i = (1); i <= ((n)); ++i)       for (int j = (1); j <= ((p)); ++j)         scanf("%d ", &arr[i][j]);      for (int x = (1); x <= ((n)); ++x) {       for (int j = (1); j <= ((p)); ++j) {         td_f weight = req[x];         int cnt = 1;         for (; weight <= 2 * arr[x][j];) {           if (arr[x][j] >= 0.9 * weight && arr[x][j] <= 1.1 * weight) {             minim[x][j] = min(minim[x][j], cnt);             b[x][j] = cnt;           }           weight += req[x];           cnt++;         }       }     }      printf("Case #%d: ", test);     if (n == 1) {       int ans = 0;       for (int j = (1); j <= ((p)); ++j) {         if (minim[1][j] != inf)           ans++;       }       printf("%d\n", ans);     } else {       for (int i = (1); i <= ((p)); ++i)         for (int j = (1); j <= ((p)); ++j)           if (przeciecie(i, j)) {             graph[i][j] = 1;         printf("%d\n", maxBPM(graph));     }   }   return 0; }
#include <bits/stdc++.h> #include <fstream> #include <vector>  using namespace std; 
ofstream fout;  ifstream fin;  typedef float td_f; typedef vector<vector<int>> vvi; typedef vector<int> vi; typedef long long LL; typedef long double LD; typedef pair<int, int> ii;  const int inf = 1e9 + 7; const int maxN = 50; const int M = 50; const int N = 50;  int t, n, p; int req[maxN], minim[maxN][maxN], s[maxN][maxN], c[maxN][maxN]; bool graph[maxN][maxN];  bool przeciecie(int i, int j) {   if (minim[1][i] == inf || minim[2][j] == inf)     return false;   if (minim[1][i] >= minim[2][j] && minim[1][i] <= c[2][j])     return true;   if (c[1][i] >= minim[2][j] && c[1][i] <= c[2][j])     return true;   return false; }   bool bpm(bool bpGraph[M][N], int u, bool seen[], int matchR[]) {    for (int v = 0; v < N; v++) {      if (bpGraph[u][v] && !seen[v]) {       seen[v] = true;        if (matchR[v] < 0 || bpm(bpGraph, matchR[v], seen, matchR)) {         matchR[v] = u;         return true;       }     }   }   return false; }   int maxBPM(bool bpGraph[M][N]) {    int matchR[N];     memset(matchR, -1, sizeof(matchR));    int result = 0;    for (int u = 0; u < M; u++) {          bool seen[N];     memset(seen, 0, sizeof(seen));       if (bpm(bpGraph, u, seen, matchR))       result++;   }   return result; }  inline void mriwuckxwx(int &x, int &j, int &a) {   minim[x][j] = min(minim[x][j], a);   c[x][j] = a; }  inline void mrjsyntqkm(int &j, float &weight, int &x, int &a) {   if (s[x][j] >= 0.9 * weight && s[x][j] <= 1.1 * weight)     mriwuckxwx(x, j, a);   weight += req[x];   a++; }  inline void vhltgfzuls(int &i, int &j) {   graph[i][j] = 0;   minim[i][j] = c[i][j] = inf; }  inline void qiaczpmbnt() {   for (int i = (1); i <= ((p)); ++i)     for (int j = (1); j <= ((p)); ++j)       if (przeciecie(i, j)) {         graph[i][j] = 1;     fout << maxBPM(graph) << endl; }  
int main() {   fout.open("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_15_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Mucosolvan/outer_temp/Mucosolvan/A-small-practice_transformation.out");    fin.open("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_15_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Mucosolvan/A-small-practice.in");    int solve = 0;    fin >> t;   for (int test = (1); test <= ((t)); ++test) {     fin >> n >> p;     for (int i = (1); i <= ((n)); ++i) {       fin >> req[i];     }      for (int x = (1); x <= ((n)); ++x)       for (int j = (1); j <= ((p)); ++j) {         minim[x][j] = c[x][j] = inf;       }     for (int i = (1); i <= ((40)); ++i) {       for (int j = (1); j <= ((40)); ++j)         vhltgfzuls(i, j);     }     for (int i = (1); i <= ((n)); ++i) {       for (int j = (1); j <= ((p)); ++j)         fin >> s[i][j];     }      int x;     for (x = (1); x <= ((n)); ++x) {       for (int j = (1); j <= ((p)); ++j) {         td_f weight = req[x];         int a = 1;         while (weight <= 2 * s[x][j])           mrjsyntqkm(j, weight, x, a);       }     }      fout << "Case #" << test << ": ";     if (n == 1) {       int ans = 0;       for (int j = (1); j <= ((p)); ++j) {         if (minim[1][j] != inf)           ans++;       }       fout << ans << endl;     } else       qiaczpmbnt();   }   return solve; }
#include <bits/stdc++.h> #include <bitset> #include <complex> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdlib.h>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std; 
 typedef vector<int> vi; typedef vector<vi> vvi; typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long LL;            typedef unsigned long long ULL;  typedef unsigned uint;  const double pi = acos(-1.0);  const double eps = 1e-11;      const int MAXI = 0x7fffffff; const int dx[] = {1, 0, -1, 0}; const int dy[] = {0, 1, 0, -1}; const char dz[] = "SENW"; struct debugger {   template <typename T> debugger &operator,(const T &v) {     cerr << v << " ";     return *this;   } } dbg;  void debugarr(int *arr, int n) {   cout << "[";   for (int i = 0; i < n; i++)     cout << arr[i] << " ";   cout << "]" << endl; }  int req[110], lb[110], ub[110]; int q[110][110]; inline void gnjncwtstz(int &p, int &i, int &j) {   for (j = 0; j < p; j++) {     scanf("%d", &q[i][j]);     ;   } }  
 int main() {   ios::sync_with_stdio(true);    freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_16_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/lazyBit/A-small-practice.in",           "r", stdin);   ;   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_16_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);   ;    int n, i, j, k, l, m, t, s = 0, d, r, ans, p;   scanf("%d", &t);   ;   int c = 1;   while (t--) {     memset((req), (0), sizeof(req));     memset((lb), (0), sizeof(lb));     memset((ub), (0), sizeof(ub));     memset((q), (0), sizeof(q));     scanf("%d", &n);     ;     scanf("%d", &p);     ;     {       i = 0;       while (i < n) {         scanf("%d", &req[i]);         ;         i++;       }     }     for (i = 0; i < n; i++)       gnjncwtstz(p, i, j);     for (i = 0; i < n; i++) {       sort(q[i], q[i] + p);     }     for (i = 0; i < n; i++) {       double nt = (9 * req[i]) / 10.0;       lb[i] = (int)nt;       if (lb[i] < nt)         lb[i]++;       ub[i] = (11 * req[i]) / 10;     }     int ns;     ans = 0;     bool vis[52][52];     memset((vis), (0), sizeof(vis));      for (i = 0; i < n; i++) {       for (j = 0; j < p; j++) {         if (q[i][j] < lb[i])           continue;         ns = q[i][j] / lb[i];         int mx = q[i][j] / ub[i];         if (mx * ub[i] < q[i][j]) {           mx++;         }         swap(mx, ns);         while (ns <= mx) {           bool f = 1;             vector<pair<int, int>> v;           v.clear();           for (int m = i + 1; m < n; m++) {             f = 0;             for (int o = 0; o < p; o++) {                   if (!vis[m][o] && ns * lb[m] <= q[m][o] &&                   ns * ub[m] >= q[m][o]) {                 vis[m][o] = true;                 v.push_back(make_pair(m, o));                 f = 1;                 break;               }             }              if (f == 0)               break;           }           if (f == 0) {             for (int o = 0; o < v.size(); o++) {               vis[v[o].first][v[o].second] = false;             }           } else {             ans++;              break;           }           ns++;         }       }       break;     }     printf("Case #%d: %d\n", c++, ans);   }   return (0); }
#include <bitset> #include <cctype> #include <climits> #include <complex> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <unordered_map>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std; 
typedef vector<int> vi;  typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long LL;           typedef unsigned long long ULL;  typedef unsigned uint;  const double pi = acos(-1.0);  const double eps = 1e-11;      const int MAXI = 0x7fffffff; const int dx[] = {1, 0, -1, 0}; const int dy[] = {0, 1, 0, -1}; const char dz[] = "SENW"; struct debugger {  } dbg;  int req[110], lb[110], ub[110]; int q[110][110]; 
int main() {    freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_16_Usenix_RF_1.0_True_MCTS_Classic_True/try/lazyBit/A-small-practice.in",           "r", stdin);   ;   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_16_Usenix_RF_1.0_True_MCTS_Classic_True/try/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);   ;    int n, i, j, k, tc, m, t, s = 0, d, r, ans, p;   scanf("%d", &t);   ;   int c = 1;   for (; t--;) {     memset((req), (0), sizeof(req));     memset((lb), (0), sizeof(lb));     memset((ub), (0), sizeof(ub));     memset((q), (0), sizeof(q));     scanf("%d", &n);     ;     scanf("%d", &p);     ;     for (i = 0; i < n; i++) {       scanf("%d", &req[i]);       ;     }     for (i = 0; i < n; i++) {       for (j = 0; j < p; j++) {         scanf("%d", &q[i][j]);         ;       }     }     for (i = 0; i < n; i++)       sort(q[i], q[i] + p);      {       i = 0;       while (i < n) {         double nt = (9 * req[i]) / 10.0;         lb[i] = (int)nt;         if (lb[i] < nt)           lb[i]++;         ub[i] = (11 * req[i]) / 10;         i++;       }     }     int ns;     ans = 0;     bool vis[52][52];     memset((vis), (0), sizeof(vis));      for (i = 0; i < n; i++) {       for (j = 0; j < p; j++) {         if (q[i][j] < lb[i])           continue;         ns = q[i][j] / lb[i];         int mx = q[i][j] / ub[i];         if (mx * ub[i] < q[i][j])           mx++;          swap(mx, ns);         for (; ns <= mx;) {           bool f = 1;                     vector<pair<int, int>> v;           v.clear();           for (int m = i + 1; m < n; m++) {             f = 0;             for (int o = 0; o < p; o++) {                            if (!vis[m][o] && ns * lb[m] <= q[m][o] &&                   ns * ub[m] >= q[m][o]) {                 vis[m][o] = 1;                 v.push_back(make_pair(m, o));                 f = 1;                 break;               }             }              if (f == 0)               break;           }           if (f == 0) {             for (int o = 0; o < v.size(); o++)               vis[v[o].first][v[o].second] = false;            } else {             ans++;              break;           }           ns++;         }       }       break;     }     printf("Case #%d: %d\n", c++, ans);   }   return (0); }
#include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <complex> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <unordered_map>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std;  
typedef double td_d; typedef long double LD; typedef set<int> si; typedef vector<int> VI; typedef vector<VI> vvi; typedef pair<int, int> pii; typedef vector<pii> vii; typedef vector<string> vs;  typedef long long ll;           typedef unsigned long long ULL;  typedef unsigned uint;    struct debugger {   template <typename T> debugger &get(const T &v) {     cerr << v << " ";     return *this;   } };  void solve(int *arr, int n) {   printf("[");   for (int i = 0; i < n; i++)     printf("%d ", arr[i]);   printf("]\n"); }  int req[110], lb[110], ub[110]; int q[110][110]; 
int main() {   ios::sync_with_stdio(true);    freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_16_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/lazyBit/A-small-practice.in",           "r", stdin);   ;   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_16_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);   ;    int n, i, j, y, b, m, t, s = 0, d, r, ans, p;   scanf("%d", &t);   ;   int c = 1;   while (t--) {     memset((req), (0), sizeof(req));     memset((lb), (0), sizeof(lb));     memset((ub), (0), sizeof(ub));     memset((q), (0), sizeof(q));     scanf("%d", &n);     ;     scanf("%d", &p);     ;     for (i = 0; i < n; i++) {       scanf("%d", &req[i]);       ;     }     for (i = 0; i < n; i++) {       for (j = 0; j < p; j++) {         scanf("%d", &q[i][j]);         ;       }     }     for (i = 0; i < n; i++) {       sort(q[i], q[i] + p);     }     for (i = 0; i < n; i++) {       td_d nt = (9 * req[i]) / 10.0;       lb[i] = (int)nt;       if (lb[i] < nt)         lb[i]++;       ub[i] = (11 * req[i]) / 10;     }     int ns;     ans = 0;     bool vis[52][52];     memset((vis), (0), sizeof(vis));      for (i = 0; i < n; i++) {       for (j = 0; j < p; j++) {         if (q[i][j] < lb[i])           continue;         ns = q[i][j] / lb[i];         int mx = q[i][j] / ub[i];         if (mx * ub[i] < q[i][j]) {           mx++;         }         swap(mx, ns);         while (ns <= mx) {           bool f = true;                    vector<pair<int, int>> v;           v.clear();           for (int m = i + 1; m < n; m++) {             f = false;             for (int o = 0; o < p; o++) {                             if (!vis[m][o] && ns * lb[m] <= q[m][o])                 if (ns * ub[m] >= q[m][o]) {                   vis[m][o] = true;                   v.push_back(make_pair(m, o));                   f = true;                   break;                 }             }              if (f == 0)               break;           }           if (f == 0) {             for (int o = 0; o < v.size(); o++) {               vis[v[o].first][v[o].second] = false;             }           } else {             ans++;              break;           }           ns++;         }       }       break;     }     printf("Case #%d: %d\n", c++, ans);   }   return (0); }
#include <bitset> #include <cctype> #include <climits> #include <complex> #include <deque> #include <iomanip> #include <iostream> #include <iterator> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <unordered_map>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std;
const int MAXN = 1005;  typedef vector<int> vi;  typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long LL;           typedef unsigned long long ULL;    struct debugger {   template <typename T> debugger &get(const T &v) {     cerr << v << " ";     return *this;   } };  void solve(int *N, int n) {   cout << "[";   for (int i = 0; i < n; i++)     cout << N[i] << " ";   cout << "]" << endl; }  int req[110], lb[110], ub[110]; int q[110][110]; 
int main() {    ;   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_16_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);   ;    int n, i, j, k, l, tc, t, s = 0, d, r, ans, p;   cin >> t;   ;   int c = 1;   while (t--) {     memset((req), (0), sizeof(req));     memset((lb), (0), sizeof(lb));     memset((ub), (0), sizeof(ub));     memset((q), (0), sizeof(q));     cin >> n;     ;     cin >> p;     ;     for (i = 0; i < n; i++) {       cin >> req[i];       ;     }     for (i = 0; i < n; i++) {       for (j = 0; j < p; j++) {         cin >> q[i][j];         ;       }     }     for (i = 0; i < n; i++)       sort(q[i], q[i] + p);      for (i = 0; i < n; i++) {       double nt = (9 * req[i]) / 10.0;       lb[i] = (int)nt;       if (lb[i] < nt)         lb[i]++;       ub[i] = (11 * req[i]) / 10;     }     int ns;     ans = 0;     bool vis[52][52];     memset((vis), (0), sizeof(vis));      for (i = 0; i < n; i++) {       for (j = 0; j < p; j++) {         if (q[i][j] < lb[i])           continue;         ns = q[i][j] / lb[i];         int mx = q[i][j] / ub[i];         if (mx * ub[i] < q[i][j]) {           mx++;         }         swap(mx, ns);         while (ns <= mx) {           int f = 1;                   vector<pair<int, int>> v;           v.clear();           for (int tc = i + 1; tc < n; tc++) {             f = 0;             int o;             for (o = 0; o < p; o++) {                           if (!vis[tc][o] && ns * lb[tc] <= q[tc][o] &&                   ns * ub[tc] >= q[tc][o]) {                 vis[tc][o] = 1;                 v.push_back(make_pair(tc, o));                 f = 1;                 break;               }             }              if (f == 0)               break;           }           if (f == 0) {             for (int o = 0; o < v.size(); o++) {               vis[v[o].first][v[o].second] = false;             }           } else {             ans++;              break;           }           ns++;         }       }       break;     }     printf("Case #%d: %d\n", c++, ans);   }   return (0); }
#include <algorithm> #include <bits/stdc++.h> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <cstring> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <math.h> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility>  using namespace std; 
ifstream fin;  ofstream fout;  int solve(int cc) {   int ret_val = 1;   int n, p, r[55], q[55][55];   fin >> n >> p;   for (int get = 0; get < n; get++) {     fin >> r[get];   }   for (int get = 0; get < n; get++) {     for (int j = 0; j < p; j++) {       fin >> q[get][j];     }   }   int sol = 0;   if (n == 1) {     for (int get = 0; get < p; get++) {       int ce = (int)(floor(10.0 / 9.0 * q[0][get] / r[0]) + 1e-5);       int fl = (int)(ceil(10.0 / 11.0 * q[0][get] / r[0]) + 1e-5);        if (fl <= ce) {         sol++;       }     }   } else {     if (n == 2) {       int arr[p];       for (int get = 0; get < p; get++) {         arr[get] = get;       }       do {          int tmp_sol = 0;         for (int get = 0; get < p; get++) {           int ce1 = (int)(floor(10.0 / 9.0 * q[0][get] / r[0]) + 1e-5);           int fl1 = (int)(ceil(10.0 / 11.0 * q[0][get] / r[0]) + 1e-5);           int ce2 = (int)(floor(10.0 / 9.0 * q[1][arr[get]] / r[1]) + 1e-5);           int fl2 = (int)(ceil(10.0 / 11.0 * q[1][arr[get]] / r[1]) + 1e-5);            if (fl1 <= ce1 && fl2 <= ce2) {             if ((fl1 <= ce2 && ce1 >= fl2) || (fl2 <= ce1 && fl1 <= ce2)) {               tmp_sol++;             }           }         }         sol = max(sol, tmp_sol);       } while (next_permutation(arr, arr + p));     }   }   fout << "Case #" << cc << ": " << sol << endl;   return ret_val; }  
int main() {   fin.open("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_17_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Thanabhat/A-small-practice.in");    fout.open("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_17_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Thanabhat/outer_temp/Thanabhat/A-small-practice_transformation.out");    int ret_val = 0;   int t;   fin >> t;   for (int get = 0; get < t; get++) {     solve(get + 1);   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <cstring> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <math.h> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility>  using namespace std; 
ifstream fin;  ofstream fout;  int solve(int cc) {   int ret_val = 1;   int n, p, r[55], q[55][55];   fin >> n >> p;   for (int get = 0; get < n; get++) {     fin >> r[get];   }   for (int get = 0; get < n; get++) {     for (int j = 0; j < p; j++) {       fin >> q[get][j];     }   }   int sol = 0;   if (n == 1) {     for (int get = 0; get < p; get++) {       int ce = (int)(floor(10.0 / 9.0 * q[0][get] / r[0]) + 1e-5);       int fl = (int)(ceil(10.0 / 11.0 * q[0][get] / r[0]) + 1e-5);        if (fl <= ce) {         sol++;       }     }   } else {     if (n == 2) {       int arr[p];       for (int get = 0; get < p; get++) {         arr[get] = get;       }       do {          int tmp_sol = 0;         for (int get = 0; get < p; get++) {           int ce1 = (int)(floor(10.0 / 9.0 * q[0][get] / r[0]) + 1e-5);           int fl1 = (int)(ceil(10.0 / 11.0 * q[0][get] / r[0]) + 1e-5);           int ce2 = (int)(floor(10.0 / 9.0 * q[1][arr[get]] / r[1]) + 1e-5);           int fl2 = (int)(ceil(10.0 / 11.0 * q[1][arr[get]] / r[1]) + 1e-5);            if (fl1 <= ce1 && fl2 <= ce2) {             if ((fl1 <= ce2 && ce1 >= fl2) || (fl2 <= ce1 && fl1 <= ce2)) {               tmp_sol++;             }           }         }         sol = max(sol, tmp_sol);       } while (next_permutation(arr, arr + p));     }   }   fout << "Case #" << cc << ": " << sol << endl;   return ret_val; }  
int main() {   fin.open("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_17_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Thanabhat/A-small-practice.in");    fout.open("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_17_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Thanabhat/outer_temp/Thanabhat/A-small-practice_transformation.out");    int ret_val = 0;   int t;   fin >> t;   for (int get = 0; get < t; get++) {     solve(get + 1);   }   return ret_val; }
#include <algorithm> #include <bitset> #include <cassert> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <functional> #include <iostream> #include <iterator> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility>  using namespace std; 
inline void tjdkctroln(int &tmp_sol) { tmp_sol++; }  inline void dtysrspnce(int q[55][55], int &i, int &j) {   cin >> q[i][j];   j++; }  int solve(int cc) {   int n, p, r[55], q[55][55];   cin >> n >> p;   for (int i = 0; i < n; i++) {     cin >> r[i];   }   for (int i = 0; i < n; i++) {     {       int j = 0;       while (j < p)         dtysrspnce(q, i, j);     }   }    int sol = 0;   if (n == 1) {     for (int i = 0; i < p; i++) {       int ce = (int)(floor(10.0 / 9.0 * q[0][i] / r[0]) + 1e-5);       int fl = (int)(ceil(10.0 / 11.0 * q[0][i] / r[0]) + 1e-5);        if (fl <= ce) {         sol++;       }     }   } else if (n == 2) {     int arr[p];     for (int i = 0; i < p; i++) {       arr[i] = i;     }     do {        int tmp_sol = 0;       for (int i = 0; i < p; i++) {         int ce1 = (int)(floor(10.0 / 9.0 * q[0][i] / r[0]) + 1e-5);         int fl1 = (int)(ceil(10.0 / 11.0 * q[0][i] / r[0]) + 1e-5);         int ce2 = (int)(floor(10.0 / 9.0 * q[1][arr[i]] / r[1]) + 1e-5);         int fl2 = (int)(ceil(10.0 / 11.0 * q[1][arr[i]] / r[1]) + 1e-5);          if (fl1 <= ce1)           if (fl2 <= ce2) {             if ((fl1 <= ce2 && ce1 >= fl2) || (fl2 <= ce1 && fl1 <= ce2))               tjdkctroln(tmp_sol);           }       }       sol = max(sol, tmp_sol);     } while (next_permutation(arr, arr + p));   }   printf("Case #%d: %d\n", cc, sol);   return 1; }  inline void rcgtnqdapc(int &i) { solve(i + 1); }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_17_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/Thanabhat/outer_temp/Thanabhat/A-small-practice_transformation.out",           "w", stdout);    int get;   cin >> get;   for (int i = 0; i < get; i++)     rcgtnqdapc(i);   return 0; }
#include <algorithm> #include <bitset> #include <cassert> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <functional> #include <iostream> #include <iterator> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stdlib.h> #include <string> #include <utility>  using namespace std; 
int get(int cc) {   int n, p, r[55], q[55][55];   cin >> n >> p;   for (int i = 0; i < n; i++) {     cin >> r[i];   }   for (int i = 0; i < n; i++) {     for (int j = 0; j < p; j++) {       cin >> q[i][j];     }   }    int sol = 0;   if (n == 1) {     for (int i = 0; i < p; i++) {       int ce = (int)(floor(10.0 / 9.0 * q[0][i] / r[0]) + 1e-5);       int fl = (int)(ceil(10.0 / 11.0 * q[0][i] / r[0]) + 1e-5);        if (fl <= ce) {         sol++;       }     }   } else if (n == 2) {     int arr[p];     int i;     for (i = 0; i < p; i++) {       arr[i] = i;     }     do {        int tmp_sol = 0;       for (int i = 0; i < p; i++) {         int ce1 = (int)(floor(10.0 / 9.0 * q[0][i] / r[0]) + 1e-5);         int fl1 = (int)(ceil(10.0 / 11.0 * q[0][i] / r[0]) + 1e-5);         int ce2 = (int)(floor(10.0 / 9.0 * q[1][arr[i]] / r[1]) + 1e-5);         int fl2 = (int)(ceil(10.0 / 11.0 * q[1][arr[i]] / r[1]) + 1e-5);          if (fl1 <= ce1 && fl2 <= ce2) {           if ((fl1 <= ce2 && ce1 >= fl2) || (fl2 <= ce1 && fl1 <= ce2)) {             tmp_sol++;           }         }       }       sol = max(sol, tmp_sol);     } while (next_permutation(arr, arr + p));   }   cout << "Case #" << cc << ": " << sol << endl;   return 1; }  
int main() {   int t;   cin >> t;   for (int i = 0; i < t; i++) {     get(i + 1);   }   return 0; }
#include <bits/stdc++.h> #include <fstream> #include <iomanip> #include <iostream>  using namespace std; 
ofstream fout;  typedef double td_d;  const int inf = 1e8; const int N = 77;  bool check_90(long long have, long long need) {   return have * 100 >= 90 * need; }  bool check_110(long long have, long long need) {   return have * 100 <= 110 * need; }  int get_l(int have, int need) {   int l = 0, r = inf;   while (r - l > 1) {     int s = (l + r) / 2;     if (check_90(have, 1LL * need * s)) {       l = s;     } else       r = s;   }   return l; }  int get_r(int have, int need) {   int l = 0, r = inf;   while (r - l > 1) {     int s = (l + r) / 2;     if (check_110(have, 1LL * need * s)) {       r = s;     } else {       l = s;     }   }   return r; }  int need[N]; int have[N][N]; int p[N];  inline void yyzheydbux(int &ans) { ++ans; }  inline void roghlhsnrf(int &ans) { yyzheydbux(ans); }  inline void nsvdyztwey(int &cur) { ++cur; }  
int main() {   ios::sync_with_stdio(false);    fout.open("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_18_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/fragusbot/outer_temp/fragusbot/A-small-practice_transformation.out");    int v;   scanf("%d", &v);   for (int cc = 1; cc <= v; ++cc) {     td_d begt = clock();     fout << "Case #" << cc << ": ";     int n, solve;     scanf("%d %d", &n, &solve);     for (int i = 0; i < n; ++i) {       scanf("%d", need + i);     }     for (int i = 0; i < n; ++i) {       for (int j = 0; j < solve; ++j) {         scanf("%d", have[i] + j);       }     }     if (n == 1) {       int ans = 0;       for (int i = 0; i < solve; ++i) {         int l = get_l(have[0][i], need[0]);         int r = get_r(have[0][i], need[0]);         swap(l, r);         if (l <= r)           roghlhsnrf(ans);       }       fout << ans << "\n";       continue;     }     for (int i = 0; i < solve; ++i) {       p[i] = i;     }     int ans = 0;     do {       int cur = 0;       for (int i = 0; i < solve; ++i) {         int get = get_l(have[0][i], need[0]);         int r0 = get_r(have[0][i], need[0]);         swap(get, r0);         if (get > r0) {           continue;         }         int l1 = get_l(have[1][p[i]], need[1]);         int r1 = get_r(have[1][p[i]], need[1]);         swap(l1, r1);         if (l1 > r1) {           continue;         }         int l = max(get, l1);         int r = min(r0, r1);         if (l <= r)           nsvdyztwey(cur);       }       ans = max(ans, cur);     } while (next_permutation(p, p + solve));     fout << ans << "\n";     fprintf(stderr, "case %d solved in %.3f\n", cc,             (clock() - begt) / CLOCKS_PER_SEC);   } }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <vector>  using namespace std; 
const int mod = 1000000007; typedef long double ld; typedef long long LL; typedef unsigned long long ull; typedef long double LD; typedef set<int> si; typedef vector<vector<int>> vvi;  const int inf = 1e8; const int N = 77;  bool check_90(long long have, long long need) {   return have * 100 >= 90 * need; }  bool check_110(long long have, long long need) {   return have * 100 <= 110 * need; }  int get_l(int have, int need) {   int l = 0, r = inf;   while (r - l > 1) {     int s = (l + r) / 2;     if (check_90(have, 1LL * need * s)) {       l = s;     } else {       r = s;     }   }   return l; }  int get_r(int have, int need) {   int l = 0, r = inf;   for (; r - l > 1;) {     int s = (l + r) / 2;     if (check_110(have, 1LL * need * s)) {       r = s;     } else {       l = s;     }   }   return r; }  int need[N]; int have[N][N]; int p[N];  inline void tftleesaka(int &ans) { ++ans; }  inline void eytasqlybu(int &i) { scanf("%d", need + i); }  inline void idcsgbnymu(int &cur) { ++cur; }  
int main() {    freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_18_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/fragusbot/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_18_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/fragusbot/outer_temp/fragusbot/A-small-practice_transformation.out",           "w", stdout);   int tt;   scanf("%d", &tt);   for (int cc = 1; cc <= tt; ++cc) {     double begt = clock();     printf("Case #%d: ", cc);     int n, m;     scanf("%d %d", &n, &m);     for (int i = 0; i < n; ++i) {       eytasqlybu(i);     }     for (int i = 0; i < n; ++i) {       for (int j = 0; j < m; ++j) {         scanf("%d", have[i] + j);       }     }     if (n == 1) {       int ans = 0;       {         int i = 0;         while (i < m) {           int l = get_l(have[0][i], need[0]);           int r = get_r(have[0][i], need[0]);           swap(l, r);           if (l <= r)             tftleesaka(ans);           ++i;         }       }       printf("%d\n", ans);       continue;     }     for (int i = 0; i < m; ++i) {       p[i] = i;     }     int ans = 0;     do {       int cur = 0;       for (int i = 0; i < m; ++i) {         int l0 = get_l(have[0][i], need[0]);         int r0 = get_r(have[0][i], need[0]);         swap(l0, r0);         if (l0 > r0) {           continue;         }         int l1 = get_l(have[1][p[i]], need[1]);         int r1 = get_r(have[1][p[i]], need[1]);         swap(l1, r1);         if (l1 > r1) {           continue;         }         int l = max(l0, l1);         int r = min(r0, r1);         if (l <= r) {           idcsgbnymu(cur);         }       }       ans = max(ans, cur);     } while (next_permutation(p, p + m));     printf("%d\n", ans);     fprintf(stderr, "case %d solved in %.3f\n", cc,             (clock() - begt) / CLOCKS_PER_SEC);   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <utility> #include <vector>  using namespace std; 
ofstream fout;  typedef double td_d;  const double eps = 1e-9;  const int inf = 1e8; const int N = 77;  bool check_90(long long have, long long need) {   return have * 100 >= 90 * need; }  bool check_110(long long have, long long need) {   return have * 100 <= 110 * need; }  int get_l(int have, int need) {   int l = 0, get = inf;   for (; get - l > 1;) {     int s = (l + get) / 2;     if (check_90(have, 1LL * need * s)) {       l = s;     } else {       get = s;     }   }   return l; }  int get_r(int have, int need) {   int l = 0, get = inf;   while (get - l > 1) {     int s = (l + get) / 2;     if (check_110(have, 1LL * need * s)) {       get = s;     } else {       l = s;     }   }   return get; }  int need[N]; int have[N][N]; int p[N];  
int main() {   fout.open("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_18_Usenix_RF_1.0_True_MCTS_Classic_True/WCG/fragusbot/outer_temp/fragusbot/A-small-practice_transformation.out");    int tt;   scanf("%d", &tt);   for (int tc = 1; tc <= tt; ++tc) {     td_d c = clock();     fout << "Case #" << tc << ": ";     int n, m;     scanf("%d %d", &n, &m);     for (int i = 0; i < n; ++i) {       scanf("%d", need + i);     }     for (int i = 0; i < n; ++i) {       for (int j = 0; j < m; ++j) {         scanf("%d", have[i] + j);       }     }     if (n == 1) {       int ans = 0;       for (int i = 0; i < m; ++i) {         int l = get_l(have[0][i], need[0]);         int get = get_r(have[0][i], need[0]);         swap(l, get);         if (l <= get) {           ++ans;         }       }       fout << ans << "\n";       continue;     }     for (int i = 0; i < m; ++i) {       p[i] = i;     }     int ans = 0;     do {       int cur = 0;        for (int i = 0; i < m; ++i) {         int l0 = get_l(have[0][i], need[0]);         int r0 = get_r(have[0][i], need[0]);         swap(l0, r0);         if (l0 > r0) {           continue;         }         int l1 = get_l(have[1][p[i]], need[1]);         int r1 = get_r(have[1][p[i]], need[1]);         swap(l1, r1);         if (l1 > r1) {           continue;         }         int l = max(l0, l1);         int get = min(r0, r1);         if (l <= get) {           ++cur;         }       }       ans = max(ans, cur);     } while (next_permutation(p, p + m));     fout << ans << "\n";     fprintf(stderr, "case %d solved in %.3f\n", tc,             (clock() - c) / CLOCKS_PER_SEC);   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <set> #include <utility> #include <vector>  using namespace std; 
const int INF = 1000000000; typedef long long ll; typedef unsigned long long ull; typedef pair<int, int> pii; typedef pair<int, int> PII; typedef vector<int> VI; typedef long double LD; typedef set<int> si; typedef vector<vector<int>> vvi;  const int inf = 1e8; const int N = 77;  bool check_90(long long have, long long need) {   return have * 100 >= 90 * need; }  bool check_110(long long have, long long need) {   return have * 100 <= 110 * need; }  int get_l(int have, int need) {   int l = 0, r = inf;   for (; r - l > 1;) {     int s = (l + r) / 2;     if (check_90(have, 1LL * need * s)) {       l = s;     } else {       r = s;     }   }   return l; }  int get_r(int have, int need) {   int l = 0, r = inf;   while (r - l > 1) {     int s = (l + r) / 2;     if (check_110(have, 1LL * need * s)) {       r = s;     } else {       l = s;     }   }   return r; }  int need[N]; int have[N][N]; int p[N];  inline void lywmmjlech(int &n) {   int i = 0;   while (i < n) {     scanf("%d", need + i);     ++i;   } }  inline void mhjgquywry(int &ans) { ++ans; }  
int main() {   ios::sync_with_stdio(false);    freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_18_Usenix_RF_1.0_True_MCTS_Classic_True/bennikartefla/fragusbot/A-small-practice.in",           "r", stdin);    int t;   scanf("%d", &t);   {     int cc = 1;     while (cc <= t) {       double begt = clock();       printf("Case #%d: ", cc);       int n, m;       scanf("%d %d", &n, &m);       lywmmjlech(n);       for (int i = 0; i < n; ++i) {         for (int j = 0; j < m; ++j) {           scanf("%d", have[i] + j);         }       }       if (n == 1) {         int ans = 0;         {           int i = 0;           while (i < m) {             int l = get_l(have[0][i], need[0]);             int r = get_r(have[0][i], need[0]);             swap(l, r);             if (l <= r)               mhjgquywry(ans);             ++i;           }         }         printf("%d\n", ans);         ++cc;         continue;       }       for (int i = 0; i < m; ++i) {         p[i] = i;       }       int ans = 0;       do {         int cur = 0;          for (int i = 0; i < m; ++i) {           int l0 = get_l(have[0][i], need[0]);           int r0 = get_r(have[0][i], need[0]);           swap(l0, r0);           if (l0 > r0) {             continue;           }           int l1 = get_l(have[1][p[i]], need[1]);           int r1 = get_r(have[1][p[i]], need[1]);           swap(l1, r1);           if (l1 > r1) {             continue;           }           int l = max(l0, l1);           int r = min(r0, r1);           if (l <= r) {             ++cur;           }         }         ans = max(ans, cur);       } while (next_permutation(p, p + m));       printf("%d\n", ans);       fprintf(stderr, "case %d solved in %.3f\n", cc,               (clock() - begt) / CLOCKS_PER_SEC);       ++cc;     }   }   return 0; }
#include <algorithm> #include <bitset> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <iostream> #include <map> #include <queue> #include <set> #include <string> #include <vector> #pragma comment(linker, "/STACK:256000000")  using namespace std; 
const int MAXN = 1005;  void get() {}  const int maxN = 60; const int maxL = 2000000; int n, p; int a[maxN]; int b[maxN][maxN];  int q[maxL];  pair<int, int> c[maxN][maxN]; bool used[maxN][maxN];  pair<int, int> getPackages(int value, int t) {   int r = (value * 10) / (9 * t);   int l = (value * 10 + 11 * t - 1) / (11 * t);    return make_pair(l, r); }  inline void ytvxlxtlmj(int &i, int &j) {   cin >> b[i][j];   c[i][j] = getPackages(b[i][j], a[i]);   {     int k = c[i][j].first;     while (k <= c[i][j].second) {       q[k] = true;       ++k;     }   } }  inline void suijhxrkjj(int &i, int &j) { used[i][j] = false; }  inline void csewuctpbe(int &i) { cin >> a[i]; }  void solve(int test) {   cin >> n >> p;   for (int i = 0; i < n; ++i)     csewuctpbe(i);    for (int i = 0; i < maxL; ++i) {     q[i] = 0;   }    for (int i = 0; i < n; ++i) {     for (int j = 0; j < p; ++j)       ytvxlxtlmj(i, j);   }    {     int i = 0;     while (i < n) {       for (int j = 0; j < p; ++j)         suijhxrkjj(i, j);       ++i;     }   }    int res = 0;   for (int k = 0; k < maxL; ++k) {     if (!q[k]) {       continue;     }     while (true) {       bool good = 1;       for (int i = 0; i < n; ++i) {         int have = false;         for (int j = 0; j < p; ++j) {           if (used[i][j]) {             continue;           }           if (k >= c[i][j].first && k <= c[i][j].second) {             have = true;             break;           }         }         if (!have) {           good = false;           break;         }       }       if (!good) {         break;       }       ++res;       for (int i = 0; i < n; ++i) {         for (int j = 0; j < p; ++j) {           if (used[i][j]) {             continue;           }           if (k >= c[i][j].first && k <= c[i][j].second) {             used[i][j] = 1;             break;           }         }       }     }   }    printf("Case #%d: %d\n", test, res); }  inline void dhgfaymlft() { get(); }  
int main(int argc, char *argv[]) {    freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_19_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/sdya/outer_temp/sdya/A-small-practice_transformation.out",           "w", stdout);    int left_bound, right_bound;     int t;   cin >> t;   left_bound = 1, right_bound = t;   for (int i = 1; i <= t; ++i) {     if (i >= left_bound && i <= right_bound) {       solve(i);     } else       dhgfaymlft();     cerr << i << ": " << clock() << endl;   }    return 0; }
#include <algorithm> #include <bitset> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <iomanip> #include <iostream> #include <map> #include <queue> #include <set> #include <string> #include <utility> #include <vector> #pragma comment(linker, "/STACK:256000000")  using namespace std; 
typedef set<int> si; typedef long double ld; typedef long long ll; typedef long long LL; typedef pair<int, int> PII; typedef vector<int> VI; typedef vector<vector<int>> vvi;  void get() {}  const int maxN = 60; const int maxL = 2000000; int n, p; int a[maxN]; int b[maxN][maxN];  int q[maxL];  pair<int, int> c[maxN][maxN]; bool used[maxN][maxN];  pair<int, int> getPackages(int value, int t) {   int r = (value * 10) / (9 * t);   int x = (value * 10 + 11 * t - 1) / (11 * t);    return make_pair(x, r); }  void solve(int test) {   cin >> n >> p;   for (int i = 0; i < n; ++i) {     cin >> a[i];   }    for (int i = 0; i < maxL; ++i) {     q[i] = 0;   }    for (int i = 0; i < n; ++i) {     for (int j = 0; j < p; ++j) {       cin >> b[i][j];       c[i][j] = getPackages(b[i][j], a[i]);       for (int k = c[i][j].first; k <= c[i][j].second; ++k) {         q[k] = true;       }     }   }    for (int i = 0; i < n; ++i) {     for (int j = 0; j < p; ++j) {       used[i][j] = false;     }   }    int res = 0;   for (int k = 0; k < maxL; ++k) {     if (!q[k]) {       continue;     }     for (; true;) {       int good = true;       for (int i = 0; i < n; ++i) {         bool have = false;         for (int j = 0; j < p; ++j) {           if (used[i][j]) {             continue;           }           if (k >= c[i][j].first)             if (k <= c[i][j].second) {               have = true;               break;             }         }         if (!have) {           good = false;           break;         }       }       if (!good) {         break;       }       ++res;       for (int i = 0; i < n; ++i) {         for (int j = 0; j < p; ++j) {           if (used[i][j]) {             continue;           }           if (k >= c[i][j].first)             if (k <= c[i][j].second) {               used[i][j] = true;               break;             }         }       }     }   }    cout << "Case #" << test << ": " << res << "\n"; }  
int main(int y, char *argv[]) {   ios::sync_with_stdio(false);    int left_bound, right_bound;      int t;   cin >> t;   left_bound = 1, right_bound = t;   for (int i = 1; i <= t; ++i) {     if (i >= left_bound && i <= right_bound) {       solve(i);     } else {       get();     }     cerr << i << ": " << clock() << endl;   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stdio.h> #include <string> #include <utility> #include <vector> #pragma comment(linker, "/STACK:256000000")  using namespace std;
const int MOD = 1000000007; const int mod = 1000000007; typedef unsigned long long ull; typedef vector<vector<int>> vvi; typedef long long ll; typedef pair<int, int> pii; typedef pair<int, int> PII; typedef vector<int> VI; typedef long double LD; typedef set<int> si;  void get() {}  const int maxN = 60; const int maxL = 2000000; int n, p; int a[maxN]; int b[maxN][maxN];  int d[maxN][maxN]; int q[maxL];  pair<int, int> c[maxN][maxN]; bool used[maxN][maxN];  pair<int, int> getPackages(int value, int t) {   int r = (value * 10) / (9 * t);   int l = (value * 10 + 11 * t - 1) / (11 * t);    return make_pair(l, r); }  inline void hkmfhzzeys(int &k) { q[k] = true; }  void solve(int test) {   scanf("%d %d ", &n, &p);   for (int i = 0; i < n; ++i) {     scanf("%d ", &a[i]);   }    for (int i = 0; i < maxL; ++i)     q[i] = 0;    for (int i = 0; i < n; ++i) {     for (int j = 0; j < p; ++j) {       scanf("%d ", &b[i][j]);       c[i][j] = getPackages(b[i][j], a[i]);       for (int k = c[i][j].first; k <= c[i][j].second; ++k)         hkmfhzzeys(k);     }   }    for (int i = 0; i < n; ++i) {     for (int j = 0; j < p; ++j)       used[i][j] = false;   }    int res = 0;   for (int k = 0; k < maxL; ++k) {     if (!q[k]) {       continue;     }     while (true) {       bool good = true;       for (int i = 0; i < n; ++i) {         bool have = false;         for (int j = 0; j < p; ++j) {           if (used[i][j]) {             continue;           }           if (k >= c[i][j].first)             if (k <= c[i][j].second) {               have = true;               break;             }         }         if (!have) {           good = false;           break;         }       }       if (!good) {         break;       }       ++res;       for (int i = 0; i < n; ++i) {         for (int j = 0; j < p; ++j) {           if (used[i][j]) {             continue;           }           if (k >= c[i][j].first) {             if (k <= c[i][j].second) {               used[i][j] = true;               break;             }           }         }       }     }   }    printf("Case #%d: %d\n", test, res); }  
int main(int argc, char *argv[]) {   ios::sync_with_stdio(false);    freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_19_Usenix_RF_1.0_True_MCTS_Classic_True/bennikartefla/sdya/A-small-practice.in",           "r", stdin);    int left_bound, right_bound;     int t;   scanf("%d ", &t);   left_bound = 1, right_bound = t;   for (int i = 1; i <= t; ++i) {     if (i >= left_bound && i <= right_bound) {       solve(i);     } else {       get();     }     cerr << i << ": " << clock() << endl;   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <iostream> #include <map> #include <queue> #include <set> #include <stdio.h> #include <string> #include <utility> #include <vector> #pragma comment(linker, "/STACK:256000000")  using namespace std;
typedef vector<int> vi; typedef pair<int, int> ii; typedef long long ll; typedef long long LL;  void readData() {}  const int maxN = 60; const int maxL = 2000000; int n, p; int a[maxN]; int b[maxN][maxN];  int d[maxN][maxN]; int q[maxL];  pair<int, int> c[maxN][maxN]; bool used[maxN][maxN];  pair<int, int> getPackages(int value, int ct) {   int r = (value * 10) / (9 * ct);   int l = (value * 10 + 11 * ct - 1) / (11 * ct);    return make_pair(l, r); }  inline void wntjkpjbzy(int &k) { q[k] = true; }  void open(int test) {   scanf("%d %d ", &n, &p);   for (int i = 0; i < n; ++i) {     scanf("%d ", &a[i]);   }    for (int i = 0; i < maxL; ++i) {     q[i] = 0;   }    for (int i = 0; i < n; ++i) {     for (int j = 0; j < p; ++j) {       scanf("%d ", &b[i][j]);       c[i][j] = getPackages(b[i][j], a[i]);       for (int k = c[i][j].first; k <= c[i][j].second; ++k)         wntjkpjbzy(k);     }   }    for (int i = 0; i < n; ++i) {     for (int j = 0; j < p; ++j) {       used[i][j] = false;     }   }    int res = 0;   for (int k = 0; k < maxL; ++k) {     if (!q[k]) {       continue;     }     while (true) {       bool good = true;       for (int i = 0; i < n; ++i) {         int have = false;         for (int j = 0; j < p; ++j) {           if (used[i][j]) {             continue;           }           if (k >= c[i][j].first && k <= c[i][j].second) {             have = true;             break;           }         }         if (!have) {           good = false;           break;         }       }       if (!good) {         break;       }       ++res;       for (int i = 0; i < n; ++i) {         for (int j = 0; j < p; ++j) {           if (used[i][j]) {             continue;           }           if (k >= c[i][j].first && k <= c[i][j].second) {             used[i][j] = true;             break;           }         }       }     }   }    printf("Case #%d: %d\n", test, res); }  
int main(int argc, char *argv[]) {   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_19_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sdya/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_5304486_5697460110360576_19_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sdya/outer_temp/sdya/A-small-practice_transformation.out",           "w", stdout);    int left_bound, right_bound;     int ct;   scanf("%d ", &ct);   left_bound = 1, right_bound = ct;   for (int i = 1; i <= ct; ++i) {     if (i >= left_bound && i <= right_bound) {       open(i);     } else {       readData();     }     cerr << i << ": " << clock() << endl;   }    return 0; }
#include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cstdio> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <queue> #include <set> #include <stdio.h> #include <stdlib.h> using namespace std; 
int tc;  inline void phbjldllfn(int &c, char cake[30][30], int &i) {    if (cake[i - 1][0] != '?' && cake[i][0] == '?') {     for (int j = 0; j < c; j++) {       cake[i][j] = cake[i - 1][j];     }   } }  inline void pgrsawjmvq(int &t) {   int r, c;   cin >> r >> c;   char cake[30][30];   for (int i = 0; i < r; i++) {     for (int j = 0; j < c; j++) {       cin >> cake[i][j];     }   }   for (int i = 0; i < r; i++) {      for (int j = 1; j < c; j++) {       if (cake[i][j - 1] != '?' && cake[i][j] == '?') {         cake[i][j] = cake[i][j - 1];       }     }      for (int j = c - 2; j >= 0; j--) {       if (cake[i][j + 1] != '?' && cake[i][j] == '?') {         cake[i][j] = cake[i][j + 1];       }     }   }   for (int i = 1; i < r; i++)     phbjldllfn(c, cake, i);   for (int i = r - 1; i >= 0; i--) {      if (cake[i + 1][0] != '?' && cake[i][0] == '?') {       for (int j = 0; j < c; j++) {         cake[i][j] = cake[i + 1][j];       }     }   }   printf("Case #%d:\n", t);   for (int i = 0; i < r; i++) {     for (int j = 0; j < c; j++) {       printf("%c", cake[i][j]);     }     printf("\n");   } }  
int main() {   ios::sync_with_stdio(false);    freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_1_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/4yn/outer_temp/4yn/A-small-practice_transformation.out",           "w", stdout);   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_1_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/4yn/A-small-practice.in",           "r", stdin);   cin >> tc;   for (int t = 1; t <= tc; t++)     pgrsawjmvq(t);   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stdio.h> #include <stdlib.h> #include <utility> #include <vector> using namespace std; 
int tc;  
int main() {   cin >> tc;   for (int t = 1; t <= tc; t++) {     int r, c;     cin >> r >> c;     char cake[30][30];     for (int i = 0; i < r; i++) {       for (int j = 0; j < c; j++) {         cin >> cake[i][j];       }     }     for (int i = 0; i < r; i++) {        for (int j = 1; j < c; j++) {         if (cake[i][j - 1] != '?' && cake[i][j] == '?') {           cake[i][j] = cake[i][j - 1];         }       }        for (int j = c - 2; j >= 0; j--) {         if (cake[i][j + 1] != '?' && cake[i][j] == '?') {           cake[i][j] = cake[i][j + 1];         }       }     }     for (int i = 1; i < r; i++) {        if (cake[i - 1][0] != '?' && cake[i][0] == '?') {         for (int j = 0; j < c; j++) {           cake[i][j] = cake[i - 1][j];         }       }     }     for (int i = r - 1; i >= 0; i--) {        if (cake[i + 1][0] != '?' && cake[i][0] == '?') {         for (int j = 0; j < c; j++) {           cake[i][j] = cake[i + 1][j];         }       }     }     cout << "Case #" << t << ":\n";     {       int i = 0;       while (i < r) {         for (int j = 0; j < c; j++) {           cout << cake[i][j];         }         cout << endl;         i++;       }     }   }   return 0; }
#include <bits/stdc++.h> #include <fstream> #include <iostream> #include <utility> #include <vector> using namespace std;
ofstream fout;  const double EPS = 1e-9; typedef long long ll; typedef pair<int, int> pii; typedef vector<int> vi; typedef vector<int> VI; typedef long double LD; typedef vector<vector<int>> vvi;  int tc;  
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_1_Usenix_RF_1.0_True_MCTS_Classic_True/bennikartefla/4yn/outer_temp/4yn/A-small-practice_transformation.out");   ios::sync_with_stdio(false);   cin >> tc;   for (int t = 1; t <= tc; t++) {     int r, c;     cin >> r >> c;     char cake[30][30];     for (int i = 0; i < r; i++) {       for (int j = 0; j < c; j++) {         cin >> cake[i][j];       }     }     for (int i = 0; i < r; i++) {        for (int j = 1; j < c; j++) {         if (cake[i][j - 1] != '?' && cake[i][j] == '?') {           cake[i][j] = cake[i][j - 1];         }       }        for (int j = c - 2; j >= 0; j--) {         if (cake[i][j + 1] != '?' && cake[i][j] == '?') {           cake[i][j] = cake[i][j + 1];         }       }     }     for (int i = 1; i < r; i++) {        if (cake[i - 1][0] != '?' && cake[i][0] == '?') {         for (int j = 0; j < c; j++) {           cake[i][j] = cake[i - 1][j];         }       }     }     for (int i = r - 1; i >= 0; i--) {        if (cake[i + 1][0] != '?' && cake[i][0] == '?') {         for (int j = 0; j < c; j++)           cake[i][j] = cake[i + 1][j];       }     }     fout << "Case #" << t << ":\n";     for (int i = 0; i < r; i++) {       for (int j = 0; j < c; j++) {         fout << cake[i][j];       }       fout << endl;     }   }   return 0; }
#include <bits/stdc++.h> #include <stdio.h> using namespace std; 
typedef long long ll; typedef long long LL;  int tc;  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_1_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/4yn/outer_temp/4yn/A-small-practice_transformation.out",           "w", stdout);   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_1_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/4yn/A-small-practice.in",           "r", stdin);   scanf("%d ", &tc);   for (int t = 1; t <= tc; t++) {     int r, c;     scanf("%d %d ", &r, &c);     char cake[30][30];     for (int i = 0; i < r; i++) {       for (int j = 0; j < c; j++) {         scanf("%c ", &cake[i][j]);       }     }     for (int i = 0; i < r; i++) {        for (int j = 1; j < c; j++) {         if (cake[i][j - 1] != '?' && cake[i][j] == '?') {           cake[i][j] = cake[i][j - 1];         }       }        for (int j = c - 2; j >= 0; j--) {         if (cake[i][j + 1] != '?' && cake[i][j] == '?') {           cake[i][j] = cake[i][j + 1];         }       }     }     for (int i = 1; i < r; i++) {        if (cake[i - 1][0] != '?' && cake[i][0] == '?') {         for (int j = 0; j < c; j++) {           cake[i][j] = cake[i - 1][j];         }       }     }     for (int i = r - 1; i >= 0; i--) {        if (cake[i + 1][0] != '?' && cake[i][0] == '?') {         for (int j = 0; j < c; j++) {           cake[i][j] = cake[i + 1][j];         }       }     }     cout << "Case #" << t << ":\n";     for (int i = 0; i < r; i++) {       for (int j = 0; j < c; j++) {         cout << cake[i][j];       }       cout << endl;     }   }   return 0; }
#include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <cmath> #include <cstdlib> #include <cstring> #include <ctime> #include <fstream> #include <iostream> #include <math.h> #include <sstream> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
typedef unsigned long long ull; typedef long double ld; typedef long long LL; typedef pair<int, int> ii; typedef pair<LL, LL> pll; typedef vector<int> VI; typedef vector<VI> vvi; typedef vector<LL> vll; typedef set<int> si; typedef map<int, int> mii;  const int N = 50; int t, n, m; char a[N][N];  inline void twzaymaome(int &solve) {   for (int b = (1); b <= (int)(m - 1); ++b)     if (a[solve][b] == '?')       a[solve][b] = a[solve][b - 1];   for (int b = (m - 2); b >= (int)(0); --b)     if (a[solve][b] == '?')       a[solve][b] = a[solve][b + 1]; }  
int main() {    freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_2_Usenix_RF_1.0_True_MCTS_Classic_True/WCG/KhaleD/A-small-practice.in",           "r", stdin);    cin >> t;   for (int c = (1); c <= (int)(t); ++c) {     cin >> n >> m;     for (int solve = (0); solve <= (int)(n - 1); ++solve)       cin >> a[solve];      for (int solve = (0); solve <= (int)(n - 1); ++solve)       twzaymaome(solve);      for (int b = (0); b <= (int)(m - 1); ++b) {       for (int solve = (1); solve <= (int)(n - 1); ++solve)         if (a[solve][b] == '?')           a[solve][b] = a[solve - 1][b];       for (int solve = (n - 2); solve >= (int)(0); --solve)         if (a[solve][b] == '?')           a[solve][b] = a[solve + 1][b];     }      printf("Case #%d:\n", c);     for (int solve = (0); solve <= (int)(n - 1); ++solve) {       for (int b = (0); b <= (int)(m - 1); ++b)         printf("%c", a[solve][b]);       puts("");     }   } }  
#include <bits/stdc++.h> #include <iostream> using namespace std; 
typedef long long ll; typedef pair<int, int> PII; typedef pair<ll, ll> pll; typedef vector<int> VI; typedef vector<VI> vvi; typedef vector<ll> vll;  const int N = 50; int t, n, m; char a[N][N];  inline void kruouhtpuk(int &i, int &get) { a[i][get] = a[i][get - 1]; }  inline void ezmfprykmx(int &i, int &get) {   printf("%c", a[i][get]);   ++get; }  
int main() {   ios::sync_with_stdio(false);    scanf("%d", &t);   for (int p = (1); p <= (int)(t); ++p) {     scanf("%d%d", &n, &m);     {       int i = (0);       while (i <= (int)(n - 1)) {         scanf("%s", a[i]);         ++i;       }     }      {       int i = (0);       while (i <= (int)(n - 1)) {         for (int get = (1); get <= (int)(m - 1); ++get)           if (a[i][get] == '?')             kruouhtpuk(i, get);         for (int get = (m - 2); get >= (int)(0); --get)           if (a[i][get] == '?')             a[i][get] = a[i][get + 1];         ++i;       }     }     for (int get = (0); get <= (int)(m - 1); ++get) {       for (int i = (1); i <= (int)(n - 1); ++i)         if (a[i][get] == '?')           a[i][get] = a[i - 1][get];       for (int i = (n - 2); i >= (int)(0); --i)         if (a[i][get] == '?')           a[i][get] = a[i + 1][get];     }      printf("Case #%d:\n", p);     for (int i = (0); i <= (int)(n - 1); ++i) {       {         int get = (0);         while (get <= (int)(m - 1))           ezmfprykmx(i, get);       }       puts("");     }   }   return 0; }  
#include <bits/stdc++.h> #include <iomanip> #include <iostream> using namespace std;
typedef long long ll; typedef pair<int, int> pii; typedef pair<ll, ll> pll; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<ll> vll; typedef set<int> si;  const int N = 50; int t, n, m; char a[N][N];  inline void pdxhmjjqoo(int &i) {   for (int j = (1); j <= (int)(m - 1); ++j)     if (a[i][j] == '?')       a[i][j] = a[i][j - 1];   for (int j = (m - 2); j >= (int)(0); --j)     if (a[i][j] == '?')       a[i][j] = a[i][j + 1]; }  inline void afpypropvi(int &j) {   for (int i = (1); i <= (int)(n - 1); ++i)     if (a[i][j] == '?')       a[i][j] = a[i - 1][j];   for (int i = (n - 2); i >= (int)(0); --i)     if (a[i][j] == '?')       a[i][j] = a[i + 1][j]; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_2_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/KhaleD/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_2_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/KhaleD/outer_temp/KhaleD/A-small-practice_transformation.out",           "w", stdout);   scanf("%d", &t);   for (int test = (1); test <= (int)(t); ++test) {     scanf("%d%d", &n, &m);     for (int i = (0); i <= (int)(n - 1); ++i)       scanf("%s", a[i]);      for (int i = (0); i <= (int)(n - 1); ++i)       pdxhmjjqoo(i);     for (int j = (0); j <= (int)(m - 1); ++j)       afpypropvi(j);      cout << "Case #" << test << ":\n";     for (int i = (0); i <= (int)(n - 1); ++i) {       for (int j = (0); j <= (int)(m - 1); ++j)         cout << a[i][j];       puts("");     }   }   return 0; }  
#include <bits/stdc++.h> using namespace std;
const double eps = 1e-9; const double EPS = 1e-9; const long double PI = 3.1415926535897932384626433832795; typedef unsigned long long ull; typedef long double ld; typedef long long LL; typedef pair<int, int> PII; typedef pair<LL, LL> pll; typedef vector<int> VI; typedef vector<VI> vvi; typedef vector<LL> vll;  const int N = 50; int t, n, x; char a[N][N];  inline void ipfhzcobhr(int &i) {   int T = (0);   while (T <= (int)(x - 1)) {     printf("%c", a[i][T]);     ++T;   } }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_2_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/KhaleD/A-small-practice.in",           "r", stdin);    scanf("%d", &t);   for (int d = (1); d <= (int)(t); ++d) {     scanf("%d%d", &n, &x);     int i;     for (i = (0); i <= (int)(n - 1); ++i)       scanf("%s", a[i]);      for (int i = (0); i <= (int)(n - 1); ++i) {       for (int T = (1); T <= (int)(x - 1); ++T)         if (a[i][T] == '?')           a[i][T] = a[i][T - 1];       for (int T = (x - 2); T >= (int)(0); --T)         if (a[i][T] == '?')           a[i][T] = a[i][T + 1];     }     for (int T = (0); T <= (int)(x - 1); ++T) {       for (int i = (1); i <= (int)(n - 1); ++i)         if (a[i][T] == '?')           a[i][T] = a[i - 1][T];       for (int i = (n - 2); i >= (int)(0); --i)         if (a[i][T] == '?')           a[i][T] = a[i + 1][T];     }      printf("Case #%d:\n", d);     for (int i = (0); i <= (int)(n - 1); ++i) {       ipfhzcobhr(i);       puts("");     }   } }  
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <sstream> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std;
typedef unsigned long long ull; typedef vector<vector<int>> vvi; typedef long double ld; typedef long long ll; typedef pair<int, int> PII; typedef pair<int, int> pii; typedef vector<int> VI; typedef long double LD;  struct Rectangle {   char ch;   int sx;   int sy;   int ex;   int ey;   Rectangle() {}   Rectangle(char a, int b, int c, int d, int e) {     ch = a;     sx = b;     sy = c;     ex = d;     ey = e;   } };  Rectangle r[26 + 1]; char s[25 + 1][25 + 1]; int n, m, v;  bool operator<(const Rectangle &a, const Rectangle &b) {   return a.sx < b.sx || (a.sx == b.sx && a.sy < b.sy); }  bool intersect(const Rectangle &a, const Rectangle &b) {   return !(a.ex < b.sx || a.sx > b.ex || a.ey < b.sy || a.sy > b.ey) &&          !(a.sx > b.sx && a.ex < b.ex && a.sy > b.sy && a.ey < b.ey); }  bool intersect(const Rectangle &a, int p) {   int i;   for (i = v; i < 26; i++) {     if ((i != p) && (intersect(a, r[i]) == true)) {       return true;     }   }   return false; }  inline void zjvwaeoyqs(int &i, int &j) {   r[v].sx = min(r[v].sx, i);   r[v].sy = min(r[v].sy, j);   r[v].ex = max(r[v].ex, i);   r[v].ey = max(r[v].ey, j); }  
int main() {   ios::sync_with_stdio(false);    int c, t, i, j, x;   cin >> t;   for (c = 0; c < t; c++) {     memset(r, -1, sizeof(r));     cin >> n >> m;     for (i = 0; i < n; i++) {       cin >> s[i];       for (j = 0; j < m; j++) {         if (isupper(s[i][j])) {           v = (int)(s[i][j] - 'A');           if ((r[v].sx == -1) && (r[v].ex == -1) && (r[v].sy == -1) &&               (r[v].ey == -1)) {             r[v].ch = s[i][j];             r[v].sx = i;             r[v].sy = j;             r[v].ex = i;             r[v].ey = j;           } else             zjvwaeoyqs(i, j);         }       }     }     sort(r, r + 26);     for (v = 0; v < 26; v++) {       if ((r[v].sx != -1) && (r[v].sy != -1) && (r[v].ex != -1) &&           (r[v].ey != -1)) {         break;       }     }     for (i = v; i < 26; i++) {       while (           (r[i].sx - 1 >= 0) &&           (intersect(Rectangle(r[i].ch, r[i].sx - 1, r[i].sy, r[i].ex, r[i].ey),                      i) == false)) {         r[i].sx--;       }       while (           (r[i].sy - 1 >= 0) &&           (intersect(Rectangle(r[i].ch, r[i].sx, r[i].sy - 1, r[i].ex, r[i].ey),                      i) == false)) {         r[i].sy--;       }       while ((r[i].ex + 1 < n) &&              (intersect(Rectangle(r[i].ch, r[i].sx + 1, r[i].sy, r[i].ex + 1,                                   r[i].ey),                         i) == false)) {         r[i].ex++;       }       while (           (r[i].ey + 1 < m) &&           (intersect(Rectangle(r[i].ch, r[i].sx, r[i].sy, r[i].ex, r[i].ey + 1),                      i) == false)) {         r[i].ey++;       }     }     for (i = v; i < 26; i++) {       for (x = r[i].sx; x <= r[i].ex; x++) {         for (int y = r[i].sy; y <= r[i].ey; y++) {           s[x][y] = r[i].ch;         }       }     }     printf("Case #%d:\n", c + 1);     for (i = 0; i < n; i++) {       printf("%s\n", s[i]);     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cctype> #include <cstdio> #include <cstring> #include <iomanip> #include <iostream> #include <vector>  using namespace std; 
typedef vector<int> vi; typedef long long ll; typedef long long LL;  struct Rectangle {   char ch;   int sx;   int sy;   int ex;   int ey;   Rectangle() {}   Rectangle(char a, int b, int c, int d, int e) {     ch = a;     sx = b;     sy = c;     ex = d;     ey = e;   } };  Rectangle r[26 + 1]; char s[25 + 1][25 + 1]; int n, m, k;  bool operator<(const Rectangle &a, const Rectangle &b) {   return a.sx < b.sx || (a.sx == b.sx && a.sy < b.sy); }  bool intersect(const Rectangle &a, const Rectangle &b) {   return !(a.ex < b.sx || a.sx > b.ex || a.ey < b.sy || a.sy > b.ey) &&          !(a.sx > b.sx && a.ex < b.ex && a.sy > b.sy && a.ey < b.ey); }  bool intersect(const Rectangle &a, int p) {   int i;   for (i = k; i < 26; i++) {     if ((i != p) && (intersect(a, r[i]) == true)) {       return true;     }   }   return false; } 
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_3_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/try/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_3_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/try/outer_temp/try/A-small-practice_transformation.out",           "w", stdout);   int c, t, i, j, x;   scanf("%d", &t);   for (c = 0; c < t; c++) {     memset(r, -1, sizeof(r));     scanf("%d %d", &n, &m);     for (i = 0; i < n; i++) {       scanf("%s", s[i]);       for (j = 0; j < m; j++) {         if (isupper(s[i][j])) {           k = (int)(s[i][j] - 'A');           if ((r[k].sx == -1) && (r[k].ex == -1) && (r[k].sy == -1) &&               (r[k].ey == -1)) {             r[k].ch = s[i][j];             r[k].sx = i;             r[k].sy = j;             r[k].ex = i;             r[k].ey = j;           } else {             r[k].sx = min(r[k].sx, i);             r[k].sy = min(r[k].sy, j);             r[k].ex = max(r[k].ex, i);             r[k].ey = max(r[k].ey, j);           }         }       }     }     sort(r, r + 26);     for (k = 0; k < 26; k++) {       if ((r[k].sx != -1) && (r[k].sy != -1) && (r[k].ex != -1) &&           (r[k].ey != -1)) {         break;       }     }     for (i = k; i < 26; i++) {       while (           (r[i].sx - 1 >= 0) &&           (intersect(Rectangle(r[i].ch, r[i].sx - 1, r[i].sy, r[i].ex, r[i].ey),                      i) == false)) {         r[i].sx--;       }       while (           (r[i].sy - 1 >= 0) &&           (intersect(Rectangle(r[i].ch, r[i].sx, r[i].sy - 1, r[i].ex, r[i].ey),                      i) == false)) {         r[i].sy--;       }       while ((r[i].ex + 1 < n) &&              (intersect(Rectangle(r[i].ch, r[i].sx + 1, r[i].sy, r[i].ex + 1,                                   r[i].ey),                         i) == false)) {         r[i].ex++;       }       while (           (r[i].ey + 1 < m) &&           (intersect(Rectangle(r[i].ch, r[i].sx, r[i].sy, r[i].ex, r[i].ey + 1),                      i) == false)) {         r[i].ey++;       }     }     for (i = k; i < 26; i++) {       for (x = r[i].sx; x <= r[i].ex; x++) {         for (int y = r[i].sy; y <= r[i].ey; y++) {           s[x][y] = r[i].ch;         }       }     }     cout << "Case #" << c + 1 << ":\n";     for (i = 0; i < n; i++) {       cout << s[i] << "\n";     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <stdio.h> #include <utility> #include <vector>  using namespace std; 
const int MOD = 1000000007; const int mod = 1000000007; const double eps = 1e-9;  struct Rectangle {   char ch;   int sx;   int sy;   int ex;   int ey;   Rectangle() {}   Rectangle(char a, int b, int c, int d, int e) {     ch = a;     sx = b;     sy = c;     ex = d;     ey = e;   } };  Rectangle r[26 + 1]; char s[25 + 1][25 + 1]; int n, q, T;  bool operator<(const Rectangle &a, const Rectangle &b) {   return a.sx < b.sx || (a.sx == b.sx && a.sy < b.sy); }  bool N(const Rectangle &a, const Rectangle &b) {   return !(a.ex < b.sx || a.sx > b.ex || a.ey < b.sy || a.sy > b.ey) &&          !(a.sx > b.sx && a.ex < b.ex && a.sy > b.sy && a.ey < b.ey); }  bool N(const Rectangle &a, int get) {   int i;   for (i = T; i < 26; i++) {     if ((i != get) && (N(a, r[i]) == true)) {       return true;     }   }   return false; }  
int main() {   ios::sync_with_stdio(false);    int ret_val = 0;    int c, t, i, j, x, y;   cin >> t;   for (c = 0; c < t; c++) {     memset(r, -1, sizeof(r));     cin >> n >> q;     for (i = 0; i < n; i++) {       cin >> s[i];       for (j = 0; j < q; j++) {         if (isupper(s[i][j])) {           T = (int)(s[i][j] - 'A');           if ((r[T].sx == -1) && (r[T].ex == -1) && (r[T].sy == -1) &&               (r[T].ey == -1)) {             r[T].ch = s[i][j];             r[T].sx = i;             r[T].sy = j;             r[T].ex = i;             r[T].ey = j;           } else {             r[T].sx = min(r[T].sx, i);             r[T].sy = min(r[T].sy, j);             r[T].ex = max(r[T].ex, i);             r[T].ey = max(r[T].ey, j);           }         }       }     }     sort(r, r + 26);     for (T = 0; T < 26; T++) {       if ((r[T].sx != -1) && (r[T].sy != -1) && (r[T].ex != -1) &&           (r[T].ey != -1)) {         break;       }     }     for (i = T; i < 26; i++) {       while ((r[i].sx - 1 >= 0) &&              (N(Rectangle(r[i].ch, r[i].sx - 1, r[i].sy, r[i].ex, r[i].ey),                 i) == false)) {         r[i].sx--;       }       for (; (r[i].sy - 1 >= 0) &&              (N(Rectangle(r[i].ch, r[i].sx, r[i].sy - 1, r[i].ex, r[i].ey),                 i) == false);)         r[i].sy--;        while ((r[i].ex + 1 < n) &&              (N(Rectangle(r[i].ch, r[i].sx + 1, r[i].sy, r[i].ex + 1, r[i].ey),                 i) == false)) {         r[i].ex++;       }       while ((r[i].ey + 1 < q) &&              (N(Rectangle(r[i].ch, r[i].sx, r[i].sy, r[i].ex, r[i].ey + 1),                 i) == false)) {         r[i].ey++;       }     }     for (i = T; i < 26; i++) {       for (x = r[i].sx; x <= r[i].ex; x++) {         for (y = r[i].sy; y <= r[i].ey; y++) {           s[x][y] = r[i].ch;         }       }     }     cout << "Case #" << c + 1 << ":\n";     for (i = 0; i < n; i++) {       cout << s[i] << "\n";     }   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
ifstream fin;  const int mod = 1000000007;  struct Rectangle {   char ch;   int sx;   int sy;   int ex;   int ey;   Rectangle() {}   Rectangle(char a, int b, int c, int d, int e) {     ch = a;     sx = b;     sy = c;     ex = d;     ey = e;   } };  Rectangle r[26 + 1]; char s[25 + 1][25 + 1]; int n, tc, T;  bool operator<(const Rectangle &a, const Rectangle &b) {   return a.sx < b.sx || (a.sx == b.sx && a.sy < b.sy); }  bool intersect(const Rectangle &a, const Rectangle &b) {   return !(a.ex < b.sx || a.sx > b.ex || a.ey < b.sy || a.sy > b.ey) &&          !(a.sx > b.sx && a.ex < b.ex && a.sy > b.sy && a.ey < b.ey); }  bool intersect(const Rectangle &a, int p) {   int i;   for (i = T; i < 26; i++) {     if ((i != p) && (intersect(a, r[i]) == true)) {       return true;     }   }   return false; }  inline void ppcnezabwt(int &i) {   i = 0;   while (i < n) {     printf("%s\n", s[i]);     i++;   } }  
int main() {   fin.open("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_3_Usenix_RF_1.0_True_MCTS_Classic_True/kuzphi/try/A-small-practice.in");    int c, t, i, j, x, y;   fin >> t;   for (c = 0; c < t; c++) {     memset(r, -1, sizeof(r));     fin >> n >> tc;     for (i = 0; i < n; i++) {       fin >> s[i];       for (j = 0; j < tc; j++) {         if (isupper(s[i][j])) {           T = (int)(s[i][j] - 'A');           if ((r[T].sx == -1) && (r[T].ex == -1) && (r[T].sy == -1) &&               (r[T].ey == -1)) {             r[T].ch = s[i][j];             r[T].sx = i;             r[T].sy = j;             r[T].ex = i;             r[T].ey = j;           } else {             r[T].sx = min(r[T].sx, i);             r[T].sy = min(r[T].sy, j);             r[T].ex = max(r[T].ex, i);             r[T].ey = max(r[T].ey, j);           }         }       }     }     sort(r, r + 26);     for (T = 0; T < 26; T++) {       if ((r[T].sx != -1) && (r[T].sy != -1) && (r[T].ex != -1) &&           (r[T].ey != -1)) {         break;       }     }     for (i = T; i < 26; i++) {       while (           (r[i].sx - 1 >= 0) &&           (intersect(Rectangle(r[i].ch, r[i].sx - 1, r[i].sy, r[i].ex, r[i].ey),                      i) == false)) {         r[i].sx--;       }       while (           (r[i].sy - 1 >= 0) &&           (intersect(Rectangle(r[i].ch, r[i].sx, r[i].sy - 1, r[i].ex, r[i].ey),                      i) == false))         r[i].sy--;        while ((r[i].ex + 1 < n) &&              (intersect(Rectangle(r[i].ch, r[i].sx + 1, r[i].sy, r[i].ex + 1,                                   r[i].ey),                         i) == false)) {         r[i].ex++;       }       while (           (r[i].ey + 1 < tc) &&           (intersect(Rectangle(r[i].ch, r[i].sx, r[i].sy, r[i].ex, r[i].ey + 1),                      i) == 0)) {         r[i].ey++;       }     }     for (i = T; i < 26; i++) {       for (x = r[i].sx; x <= r[i].ex; x++) {         for (y = r[i].sy; y <= r[i].ey; y++) {           s[x][y] = r[i].ch;         }       }     }     printf("Case #%d:\n", c + 1);     ppcnezabwt(i);   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> #include <vector> using namespace std; 
typedef long long ll; typedef vector<int> vi;  ofstream fout("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_4_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  void rsolve(int r0, int r1, int c0, int c1, vector<string> &rows) {   vector<pair<int, int>> founds;   for (int i = r0; i < r1; i++)     for (int j = c0; j < c1; j++)       if (rows[i][j] != '?')         founds.push_back({i, j});   cout << r0 << ' ' << r1 << ' ' << c0 << ' ' << c1 << ' ' << founds.size()        << '\n';   if (founds.size() == 0) {     cout << "WTF???\n";     return;   }   if (founds.size() == 1) {     char found = rows[founds[0].first][founds[0].second];     for (int i = r0; i < r1; i++)       for (int j = c0; j < c1; j++)         rows[i][j] = found;     return;   } else {     int R1 = founds[0].first, C1 = founds[0].second, R2 = founds[1].first,         C2 = founds[1].second;     if (C1 == C2) {       rsolve(r0, max(R1, R2), c0, c1, rows);       rsolve(max(R1, R2), r1, c0, c1, rows);     } else {       rsolve(r0, r1, c0, max(C1, C2), rows);       rsolve(r0, r1, max(C1, C2), c1, rows);     }   }   cout << r0 << ' ' << r1 << ' ' << c0 << ' ' << c1 << "done\n"; }  void open() {   int r, c;   scanf("%d %d ", &r, &c);   vector<string> rows(r);   for (string &s : rows)     cin >> s;   rsolve(0, r, 0, c, rows);   for (string s : rows)     fout << s << '\n';   cout << "solve done"; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_4_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sammyMaX/A-small-practice.in", "r", stdin);    int t;   scanf("%d ", &t);   for (int i = 0; i < t; i++)     fout << "Case #" << i + 1 << ":\n", open();   return 0; }
#include <bits/stdc++.h> #include <iostream> using namespace std; 
ofstream T("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_4_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  inline void bcnhjiqvrv(vector<std::string> &rows,                        vector<pair<int, int>> &founds, int &i, int &j) {   if (rows[i][j] != '?')     founds.push_back({i, j}); }  inline void baiijymeno(int &c0, int &c1, vector<std::string> &rows,                        vector<pair<int, int>> &founds, int &i) {   for (int j = c0; j < c1; j++)     bcnhjiqvrv(rows, founds, i, j);   i++; }  inline void dotbrioswt(int &r0, int &r1, int &c0, int &c1,                        vector<std::string> &rows,                        vector<pair<int, int>> &founds) {   int i = r0;   while (i < r1)     baiijymeno(c0, c1, rows, founds, i); }  inline bool uznutdgoql(vector<pair<int, int>> &founds, int &r0, int &r1,                        int &c0, int &c1, vector<std::string> &rows) {   char found = rows[founds[0].first][founds[0].second];   {     int i = r0;     while (i < r1) {       int j = c0;       while (j < c1) {         rows[i][j] = found;         j++;       }       i++;     }   }   return true;   return false; }  void rsolve(int r0, int r1, int c0, int c1, vector<string> &rows) {   vector<pair<int, int>> founds;   dotbrioswt(r0, r1, c0, c1, rows, founds);   cout << r0 << ' ' << r1 << ' ' << c0 << ' ' << c1 << ' ' << founds.size()        << '\n';   if (founds.size() == 0) {     cout << "WTF???\n";     return;   }   if (founds.size() == 1) {     if (uznutdgoql(founds, r0, r1, c0, c1, rows)) {       return;     }   } else {     int R1 = founds[0].first, C1 = founds[0].second, R2 = founds[1].first,         C2 = founds[1].second;     if (C1 == C2) {       rsolve(r0, max(R1, R2), c0, c1, rows);       rsolve(max(R1, R2), r1, c0, c1, rows);     } else {       rsolve(r0, r1, c0, max(C1, C2), rows);       rsolve(r0, r1, max(C1, C2), c1, rows);     }   }   cout << r0 << ' ' << r1 << ' ' << c0 << ' ' << c1 << "done\n"; }  void solve() {   int r, c;   cin >> r >> c;   vector<string> rows(r);   for (string &s : rows)     cin >> s;   rsolve(0, r, 0, c, rows);   for (string s : rows) {     T << s << '\n';   }   cout << "solve done"; }  
int main() {   int t;   cin >> t;   int i;   for (i = 0; i < t; i++)     T << "Case #" << i + 1 << ":\n", solve();   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <set> #include <sstream> #include <stack> #include <stdlib.h> #include <string> #include <unordered_map> #include <vector> using namespace std;
const int INF = 1000000000; const long double PI = 3.1415926535897932384626433832795; const double EPS = 1e-9;  ifstream q("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_4_Usenix_RF_1.0_True_MCTS_Classic_True/kuzphi/sammyMaX/A-small-practice.in"); ofstream ans("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_4_Usenix_RF_1.0_True_MCTS_Classic_True/kuzphi/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  inline bool evlxlnuvsc(vector<pair<int, int>> &T, int &r0, int &r1, int &c0,                        int &c1, vector<std::string> &rows) {   char found = rows[T[0].first][T[0].second];   for (int i = r0; i < r1; i++)     for (int N = c0; N < c1; N++)       rows[i][N] = found;   return true;   return false; }  inline void ywzjxjsbsp(vector<std::string> &rows, vector<pair<int, int>> &T,                        int &i, int &N) {   if (rows[i][N] != '?')     T.push_back({i, N});   N++; }  inline bool oqwymiepdt() {   return true;   return false; }  void rsolve(int r0, int r1, int c0, int c1, vector<string> &rows) {   vector<pair<int, int>> T;   for (int i = r0; i < r1; i++) {     int N = c0;     while (N < c1)       ywzjxjsbsp(rows, T, i, N);   }   cout << r0 << ' ' << r1 << ' ' << c0 << ' ' << c1 << ' ' << T.size() << '\n';   if (T.size() == 0) {     cout << "WTF???\n";     return;   }   if (T.size() == 1) {     if (evlxlnuvsc(T, r0, r1, c0, c1, rows)) {       if (oqwymiepdt()) {         return;       }     }   } else {     int R1 = T[0].first, C1 = T[0].second, R2 = T[1].first, C2 = T[1].second;     if (C1 == C2) {       rsolve(r0, max(R1, R2), c0, c1, rows);       rsolve(max(R1, R2), r1, c0, c1, rows);     } else {       rsolve(r0, r1, c0, max(C1, C2), rows);       rsolve(r0, r1, max(C1, C2), c1, rows);     }   }   cout << r0 << ' ' << r1 << ' ' << c0 << ' ' << c1 << "done\n"; }  void a() {   int r, c;   q >> r >> c;   vector<string> rows(r);   for (string &s : rows)     q >> s;   rsolve(0, r, 0, c, rows);   for (string s : rows)     ans << s << '\n';   cout << "solve done"; }  
int main() {   int t;   q >> t;   for (int i = 0; i < t; i++)     ans << "Case #" << i + 1 << ":\n", a();   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const int INF = 1000000000;  ofstream fout("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_4_Usenix_RF_1.0_True_MCTS_Classic_True/ibrahim5253/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  void rsolve(int r0, int r1, int c0, int c1, vector<string> &rows) {   vector<pair<int, int>> founds;   for (int i = r0; i < r1; i++)     for (int j = c0; j < c1; j++)       if (rows[i][j] != '?')         founds.push_back({i, j});   cout << r0 << ' ' << r1 << ' ' << c0 << ' ' << c1 << ' ' << founds.size()        << '\n';   if (founds.size() == 0) {     cout << "WTF???\n";     return;   }   if (founds.size() == 1) {     char found = rows[founds[0].first][founds[0].second];     for (int i = r0; i < r1; i++)       for (int j = c0; j < c1; j++)         rows[i][j] = found;     return;   } else {     int R1 = founds[0].first, C1 = founds[0].second, R2 = founds[1].first,         get = founds[1].second;     if (C1 == get) {       rsolve(r0, max(R1, R2), c0, c1, rows);       rsolve(max(R1, R2), r1, c0, c1, rows);     } else {       rsolve(r0, r1, c0, max(C1, get), rows);       rsolve(r0, r1, max(C1, get), c1, rows);     }   }   cout << r0 << ' ' << r1 << ' ' << c0 << ' ' << c1 << "done\n"; }  void solve() {   int r, c;   cin >> r >> c;   vector<string> rows(r);   for (string &s : rows)     cin >> s;   rsolve(0, r, 0, c, rows);   for (string s : rows)     fout << s << '\n';   cout << "solve done"; }  
int main() {   int t;   cin >> t;   for (int i = 0; i < t; i++)     fout << "Case #" << i + 1 << ":\n", solve();   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility> #include <vector>  using namespace std;
typedef long double ld; typedef long long ll; typedef long long LL; typedef pair<int, int> PII; typedef unsigned long long ull; typedef long double LD;  const double EPS = 1e-9;  const int N = 100;  int n, m;  inline void lpodivfzbq(std::string &c, int &T, char &last) { c[T] = last; }  inline void lragfbbhuw(char &last, std::string &c, int &T) { last = c[T]; }  void handle_line(string &c) {   char last = '?';   for (int T = 0; T < m; ++T) {     if (c[T] == '?') {       lpodivfzbq(c, T, last);     } else       lragfbbhuw(last, c, T);   }   for (int T = m - 1; T >= 0; --T) {     if (c[T] == '?') {       c[T] = last;     } else {       last = c[T];     }   } }  string c[N];  inline void ukzgtebnpm(int &st, int &T) { st = T; }  void work() {   cin >> n >> m;   string qs;   for (int T = 1; T <= m; ++T) {     qs.push_back('?');   }   int st = -1;   for (int T = 1; T <= n; ++T) {     cin >> c[T];     if (c[T] != qs) {       ukzgtebnpm(st, T);     }   }   handle_line(c[st]);   for (int T = st - 1; T >= 1; --T) {     if (c[T] == qs) {       c[T] = c[T + 1];     } else {       handle_line(c[T]);     }   }   for (int T = st + 1; T <= n; ++T) {     if (c[T] == qs) {       c[T] = c[T - 1];     } else {       handle_line(c[T]);     }   }   int T;   for (T = 1; T <= n; ++T) {     cout << c[T] << endl;   } }  
int main() {   ios::sync_with_stdio(true);    int q;   cin >> q;   for (int T = 1; T <= q; ++T) {     cout << "Case #" << T << ":\n";     work();   }   return 0; }
#include <algorithm> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdlib.h> #include <string> #include <unordered_map> #include <vector>  using namespace std; 
const int INF = 1000000000; const int MAXN = 1005; const int mod = 1000000007;  const int N = 100;  int n, m;  void handle_line(string &s) {   char last = '?';   int i;   for (i = 0; i < m; ++i) {     if (s[i] == '?') {       s[i] = last;     } else {       last = s[i];     }   }   {     int i = m - 1;     while (i >= 0) {       if (s[i] == '?') {         s[i] = last;       } else {         last = s[i];       }       --i;     }   } }  string s[N];  void solve() {   cin >> n >> m;   string tc;   for (int i = 1; i <= m; ++i) {     tc.push_back('?');   }   int st = -1;   for (int i = 1; i <= n; ++i) {     cin >> s[i];     if (s[i] != tc) {       st = i;     }   }   handle_line(s[st]);   {     int i = st - 1;     while (i >= 1) {       if (s[i] == tc) {         s[i] = s[i + 1];       } else {         handle_line(s[i]);       }       --i;     }   }   int i;   for (i = st + 1; i <= n; ++i) {     if (s[i] == tc) {       s[i] = s[i - 1];     } else {       handle_line(s[i]);     }   }   for (int i = 1; i <= n; ++i) {     cout << s[i] << endl;   } }  
int main() {   ios::sync_with_stdio(true);    int q;   cin >> q;   int i;   for (i = 1; i <= q; ++i) {     printf("Case #%d:\n", i);     solve();   }   return 0; }
#include <algorithm> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
const int N = 100;  int n, m;  void handle_line(string &s) {   char last = '?';   for (int t = 0; t < m; ++t) {     if (s[t] == '?') {       s[t] = last;     } else {       last = s[t];     }   }   int t;   for (t = m - 1; t >= 0; --t) {     if (s[t] == '?') {       s[t] = last;     } else {       last = s[t];     }   } }  string s[N];  void work() {   cin >> n >> m;   string qs;   for (int t = 1; t <= m; ++t) {     qs.push_back('?');   }   int st = -1;   for (int t = 1; t <= n; ++t) {     cin >> s[t];     if (s[t] != qs) {       st = t;     }   }   handle_line(s[st]);   for (int t = st - 1; t >= 1; --t) {     if (s[t] == qs) {       s[t] = s[t + 1];     } else {       handle_line(s[t]);     }   }   for (int t = st + 1; t <= n; ++t) {     if (s[t] == qs) {       s[t] = s[t - 1];     } else {       handle_line(s[t]);     }   }   for (int t = 1; t <= n; ++t) {     cout << s[t] << endl;   } }  
int main() {   ios::sync_with_stdio(true);    freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_5_Usenix_RF_1.0_True_MCTS_Classic_True/ibrahim5253/Tashi711/A-small-practice.in",           "r", stdin);    int q;   cin >> q;   for (int t = 1; t <= q; ++t) {     printf("Case #%d:\n", t);     work();   }   return 0; }
#include <bits/stdc++.h> #include <cstdio> #include <iostream> #include <map> #include <stdio.h> #include <string> #include <vector>  using namespace std; 
const int N = 100;  int n, m;  inline void nfdhqtwyor(std::string &r, int &i, char &last) { r[i] = last; }  void handle_line(string &r) {   char last = '?';   for (int i = 0; i < m; ++i) {     if (r[i] == '?')       nfdhqtwyor(r, i, last);     else {       last = r[i];     }   }   for (int i = m - 1; i >= 0; --i) {     if (r[i] == '?')       r[i] = last;     else {       last = r[i];     }   } }  string r[N];  void work() {   cin >> n >> m;   string qs;   for (int i = 1; i <= m; ++i) {     qs.push_back('?');   }   int st = -1;    for (int i = 1; i <= n; ++i) {     cin >> r[i];     if (r[i] != qs) {       st = i;     }   }   handle_line(r[st]);   {     int i = st - 1;     while (i >= 1) {       if (r[i] == qs)         r[i] = r[i + 1];       else {         handle_line(r[i]);       }       --i;     }   }   for (int i = st + 1; i <= n; ++i) {     if (r[i] == qs)       r[i] = r[i - 1];     else       handle_line(r[i]);   }   for (int i = 1; i <= n; ++i)     printf("%s\n", r[i].c_str()); }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_5_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/Tashi711/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_5_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/Tashi711/outer_temp/Tashi711/A-small-practice_transformation.out",           "w", stdout);    int cas;   cin >> cas;   {     int i = 1;     while (i <= cas) {       printf("Case #%d:\n", i);       work();       ++i;     }   }   return 0; }
#include <algorithm> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <vector> using namespace std; 
const long double PI = 3.1415926535897932384626433832795; const double EPS = 1e-9; const int INF = 1000000000;  char ch[30][30]; int r, c;  void fill(char T, int x, int y, int dx, int dy) {   for (; (x + dx >= 0) && (x + dx < r) && (y + dy >= 0) && (y + dy < c) &&          (ch[x + dx][y + dy] == '?');) {     x += dx;     y += dy;     ch[x][y] = T;   } }  inline void bkaycqppue(int &tc, int &j) {   fill(ch[tc][j], tc, j, -1, 0);   fill(ch[tc][j], tc, j, 1, 0); }  inline void efkeaxrxpt(int &tc, int &j) {   fill(ch[tc][j], tc, j, 0, 1);   fill(ch[tc][j], tc, j, 0, -1); }  inline void kacaihoscv(int &tc) {   int j;   for (j = 0; j < c; ++j)     printf("%c", ch[tc][j]);   printf("\n"); }  
int main() {   int q;    cin >> q;    for (int a = 1; a <= q; ++a) {     cin >> r >> c;     for (int tc = 0; tc < r; ++tc)       for (int j = 0; j < c; ++j)         cin >> ch[tc][j];      for (int tc = 0; tc < r; ++tc)       for (int j = 0; j < c; ++j)         if (ch[tc][j] != '?')           bkaycqppue(tc, j);     for (int tc = 0; tc < r; ++tc)       for (int j = 0; j < c; ++j)         if (ch[tc][j] != '?')           efkeaxrxpt(tc, j);      printf("Case #%d: \n", a);     for (int tc = 0; tc < r; ++tc)       kacaihoscv(tc);   }    return 0; }
#include <algorithm> #include <bitset> #include <cctype> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <iostream> #include <iterator> #include <map> #include <numeric> #include <queue> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility> #include <vector> using namespace std;
typedef long long ll; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef pair<int, int> PII;  char ch[30][30]; int r, c;  void fill(char cc, int x, int y, int dx, int dy) {   while ((x + dx >= 0) && (x + dx < r) && (y + dy >= 0) && (y + dy < c) &&          (ch[x + dx][y + dy] == '?')) {     x += dx;     y += dy;     ch[x][y] = cc;   } }  
int main() {   ios::sync_with_stdio(false);    int q;    cin >> q;    for (int t = 1; t <= q; ++t) {     cin >> r >> c;     for (int i = 0; i < r; ++i)       for (int j = 0; j < c; ++j)         cin >> ch[i][j];      for (int i = 0; i < r; ++i) {       int j = 0;       while (j < c) {         if (ch[i][j] != '?') {           fill(ch[i][j], i, j, -1, 0);           fill(ch[i][j], i, j, 1, 0);         }         ++j;       }     }     for (int i = 0; i < r; ++i)       for (int j = 0; j < c; ++j)         if (ch[i][j] != '?') {           fill(ch[i][j], i, j, 0, 1);           fill(ch[i][j], i, j, 0, -1);         }      cout << "Case #" << t << ": " << endl;     for (int i = 0; i < r; ++i) {       for (int j = 0; j < c; ++j)         cout << ch[i][j];       cout << endl;     }   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <iostream> #include <stdio.h> #include <string> #include <vector> using namespace std;  
char ch[30][30]; int r, c;  void fill(char cc, int x, int cas, int dx, int dy) {   while ((x + dx >= 0) && (x + dx < r) && (cas + dy >= 0) && (cas + dy < c) &&          (ch[x + dx][cas + dy] == '?')) {     x += dx;     cas += dy;     ch[x][cas] = cc;   } }  inline void habnwdioaw(int &i, int &j) {   fill(ch[i][j], i, j, -1, 0);   fill(ch[i][j], i, j, 1, 0); }  inline void bsdclcltim(int &i, int &j) {   fill(ch[i][j], i, j, 0, 1);   fill(ch[i][j], i, j, 0, -1); }  
int main() {   ios::sync_with_stdio(false);    freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_6_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/WCG/outer_temp/WCG/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_6_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/WCG/A-small-practice.in",           "r", stdin);    int tt;    cin >> tt;    {     int n = 1;     while (n <= tt) {       cin >> r >> c;       {         int i = 0;         while (i < r) {           for (int j = 0; j < c; ++j)             cin >> ch[i][j];           ++i;         }       }        {         int i = 0;         while (i < r) {           for (int j = 0; j < c; ++j)             if (ch[i][j] != '?')               habnwdioaw(i, j);           ++i;         }       }       for (int i = 0; i < r; ++i) {         for (int j = 0; j < c; ++j)           if (ch[i][j] != '?')             bsdclcltim(i, j);       }        printf("Case #%d: \n", n);       for (int i = 0; i < r; ++i) {         int j;         for (j = 0; j < c; ++j)           printf("%c", ch[i][j]);         printf("\n");       }       ++n;     }   }    return 0; }
#include <algorithm> #include <cstdio> #include <cstring> #include <iostream> #include <stdio.h> #include <string> #include <vector> using namespace std;  
char ch[30][30]; int r, c;  void fill(char cc, int x, int y, int dx, int dy) {   while ((x + dx >= 0) && (x + dx < r) && (y + dy >= 0) && (y + dy < c) &&          (ch[x + dx][y + dy] == '?')) {     x += dx;     y += dy;     ch[x][y] = cc;   } }  
int main() {   int tt;    scanf("%d ", &tt);    for (int t = 1; t <= tt; ++t) {     scanf("%d %d ", &r, &c);     for (int i = 0; i < r; ++i)       for (int s = 0; s < c; ++s)         scanf("%c ", &ch[i][s]);      for (int i = 0; i < r; ++i)       for (int s = 0; s < c; ++s)         if (ch[i][s] != '?') {           fill(ch[i][s], i, s, -1, 0);           fill(ch[i][s], i, s, 1, 0);         }     for (int i = 0; i < r; ++i)       for (int s = 0; s < c; ++s)         if (ch[i][s] != '?') {           fill(ch[i][s], i, s, 0, 1);           fill(ch[i][s], i, s, 0, -1);         }      printf("Case #%d: \n", t);     for (int i = 0; i < r; ++i) {       for (int s = 0; s < c; ++s)         printf("%c", ch[i][s]);       printf("\n");     }   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> using namespace std; 
const int INF = 1000000000;  typedef pair<int, int> ii;  typedef vector<ii> vii; typedef long long ll;  
int main() {   cin.sync_with_stdio(false);    int t;   cin >> t;    for (int ans = (0); ans < (t); ans++) {     int n, d;     cin >> n >> d;     char at[500][500];     bool vis[500][500];     memset(vis, 0, sizeof(vis));     for (int i = (0); i < (n); i++)       for (int a = (0); a < (d); a++)         cin >> at[i][a];     for (int i = (0); i < (n); i++)       for (int a = (0); a < (d); a++) {         if (at[i][a] != '?' && !vis[i][a]) {           vis[i][a] = true;           int startx = a;           int endx = a;           char am = at[i][a];           for (int a2 = (a + 1); a2 < (d); a2++) {             if (at[i][a2] == '?') {               at[i][a2] = am;               vis[i][a2] = true;               endx++;             } else               break;           }           for (int a2 = a - 1; a2 >= 0; a2--) {             if (at[i][a2] == '?') {               at[i][a2] = am;               vis[i][a2] = true;               startx--;             } else               break;           }            for (int i2 = (i + 1); i2 < (n); i2++) {             bool p = true;             for (int a2 = (startx); a2 < (endx + 1); a2++)               if (at[i2][a2] != '?')                 p = false;             if (p) {               for (int a2 = (startx); a2 < (endx + 1); a2++) {                 at[i2][a2] = am;                 vis[i2][a2] = true;               }             } else               break;           }           for (int i2 = i - 1; i2 >= 0; i2--) {             bool p = true;             for (int a2 = (startx); a2 < (endx + 1); a2++)               if (at[i2][a2] != '?')                 p = 0;             if (p) {               {                 int a2 = (startx);                 while (a2 < (endx + 1)) {                   at[i2][a2] = am;                   vis[i2][a2] = true;                   a2++;                 }               }             } else               break;           }         }       }     cout << "Case #" << ans + 1 << ":" << endl;     for (int i = (0); i < (n); i++) {       for (int a = (0); a < (d); a++)         cout << at[i][a];       cout << endl;     }   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> using namespace std; 
typedef pair<int, int> ii; typedef vector<int> vi; typedef vector<ii> vii; 
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_7_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_7_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/bennikartefla/A-small-practice.in",           "r", stdin);    int r;   cin >> r;   for (int u = (0); u < (r); u++) {     int n, m;     cin >> n >> m;     char ltnc_Var[500][500];     bool vis[500][500];     memset(vis, 0, sizeof(vis));     for (int i = (0); i < (n); i++)       for (int xazi_Var = (0); xazi_Var < (m); xazi_Var++) {         cin >> ltnc_Var[i][xazi_Var];       }     for (int i = (0); i < (n); i++)       for (int xazi_Var = (0); xazi_Var < (m); xazi_Var++) {         if (ltnc_Var[i][xazi_Var] != '?')           if (!vis[i][xazi_Var]) {             vis[i][xazi_Var] = true;             int startx = xazi_Var;             int endx = xazi_Var;             char am = ltnc_Var[i][xazi_Var];             for (int a2 = (xazi_Var + 1); a2 < (m); a2++) {               if (ltnc_Var[i][a2] == '?') {                 ltnc_Var[i][a2] = am;                 vis[i][a2] = true;                 endx++;               } else                 break;             }             int a2;             for (a2 = xazi_Var - 1; a2 >= 0; a2--) {               if (ltnc_Var[i][a2] == '?') {                 ltnc_Var[i][a2] = am;                 vis[i][a2] = true;                 startx--;               } else                 break;             }              for (int i2 = (i + 1); i2 < (n); i2++) {               bool cas = true;               for (int a2 = (startx); a2 < (endx + 1); a2++)                 if (ltnc_Var[i2][a2] != '?')                   cas = false;               if (cas) {                 for (int a2 = (startx); a2 < (endx + 1); a2++) {                   ltnc_Var[i2][a2] = am;                   vis[i2][a2] = true;                 }               } else                 break;             }             for (int i2 = i - 1; i2 >= 0; i2--) {               int cas = true;               for (int a2 = (startx); a2 < (endx + 1); a2++)                 if (ltnc_Var[i2][a2] != '?')                   cas = false;               if (cas) {                 for (int a2 = (startx); a2 < (endx + 1); a2++) {                   ltnc_Var[i2][a2] = am;                   vis[i2][a2] = true;                 }               } else                 break;             }           }       }     printf("Case #%d:\n", u + 1);     for (int i = (0); i < (n); i++) {       int xazi_Var;       for (xazi_Var = (0); xazi_Var < (m); xazi_Var++)         printf("%c", ltnc_Var[i][xazi_Var]);       printf("\n");     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <fstream> #include <vector> using namespace std; 
ifstream fin;  typedef pair<int, int> ii; typedef vector<int> vi;  
int main() {   fin.open("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_7_Usenix_RF_1.0_True_MCTS_Classic_True/iPeter/bennikartefla/A-small-practice.in");    ofstream fout("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_7_Usenix_RF_1.0_True_MCTS_Classic_True/iPeter/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out");   int t;   fin >> t;   for (int ccai_Var = (0); ccai_Var < (t); ccai_Var++) {     int ans, m;     fin >> ans >> m;     char tt[500][500];     bool vis[500][500];     memset(vis, 0, sizeof(vis));     for (int s = (0); s < (ans); s++)       for (int a = (0); a < (m); a++)         fin >> tt[s][a];     for (int s = (0); s < (ans); s++)       for (int a = (0); a < (m); a++) {         if (tt[s][a] != '?' && !vis[s][a]) {           vis[s][a] = true;           int startx = a;           int endx = a;           char am = tt[s][a];           for (int a2 = (a + 1); a2 < (m); a2++) {             if (tt[s][a2] == '?') {               tt[s][a2] = am;               vis[s][a2] = true;               endx++;             } else               break;           }           for (int a2 = a - 1; a2 >= 0; a2--) {             if (tt[s][a2] == '?') {               tt[s][a2] = am;               vis[s][a2] = true;               startx--;             } else               break;           }            for (int i2 = (s + 1); i2 < (ans); i2++) {             int can = 1;             for (int a2 = (startx); a2 < (endx + 1); a2++) {               if (tt[i2][a2] != '?')                 can = false;             }             if (can) {               int a2;               for (a2 = (startx); a2 < (endx + 1); a2++) {                 tt[i2][a2] = am;                 vis[i2][a2] = true;               }             } else               break;           }           for (int i2 = s - 1; i2 >= 0; i2--) {             int can = true;             for (int a2 = (startx); a2 < (endx + 1); a2++)               if (tt[i2][a2] != '?')                 can = false;             if (can) {               for (int a2 = (startx); a2 < (endx + 1); a2++) {                 tt[i2][a2] = am;                 vis[i2][a2] = true;               }             } else               break;           }         }       }     fout << "Case #" << ccai_Var + 1 << ":" << endl;     for (int s = (0); s < (ans); s++) {       for (int a = (0); a < (m); a++)         fout << tt[s][a];       fout << endl;     }   }   return 0; }
#include <bits/stdc++.h> #include <iostream> using namespace std; 
typedef pair<int, int> ii;  typedef vector<ii> vii; typedef long long ll;  inline void gldkyplywh(int &m, char at[500][500], int &i) {   for (int a = (0); a < (m); a++)     cout << at[i][a];   cout << endl; }  inline void obpgqdzpzt(int &startx, int &endx, char at[500][500], char &am,                        _Bool vis[500][500], int &i2) {   for (int a2 = (startx); a2 < (endx + 1); a2++) {     at[i2][a2] = am;     vis[i2][a2] = true;   } }  
int main() {   ios::sync_with_stdio(false);    freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_7_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_7_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/bennikartefla/A-small-practice.in",           "r", stdin);    int get;   cin >> get;   for (int u = (0); u < (get); u++) {     int n, m;     cin >> n >> m;     char at[500][500];     bool vis[500][500];     memset(vis, 0, sizeof(vis));     for (int i = (0); i < (n); i++)       for (int a = (0); a < (m); a++)         cin >> at[i][a];     for (int i = (0); i < (n); i++) {       int a = (0);       for (; a < (m);) {         if (at[i][a] != '?' && !vis[i][a]) {           vis[i][a] = true;           int startx = a;           int endx = a;           char am = at[i][a];           for (int a2 = (a + 1); a2 < (m); a2++) {             if (at[i][a2] == '?') {               at[i][a2] = am;               vis[i][a2] = true;               endx++;             } else               break;           }           for (int a2 = a - 1; a2 >= 0; a2--) {             if (at[i][a2] == '?') {               at[i][a2] = am;               vis[i][a2] = true;               startx--;             } else               break;           }            for (int i2 = (i + 1); i2 < (n); i2++) {             bool can = true;             for (int a2 = (startx); a2 < (endx + 1); a2++)               if (at[i2][a2] != '?')                 can = false;             if (can)               obpgqdzpzt(startx, endx, at, am, vis, i2);             else               break;           }           for (int i2 = i - 1; i2 >= 0; i2--) {             bool can = true;             for (int a2 = (startx); a2 < (endx + 1); a2++)               if (at[i2][a2] != '?')                 can = false;             if (can) {               for (int a2 = (startx); a2 < (endx + 1); a2++) {                 at[i2][a2] = am;                 vis[i2][a2] = true;               }             } else               break;           }         }         a++;       }     }     cout << "Case #" << u + 1 << ":" << endl;     for (int i = (0); i < (n); i++)       gldkyplywh(m, at, i);   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> #include <vector> using namespace std; 
typedef long long LL; typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<int> vi; void open() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_8_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/ccsnoopy/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_8_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/ccsnoopy/outer_temp/ccsnoopy/A-small-practice_transformation.out",           "w", stdout); }  
int main(void) {   ios::sync_with_stdio(false);    open();   int tc;   cin >> tc;    for (int ct = 1; ct <= tc; ct++) {     int r, c;     cin >> r;     cin >> c;     string m[30];     vector<std::string> ret(30);     for (int i = 0; i < r; i++) {       cin >> m[i];        ret[i] = m[i];     }      for (int i = 0; i < r; i++) {       for (int j = 0; j < c; j++) {         if (m[i][j] == '?')           continue;         int minx, maxx;         minx = maxx = i;         int miny, maxy;         miny = maxy = j;         while (miny > 0 && m[i][miny - 1] == '?' && ret[i][miny - 1] == '?')           miny--;         while (maxy < c - 1 && m[i][maxy + 1] == '?' && ret[i][maxy + 1] == '?')           maxy++;         for (; minx > 0;) {           bool valid = true;           for (int cas = miny; cas <= maxy; cas++) {             if (ret[minx - 1][cas] != '?') {               valid = false;               break;             } else if (m[minx - 1][cas] != '?') {               valid = false;               break;             }           }           if (valid) {             minx--;           } else {             break;           }         }         int adabawah = false;         for (int cas = i + 1; cas < r; cas++) {           for (int ans = 0; ans < c; ans++) {             if (m[cas][ans] != '?') {               adabawah = true;               break;             }           }         }         if (!adabawah)           maxx = r - 1;          for (int cas = minx; cas <= maxx; cas++) {           for (int ans = miny; ans <= maxy; ans++)             ret[cas][ans] = m[i][j];         }       }     }      printf("Case #%d: \n", ct);     for (int i = 0; i < r; i++) {       printf("%s\n", ret[i].c_str());     }      cerr << "Test " << ct << " done \n";   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <stdio.h> #include <vector> using namespace std; 
typedef long long LL; typedef pair<int, int> ii; typedef vector<ii> vii;  void do_voiedx_fct() {}  
int main(void) {   do_voiedx_fct();   int t;   scanf("%d", &t);    for (int xrei_Var = 1; xrei_Var <= t; xrei_Var++) {     int r, c;     scanf("%d", &r);     scanf("%d", &c);     string tt[30];     string ret[30];     for (int i = 0; i < r; i++) {       cin >> tt[i];          ret[i] = tt[i];     }      for (int i = 0; i < r; i++) {       for (int s = 0; s < c; s++) {         if (tt[i][s] == '?')           continue;         int minx, maxx;         minx = maxx = i;         int miny, maxy;         miny = maxy = s;         while (miny > 0 && tt[i][miny - 1] == '?' && ret[i][miny - 1] == '?')           miny--;         while (maxy < c - 1 && tt[i][maxy + 1] == '?' &&                ret[i][maxy + 1] == '?')           maxy++;         for (; minx > 0;) {           bool valid = true;           for (int k = miny; k <= maxy; k++) {             if (ret[minx - 1][k] != '?') {               valid = false;               break;             } else if (tt[minx - 1][k] != '?') {               valid = false;               break;             }           }           if (valid) {             minx--;           } else             break;         }         bool adabawah = false;         for (int k = i + 1; k < r; k++) {           for (int ans = 0; ans < c; ans++) {             if (tt[k][ans] != '?') {               adabawah = true;               break;             }           }         }         if (!adabawah) {           maxx = r - 1;         }          for (int k = minx; k <= maxx; k++) {           for (int ans = miny; ans <= maxy; ans++) {             ret[k][ans] = tt[i][s];           }         }       }     }      printf("Case #%d: \n", xrei_Var);     for (int i = 0; i < r; i++) {       printf("%s\n", ret[i].c_str());     }      cerr << "Test " << xrei_Var << " done \n";   }   return 0; }
#include <bits/stdc++.h> #include <iomanip> #include <iostream> #include <set> using namespace std; 
typedef unsigned long long ull; typedef set<int> si; typedef long double ld; typedef long double LD; typedef long long ll; typedef long long LL; typedef pair<int, int> PII; typedef vector<PII> vii;  void open() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_8_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/ccsnoopy/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_8_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/ccsnoopy/outer_temp/ccsnoopy/A-small-practice_transformation.out",           "w", stdout); }  inline void husdeumqie(int &minx) { minx--; }  
int main(void) {   ios::sync_with_stdio(true);    open();   int tc;   cin >> tc;    for (int ct = 1; ct <= tc; ct++) {     int r, c;     cin >> r;     cin >> c;     string x[30];     string ret[30];     for (int i = 0; i < r; i++) {       cin >> x[i];            ret[i] = x[i];     }      {       int i = 0;       while (i < r) {         for (int j = 0; j < c; j++) {           if (x[i][j] == '?')             continue;           int minx, maxx;           minx = maxx = i;           int miny, maxy;           miny = maxy = j;           while (miny > 0 && x[i][miny - 1] == '?' && ret[i][miny - 1] == '?')             miny--;           while (maxy < c - 1 && x[i][maxy + 1] == '?' &&                  ret[i][maxy + 1] == '?')             maxy++;           while (minx > 0) {             bool valid = true;             for (int k = miny; k <= maxy; k++) {               if (x[minx - 1][k] != '?' || ret[minx - 1][k] != '?') {                 valid = 0;                 break;               }             }             if (valid)               husdeumqie(minx);             else               break;           }           int adabawah = 0;           {             int k = i + 1;             while (k < r) {               for (int n = 0; n < c; n++) {                 if (x[k][n] != '?') {                   adabawah = true;                   break;                 }               }               k++;             }           }           if (!adabawah) {             maxx = r - 1;           }            for (int k = minx; k <= maxx; k++) {             for (int n = miny; n <= maxy; n++) {               ret[k][n] = x[i][j];             }           }         }         i++;       }     }      cout << "Case #" << ct << ": \n";     for (int i = 0; i < r; i++) {       cout << ret[i] << "\n";     }      cerr << "Test " << ct << " done \n";   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <set> #include <sstream> #include <stdio.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
ifstream fin;  typedef long long ll; typedef long long LL; typedef pair<int, int> ii; typedef vector<ii> vii;  void solve() {}  inline void kphjjdbxvd(int &miny, int &maxy, std::string ret[30], int &get,                        std::string str[30], int &i, int &j) {   for (int l = miny; l <= maxy; l++) {     ret[get][l] = str[i][j];   } }  inline void vyzjpwdfwp(std::string ret[30], std::string str[30], int &i) {   fin >> str[i];    ret[i] = str[i]; } 
int main(void) {   fin.open("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_8_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ccsnoopy/A-small-practice.in");    int ret_val = 0;   solve();   int tc;   fin >> tc;    for (int ct = 1; ct <= tc; ct++) {     int r, c;     fin >> r;     fin >> c;     string str[30];     string ret[30];     for (int i = 0; i < r; i++)       vyzjpwdfwp(ret, str, i);      for (int i = 0; i < r; i++) {       for (int j = 0; j < c; j++) {         if (str[i][j] == '?')           continue;         int minx, maxx;         minx = maxx = i;         int miny, maxy;         miny = maxy = j;         while (miny > 0 && str[i][miny - 1] == '?' && ret[i][miny - 1] == '?')           miny--;         while (maxy < c - 1 && str[i][maxy + 1] == '?' &&                ret[i][maxy + 1] == '?')           maxy++;         while (minx > 0) {           bool valid = true;           for (int get = miny; get <= maxy; get++) {             if (str[minx - 1][get] != '?' || ret[minx - 1][get] != '?') {               valid = false;               break;             }           }           if (valid) {             minx--;           } else             break;         }         bool adabawah = false;         for (int get = i + 1; get < r; get++) {           for (int l = 0; l < c; l++) {             if (str[get][l] != '?') {               adabawah = true;               break;             }           }         }         if (!adabawah) {           maxx = r - 1;         }          for (int get = minx; get <= maxx; get++)           kphjjdbxvd(miny, maxy, ret, get, str, i, j);       }     }      cout << "Case #" << ct << ": \n";     for (int i = 0; i < r; i++) {       cout << ret[i] << "\n";     }      cerr << "Test " << ct << " done \n";   }   return ret_val; }
#include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <fstream> #include <stdio.h> using namespace std; 
ifstream fin;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &is, pair<S, T> &ans) {   return is >> ans.first >> ans.second; } template <class S, class T> ostream &do_stdler_fct(ostream &os, const pair<S, T> &p) {   return os << p.first << " " << p.second; }  
int main() {   int ret_val = 0;   fin.open("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_9_Usenix_RF_1.0_True_MCTS_Classic_True/iPeter/okaduki/A-small-practice.in");   cin.tie(0);   int t;   fin >> t;   for (int t_ = (1); t_ < (t + 1); ++t_) {     int H, W;     fin >> H >> W;     VS vs(H);     for (int y = (0); y < (H); ++y)       fin >> vs[y];      set<char> memo;     int y;     for (y = (0); y < (H); ++y)       for (int x = (0); x < (W); ++x) {         if (vs[y][x] != '?' && !memo.count(vs[y][x])) {           memo.insert(vs[y][x]);            int lx, rx, ty, by;           for (lx = x - 1; lx >= 0; --lx)             if (vs[y][lx] != '?')               break;           ++lx;           for (rx = x + 1; rx < W; ++rx)             if (vs[y][rx] != '?')               break;            for (ty = y - 1; ty >= 0; --ty) {             bool ok = 1;              for (int xx = lx; xx < rx; ++xx) {               if (vs[ty][xx] != '?')                 ok = false;             }             if (!ok)               break;           }           ++ty;           for (by = y + 1; by < H; ++by) {             bool ok = true;             for (int xx = lx; xx < rx; ++xx) {               if (vs[by][xx] != '?')                 ok = false;             }             if (!ok)               break;           }            for (int yy = (ty); yy < (by); ++yy)             for (int xx = (lx); xx < (rx); ++xx)               vs[yy][xx] = vs[y][x];         }       }      printf("Case #%d:\n", t_);     for (int y = (0); y < (H); ++y)       printf("%s\n", vs[y].c_str());   }   return ret_val; }
#include <bits/stdc++.h> #include <iostream> #include <utility> #include <vector> using namespace std; 
const int INF = 1000000000; typedef long double ld; typedef long long ll;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &is, pair<S, T> &p) {   return is >> p.first >> p.second; }  template <class T> void maxi(T &x, T y) {   if (x < y)     x = y; }  
int main() {   ios::sync_with_stdio(false);    freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_9_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/okaduki/outer_temp/okaduki/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_9_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/okaduki/A-small-practice.in",           "r", stdin);    cin.tie(0);    int T;   cin >> T;   for (int t_ = (1); t_ < (T + 1); ++t_) {     int H, W;     cin >> H >> W;     VS vs(H);     for (int y = (0); y < (H); ++y)       cin >> vs[y];      set<char> memo;     for (int y = (0); y < (H); ++y)       for (int x = (0); x < (W); ++x) {         if (vs[y][x] != '?' && !memo.count(vs[y][x])) {           memo.insert(vs[y][x]);            int lx, rx, ty, by;           for (lx = x - 1; lx >= 0; --lx)             if (vs[y][lx] != '?')               break;           ++lx;           for (rx = x + 1; rx < W; ++rx)             if (vs[y][rx] != '?')               break;            for (ty = y - 1; ty >= 0; --ty) {             bool ok = 1;             for (int xx = lx; xx < rx; ++xx) {               if (vs[ty][xx] != '?')                 ok = false;             }             if (!ok)               break;           }           ++ty;           for (by = y + 1; by < H; ++by) {             bool ok = true;             for (int xx = lx; xx < rx; ++xx) {               if (vs[by][xx] != '?')                 ok = false;             }             if (!ok)               break;           }            for (int yy = (ty); yy < (by); ++yy)             for (int xx = (lx); xx < (rx); ++xx)               vs[yy][xx] = vs[y][x];         }       }      cout << "Case #" << t_ << ":" << endl;     for (int y = (0); y < (H); ++y)       cout << vs[y] << endl;   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <fstream> #include <iostream> #include <map> #include <math.h> #include <sstream> #include <stdlib.h> #include <unordered_map> #include <utility> using namespace std; 
ofstream fout;  typedef long long ll; typedef pair<int, int> pii; typedef long double ld; typedef set<int> si;  ifstream n;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &b, pair<S, T> &p) {   return b >> p.first >> p.second; } template <class S, class T> ostream &operator<<(ostream &t, const pair<S, T> &p) {   return t << p.first << " " << p.second; } template <class T> void maxi(T &x, T y) {   if (x < y)     x = y; } template <class T> void mini(T &x, T y) {   if (x > y)     x = y; }  const double EPS = 1e-10; const double PI = acos(-1.0); const LL MOD = 1e9 + 7;  inline void hqjtlfpugi(VS &vs, int &by, int &xx, _Bool &ok) {   if (vs[by][xx] != '?')     ok = 0; }  inline void qsbibnnrnc(VS &vs, int &ty, int &xx, _Bool &ok) {   if (vs[ty][xx] != '?')     ok = false; }  
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_9_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/okaduki/outer_temp/okaduki/A-small-practice_transformation.out");    n.open("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_9_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/okaduki/A-small-practice.in");    cin.tie(0);    int T;   n >> T;   for (int d = (1); d < (T + 1); ++d) {     int H, W;     n >> H >> W;     VS vs(H);     for (int y = (0); y < (H); ++y)       n >> vs[y];      set<char> memo;     for (int y = (0); y < (H); ++y)       for (int x = (0); x < (W); ++x) {         if (vs[y][x] != '?')           if (!memo.count(vs[y][x])) {             memo.insert(vs[y][x]);              int lx, rx, ty, by;             for (lx = x - 1; lx >= 0; --lx)               if (vs[y][lx] != '?')                 break;             ++lx;             {               rx = x + 1;               while (rx < W) {                 if (vs[y][rx] != '?')                   break;                 ++rx;               }             }              for (ty = y - 1; ty >= 0; --ty) {               bool ok = true;               for (int xx = lx; xx < rx; ++xx)                 qsbibnnrnc(vs, ty, xx, ok);               if (!ok)                 break;             }             ++ty;             {               by = y + 1;               while (by < H) {                 bool ok = true;                 for (int xx = lx; xx < rx; ++xx)                   hqjtlfpugi(vs, by, xx, ok);                 if (!ok)                   break;                 ++by;               }             }              for (int yy = (ty); yy < (by); ++yy)               for (int xx = (lx); xx < (rx); ++xx)                 vs[yy][xx] = vs[y][x];           }       }      fout << "Case #" << d << ":" << endl;     for (int y = (0); y < (H); ++y)       fout << vs[y] << endl;   }    return 0; }
#include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <cstdio> #include <cstdlib> #include <ctime> #include <fstream> #include <functional> #include <math.h> #include <numeric> #include <set> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;
typedef long long ll; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef unsigned long long ull; typedef vector<int> vi;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &ans, pair<S, T> &p) {   return ans >> p.first >> p.second; } template <class S, class T> ostream &operator<<(ostream &v, const pair<S, T> &p) {   return v << p.first << " " << p.second; } template <class T> void get(T &x, T y) {   if (x < y)     x = y; } template <class T> void mini(T &x, T y) {   if (x > y)     x = y; }  inline void tvlhskalxl(int &H, VS &vs) {   int y = (0);   while (y < (H)) {     cout << vs[y] << endl;     ++y;   } }  inline void axplssdcfa(VS &vs, int &ty, int &xx, _Bool &ok) {   if (vs[ty][xx] != '?')     ok = false; }  inline void aqzqjctyyz(VS &vs, int &ty, _Bool &ok, int &xx) {   axplssdcfa(vs, ty, xx, ok);   ++xx; }  
int main() {   cin.tie(0);   ios_base::sync_with_stdio(0);    int t;   cin >> t;   for (int N = (1); N < (t + 1); ++N) {     int H, W;     cin >> H >> W;     VS vs(H);     for (int y = (0); y < (H); ++y)       cin >> vs[y];      set<char> memo;     for (int y = (0); y < (H); ++y)       for (int x = (0); x < (W); ++x) {         if (vs[y][x] != '?' && !memo.count(vs[y][x])) {           memo.insert(vs[y][x]);            int lx, rx, ty, by;           for (lx = x - 1; lx >= 0; --lx)             if (vs[y][lx] != '?')               break;           ++lx;           for (rx = x + 1; rx < W; ++rx)             if (vs[y][rx] != '?')               break;            {             ty = y - 1;             for (; ty >= 0;) {               bool ok = true;               {                 int xx = lx;                 while (xx < rx)                   aqzqjctyyz(vs, ty, ok, xx);               }               if (!ok)                 break;               --ty;             }           }           ++ty;           for (by = y + 1; by < H; ++by) {             bool ok = 1;             for (int xx = lx; xx < rx; ++xx) {               if (vs[by][xx] != '?')                 ok = false;             }             if (!ok)               break;           }            for (int yy = (ty); yy < (by); ++yy)             for (int xx = (lx); xx < (rx); ++xx)               vs[yy][xx] = vs[y][x];         }       }      cout << "Case #" << N << ":" << endl;     tvlhskalxl(H, vs);   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <limits> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
 int T;  typedef long long ll; typedef pair<int, int> pii; typedef pair<int, int> PII; typedef vector<int> vi; typedef long double LD;  int n, m, cs;  char mp[100][100]; int L[100], R[100], U[100], D[100]; vector<int> color; inline void fxcjlljrqj(int &ck, int &i, int &id) {   ck &= (mp[i][L[id] - 1] == '?'); }  void pushl(int id) {   while (L[id] > 1) {     int ck = 1;      int i;     for (i = U[id]; ck && i <= D[id]; i++)       fxcjlljrqj(ck, i, id);     if (ck)       L[id]--;     else       break;   } } void pushr(int id) {   while (R[id] < m) {     int ck = 1;     for (int i = U[id]; ck && i <= D[id]; i++) {       ck &= (mp[i][R[id] + 1] == '?');     }     if (ck)       R[id]++;     else       break;   } } void pushu(int id) {   while (U[id] > 0) {     int ck = 1;     for (int i = L[id]; ck && i <= R[id]; i++) {       ck &= (mp[U[id] - 1][i] == '?');     }     if (ck)       U[id]--;     else       break;   } } void pushd(int id) {   while (D[id] < n) {     int ck = 1;     for (int i = L[id]; ck && i <= R[id]; i++) {       ck &= (mp[D[id] + 1][i] == '?');     }     if (ck)       D[id]++;     else       break;   } } 
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_10_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/kuzphi/outer_temp/kuzphi/A-small-practice_transformation.out",           "w", stdout);    ios::sync_with_stdio(1);    freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_10_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/kuzphi/A-small-practice.in",           "r", stdin);    cin >> T;   while (T--) {     cout << "Case #" << ++cs << ": \n";     cin >> n >> m;     for (int i = 1; i <= n; i++)       cin >> (mp[i] + 1);     for (int i = 0; i <= 27; i++) {       L[i] = U[i] = 10000;       R[i] = D[i] = -1;     }     color.clear();     for (int i = 1; i <= n; i++) {       for (int j = 1; j <= m; j++) {         if (mp[i][j] == '?')           continue;         int id = mp[i][j] - 'A';         color.push_back(id);         L[id] = min(L[id], j);         R[id] = max(R[id], j);         U[id] = min(U[id], i);         D[id] = max(D[id], i);       }     }     for (int i = 0; i < color.size(); i++) {       pushl(color[i]);       pushr(color[i]);       pushu(color[i]);       pushd(color[i]);       for (int x = U[color[i]]; x <= D[color[i]]; x++)         for (int y = L[color[i]]; y <= R[color[i]]; y++)           mp[x][y] = 'A' + color[i];     }     for (int i = 1; i <= n; i++) {       cout << (mp[i] + 1) << endl;     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <limits> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;  
int T;  const double eps = 1e-9; const int MOD = 1000000007; typedef long double ld; typedef pair<int, int> ii; typedef pair<int, int> PII; typedef vector<int> VI; typedef set<int> si; typedef vector<vector<int>> vvi;  ifstream fin;  int n, t, cs;  char mp[100][100]; int L[100], R[100], U[100], D[100]; vector<int> color; void pushl(int id) {   while (L[id] > 1) {     int ck = 1;     for (int i = U[id]; ck && i <= D[id]; i++) {       ck &= (mp[i][L[id] - 1] == '?');     }     if (ck)       L[id]--;     else       break;   } } void pushr(int id) {   for (; R[id] < t;) {     int ck = 1;     for (int i = U[id]; ck && i <= D[id]; i++) {       ck &= (mp[i][R[id] + 1] == '?');     }     if (ck)       R[id]++;     else       break;   } } void pushu(int id) {   while (U[id] > 0) {     int ck = 1;     for (int i = L[id]; ck && i <= R[id]; i++) {       ck &= (mp[U[id] - 1][i] == '?');     }     if (ck)       U[id]--;     else       break;   } } void pushd(int id) {   while (D[id] < n) {     int ck = 1;     for (int i = L[id]; ck && i <= R[id]; i++) {       ck &= (mp[D[id] + 1][i] == '?');     }     if (ck)       D[id]++;     else       break;   } } inline void xfpoqbhidh(int &i, int &x) {   for (int y = L[color[i]]; y <= R[color[i]]; y++)     mp[x][y] = 'A' + color[i];   x++; }  
int main() {    fin.open("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_10_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/kuzphi/A-small-practice.in");    fin >> T;   while (T--) {     cout << "Case #" << ++cs << ": \n";     fin >> n >> t;     for (int i = 1; i <= n; i++)       fin >> (mp[i] + 1);     for (int i = 0; i <= 27; i++) {       L[i] = U[i] = 10000;       R[i] = D[i] = -1;     }     color.clear();     for (int i = 1; i <= n; i++) {       for (int j = 1; j <= t; j++) {         if (mp[i][j] == '?')           continue;         int id = mp[i][j] - 'A';         color.push_back(id);         L[id] = min(L[id], j);         R[id] = max(R[id], j);         U[id] = min(U[id], i);         D[id] = max(D[id], i);       }     }     for (int i = 0; i < color.size(); i++) {       pushl(color[i]);       pushr(color[i]);       pushu(color[i]);       pushd(color[i]);       {         int x = U[color[i]];         while (x <= D[color[i]])           xfpoqbhidh(i, x);       }     }     for (int i = 1; i <= n; i++) {       cout << (mp[i] + 1) << "\n";     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <limits> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;  
int solve;  typedef pair<int, int> PII; typedef long double LD; typedef long long ll; typedef long long LL; typedef unsigned long long ull; typedef vector<int> VI; typedef set<int> si; typedef vector<vector<int>> vvi;  int n, m, cs;  char mp[100][100]; int L[100], R[100], U[100], D[100]; vector<int> color; void pushl(int id) {   while (L[id] > 1) {     int ck = 1;     for (int i = U[id]; ck && i <= D[id]; i++) {       ck &= (mp[i][L[id] - 1] == '?');     }     if (ck)       L[id]--;     else       break;   } } void pushr(int id) {   while (R[id] < m) {     int ck = 1;     for (int i = U[id]; ck && i <= D[id]; i++) {       ck &= (mp[i][R[id] + 1] == '?');     }     if (ck)       R[id]++;     else       break;   } } void pushu(int id) {   while (U[id] > 0) {     int ck = 1;     for (int i = L[id]; ck && i <= R[id]; i++) {       ck &= (mp[U[id] - 1][i] == '?');     }     if (ck)       U[id]--;     else       break;   } } void pushd(int id) {   while (D[id] < n) {     int ck = 1;     for (int i = L[id]; ck && i <= R[id]; i++) {       ck &= (mp[D[id] + 1][i] == '?');     }     if (ck)       D[id]++;     else       break;   } } 
int main() {   ios::sync_with_stdio(1);    cin >> solve;   while (solve--) {     cout << "Case #" << ++cs << ": \n";     cin >> n >> m;     for (int i = 1; i <= n; i++)       cin >> (mp[i] + 1);     for (int i = 0; i <= 27; i++) {       L[i] = U[i] = 10000;       R[i] = D[i] = -1;     }     color.clear();     for (int i = 1; i <= n; i++) {       int j = 1;       while (j <= m) {         if (mp[i][j] == '?') {           j++;           continue;         }         int id = mp[i][j] - 'A';         color.push_back(id);         L[id] = min(L[id], j);         R[id] = max(R[id], j);         U[id] = min(U[id], i);         D[id] = max(D[id], i);         j++;       }     }     for (int i = 0; i < color.size(); i++) {       pushl(color[i]);       pushr(color[i]);       pushu(color[i]);       pushd(color[i]);       for (int x = U[color[i]]; x <= D[color[i]]; x++)         for (int y = L[color[i]]; y <= R[color[i]]; y++)           mp[x][y] = 'A' + color[i];     }     for (int i = 1; i <= n; i++) {       cout << (mp[i] + 1) << endl;     }   }   return 0; }
#include <algorithm> #include <bitset> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iostream> #include <limits> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <unordered_map> #include <vector> using namespace std;  
int T;  int n, m, cs;  char mp[100][100]; int L[100], R[100], U[100], D[100]; vector<int> color; void pushl(int id) {   while (L[id] > 1) {     int ck = 1;     for (int i = U[id]; ck && i <= D[id]; i++) {       ck &= (mp[i][L[id] - 1] == '?');     }     if (ck)       L[id]--;     else       break;   } } void pushr(int id) {   while (R[id] < m) {     int ck = 1;     for (int i = U[id]; ck && i <= D[id]; i++) {       ck &= (mp[i][R[id] + 1] == '?');     }     if (ck)       R[id]++;     else       break;   } } void pushu(int id) {   while (U[id] > 0) {     int ck = 1;     for (int i = L[id]; ck && i <= R[id]; i++) {       ck &= (mp[U[id] - 1][i] == '?');     }     if (ck)       U[id]--;     else       break;   } } void pushd(int id) {   while (D[id] < n) {     int ck = 1;     for (int i = L[id]; ck && i <= R[id]; i++) {       ck &= (mp[D[id] + 1][i] == '?');     }     if (ck)       D[id]++;     else       break;   } } 
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_10_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/kuzphi/A-small-practice.in", "r", stdin);    int ret_val = 0;   cin >> T;   while (T--) {     printf("Case #%d: \n", ++cs);     cin >> n >> m;     for (int i = 1; i <= n; i++)       cin >> (mp[i] + 1);     for (int i = 0; i <= 27; i++) {       L[i] = U[i] = 10000;       R[i] = D[i] = -1;     }     color.clear();     for (int i = 1; i <= n; i++)       for (int j = 1; j <= m; j++) {         if (mp[i][j] == '?')           continue;         int id = mp[i][j] - 'A';         color.push_back(id);         L[id] = min(L[id], j);         R[id] = max(R[id], j);         U[id] = min(U[id], i);         D[id] = max(D[id], i);       }     for (int i = 0; i < color.size(); i++) {       pushl(color[i]);       pushr(color[i]);       pushu(color[i]);       pushd(color[i]);       for (int x = U[color[i]]; x <= D[color[i]]; x++)         for (int y = L[color[i]]; y <= R[color[i]]; y++)           mp[x][y] = 'A' + color[i];     }     for (int i = 1; i <= n; i++) {       cout << (mp[i] + 1) << endl;     }   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
const int MOD = 1000000007; const int MAXN = 1005; ofstream fout;  ifstream fin;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  ll gcd(ll a, ll b) {   ll t;   while ((t = a % b) != 0) {     a = b;     b = t;   }   return b; }  ll get(ll p, ll n, ll tc) {   if (n == 0)     return 1;   ll t = get(p, n / 2, tc);   if (n % 2 == 0)     return (t * t) % tc;   else     return (((t * t) % tc) * p) % tc; }  bool is_set(int i, ll N) { return (N >> i) & 1; }  int count_bits(ll N) {   int ans = 0;   for (int i = 0; i < 64; ++i)     if (is_set(i, N))       ++ans;   return ans; }  int first_bit(ll N) {   int i = 0;   while (i < 64)     if (is_set(i++, N))       return i - 1;   return -1; }  
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_11_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ibrahim5253/outer_temp/ibrahim5253/A-small-practice_transformation.out");    fin.open("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_11_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ibrahim5253/A-small-practice.in");    int t;   fin >> t;   {     int i = 1;     while (i <= t) {       int r, c;       fin >> r >> c;       vector<vector<pii>> v;       vector<std::string> cake(r);       for (int i = 0; i < r; ++i)         fin >> cake[i];       for (int i = 0; i < r; ++i) {         vector<pii> vec;         for (int j = 0; j < c; ++j)           if (cake[i][j] != '?')             vec.push_back(make_pair(i, j));         if (!vec.empty())           v.push_back(vec);       }       int sr = 0;       int L = v.size();       for (int i = 0; i < L; ++i) {         int er = (i == L - 1 ? r - 1 : v[i][0].first);         int d = v[i].size();         int sc = 0;         for (int j = 0; j < d; ++j) {           int ec = (j == d - 1 ? c - 1 : v[i][j].second);           {             int x = sr;             while (x <= er) {               for (int y = sc; y <= ec; ++y)                 cake[x][y] = cake[v[i][j].first][v[i][j].second];               ++x;             }           }           sc = v[i][j].second + 1;         }         sr = v[i][0].first + 1;       }       fout << "Case #" << i << ":\n";       for (int i = 0; i < r; ++i)         fout << cake[i] << "\n";       ++i;     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <cstring> #include <deque> #include <fstream> #include <iostream> #include <iterator> #include <list> #include <map> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
const long double PI = 3.1415926535897932384626433832795;  typedef long double ld; typedef long long LL; typedef pair<int, int> PII; typedef vector<int> VI; typedef long double LD;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  ll solve(ll a, ll b) {   ll t;   for (; (t = a % b) != 0;) {     a = b;     b = t;   }   return b; }  ll get(ll tc, ll n, ll m) {   if (n == 0)     return 1;   ll t = get(tc, n / 2, m);   if (n % 2 == 0)     return (t * t) % m;   else     return (((t * t) % m) * tc) % m; }  bool do__Bohun_fct(int i, ll mask) { return (mask >> i) & 1; }  int count_bits(ll mask) {   int ans = 0;   for (int i = 0; i < 64; ++i)     if (do__Bohun_fct(i, mask))       ++ans;   return ans; }  
int main() {   ios::sync_with_stdio(false);   int t;   cin >> t;   for (int i = 1; i <= t; ++i) {     int r, c;     cin >> r >> c;     vector<vector<pii>> v;     string cake[r];     for (int i = 0; i < r; ++i)       cin >> cake[i];     for (int i = 0; i < r; ++i) {       vector<pii> vec;       for (int j = 0; j < c; ++j) {         if (cake[i][j] != '?')           vec.push_back(make_pair(i, j));       }       if (!vec.empty())         v.push_back(vec);     }     int sr = 0;     int L = v.size();     for (int i = 0; i < L; ++i) {       int er = (i == L - 1 ? r - 1 : v[i][0].first);       int p = v[i].size();       int sc = 0;       for (int j = 0; j < p; ++j) {         int ec = (j == p - 1 ? c - 1 : v[i][j].second);         for (int x = sr; x <= er; ++x) {           for (int y = sc; y <= ec; ++y)             cake[x][y] = cake[v[i][j].first][v[i][j].second];         }         sc = v[i][j].second + 1;       }       sr = v[i][0].first + 1;     }     cout << "Case #" << i << ":\n";     for (int i = 0; i < r; ++i)       cout << cake[i] << "\n";   }   return 0; }
#include <algorithm> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
typedef long long LL; typedef pair<int, int> PII; typedef vector<int> VI; typedef long double LD; typedef set<int> si;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  ll gcd(ll a, ll b) {   ll t;   while ((t = a % b) != 0) {     a = b;     b = t;   }   return b; }  ll fast_exp(ll T, ll n, ll m) {   if (n == 0)     return 1;   ll t = fast_exp(T, n / 2, m);   if (n % 2 == 0)     return (t * t) % m;   else     return (((t * t) % m) * T) % m; }  bool is_set(int i, ll mask) { return (mask >> i) & 1; }  int get(ll mask) {   int ans = 0;   for (int i = 0; i < 64; ++i)     if (is_set(i, mask))       ++ans;   return ans; }  inline void zgvvexaclc(int &r, vector<std::string> &cake) {   int i = 0;   while (i < r) {     printf("%s\n", cake[i].c_str());     ++i;   } }  inline void cowbmgxekl(int &c, vector<std::string> &cake, int &i,                        vector<vector<pii>> &v) {   vector<pii> vec;   for (int j = 0; j < c; ++j)     if (cake[i][j] != '?')       vec.push_back(make_pair(i, j));   if (!vec.empty())     v.push_back(vec); }  
int main() {   int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_11_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/ibrahim5253/A-small-practice.in",           "r", stdin);   int t;   scanf("%d ", &t);   for (int i = 1; i <= t; ++i) {     int r, c;     scanf("%d %d ", &r, &c);     vector<vector<pii>> v;     vector<std::string> cake(r);     for (int i = 0; i < r; ++i)       cin >> cake[i];     for (int i = 0; i < r; ++i)       cowbmgxekl(c, cake, i, v);     int sr = 0;     int L = v.size();     for (int i = 0; i < L; ++i) {       int er = (i == L - 1 ? r - 1 : v[i][0].first);       int l = v[i].size();       int sc = 0;       {         int j = 0;         while (j < l) {           int ec = (j == l - 1 ? c - 1 : v[i][j].second);           for (int x = sr; x <= er; ++x)             for (int y = sc; y <= ec; ++y)               cake[x][y] = cake[v[i][j].first][v[i][j].second];           sc = v[i][j].second + 1;           ++j;         }       }       sr = v[i][0].first + 1;     }     printf("Case #%d:\n", i);     zgvvexaclc(r, cake);   }   return ret_val; }
#include <algorithm> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
const double EPS = 1e-9; using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  ll gcd(ll a, ll b) {   ll t;   for (; (t = a % b) != 0;) {     a = b;     b = t;   }   return b; }  bool get(int i, ll N) { return (N >> i) & 1; }  int count_bits(ll N) {   int ans = 0;   for (int i = 0; i < 64; ++i)     if (get(i, N))       ++ans;   return ans; }  int solve(ll N) {   int i = 0;   while (i < 64)     if (get(i++, N))       return i - 1;   return -1; }  inline void onjvbmmivw(int &l, int &c, int &sr, int &er,                        vector<std::string> &cake, int &sc,                        vector<vector<pii>> &v, int &i, int &j) {   int ec = (j == l - 1 ? c - 1 : v[i][j].second);   for (int x = sr; x <= er; ++x)     for (int y = sc; y <= ec; ++y)       cake[x][y] = cake[v[i][j].first][v[i][j].second];   sc = v[i][j].second + 1; }  
int main() {   int ret_val = 0;   int t;   cin >> t;   for (int i = 1; i <= t; ++i) {     int r, c;     cin >> r >> c;     vector<vector<pii>> v;     vector<std::string> cake(r);     {       int i = 0;       while (i < r) {         cin >> cake[i];         ++i;       }     }     for (int i = 0; i < r; ++i) {       vector<pii> vec;       for (int j = 0; j < c; ++j)         if (cake[i][j] != '?')           vec.push_back(make_pair(i, j));       if (!vec.empty())         v.push_back(vec);     }     int sr = 0;     int L = v.size();     for (int i = 0; i < L; ++i) {       int er = (i == L - 1 ? r - 1 : v[i][0].first);       int l = v[i].size();       int sc = 0;       for (int j = 0; j < l; ++j)         onjvbmmivw(l, c, sr, er, cake, sc, v, i, j);       sr = v[i][0].first + 1;     }     printf("Case #%d:\n", i);     for (int i = 0; i < r; ++i)       printf("%s\n", cake[i].c_str());   }   return ret_val; }
#include <bits/stdc++.h> #include <iostream> #include <set> #include <utility> #include <vector> using namespace std; 
const int INF = 1000000000; typedef unsigned long long ull; typedef vector<int> vi; typedef long long ll; typedef pair<int, int> ii; typedef pair<int, int> PII; typedef long double ld; typedef set<int> si;  using LL = long long;  int tc, x;  inline void bxlbhtxnww(int &p, std::string &s, int &c) {   if (s[c] != '?')     while (p <= c)       s[p++] = s[c]; }  string convert(string s) {   int p, c;   for (p = 0, c = 0; s[c]; c++)     bxlbhtxnww(p, s, c);   if (!p)     return s;   while (s[--c] == '?')     s[c] = s[p - 1];   return s; }  inline void dxqikbzvxm(int &p, vector<std::string> &get, int &c) {   string s;   cin >> s;   s = convert(s);   get.push_back(s);   if (s[0] != '?')     while (p <= c)       get[p++] = get[c]; }  
int main() {   ios::sync_with_stdio(0);    freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_12_Usenix_RF_1.0_True_MCTS_Classic_True/Mucosolvan/jiian/A-small-practice.in",           "r", stdin);    cin >> tc;   while (tc--) {     vector<string> get;     int n, m;     cin >> n >> m;     int p = 0, c;     for (c = 0; c < n; c++)       dxqikbzvxm(p, get, c);     while (get[--c][0] == '?')       get[c] = get[p - 1];     printf("Case #%d:\n", ++x);     for (auto s : get)       printf("%s\n", s.c_str());   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <queue> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
typedef pair<int, int> pii; typedef unsigned long long ull; typedef vector<int> VI; typedef long double ld; typedef set<int> si; typedef vector<vector<int>> vvi;  using LL = long long;  int T, N;  inline void liluwaziri(int &p, std::string &s, int &i) {   p = 0, i = 0;   while (s[i]) {     if (s[i] != '?')       while (p <= i)         s[p++] = s[i];     i++;   } }  string convert(string s) {   int p, i;   liluwaziri(p, s, i);   if (!p)     return s;   while (s[--i] == '?') {     s[i] = s[p - 1];   }   return s; }  
int main() {   int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_12_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/jiian/A-small-practice.in",           "r", stdin);   scanf("%d ", &T);   while (T--) {     vector<string> a;     int n, m;     scanf("%d %d ", &n, &m);     int p = 0, i;     for (i = 0; i < n; i++) {       string s;       cin >> s;       s = convert(s);       a.push_back(s);       if (s[0] != '?')         while (p <= i)           a[p++] = a[i];     }     while (a[--i][0] == '?')       a[i] = a[p - 1];     cout << "Case #" << ++N << ":\n";     for (auto s : a)       cout << s << "\n";   }   return ret_val; }
#include <bits/stdc++.h> #include <iomanip> #include <iostream> #include <stdio.h> using namespace std; 
const int mod = 1000000007; const int MOD = 1000000007; using LL = long long;  int b, t;  string convert(string solve) {   int p, i;   {     p = 0, i = 0;     while (solve[i]) {       if (solve[i] != '?')         while (p <= i)           solve[p++] = solve[i];       i++;     }   }   if (!p)     return solve;   while (solve[--i] == '?')     solve[i] = solve[p - 1];   return solve; }  inline void vesdyudwct(int &p, vector<std::string> &get, int &i) {   string solve;   cin >> solve;   solve = convert(solve);   get.push_back(solve);   if (solve[0] != '?')     while (p <= i) {       get[p++] = get[i];     } }  
int main() {   ios::sync_with_stdio(false);    cin >> b;   while (b--) {     vector<string> get;     int n, m;     cin >> n >> m;     int p = 0, i;     for (i = 0; i < n; i++)       vesdyudwct(p, get, i);     while (get[--i][0] == '?')       get[i] = get[p - 1];     printf("Case #%d:\n", ++t);     for (auto solve : get)       printf("%s\n", solve.c_str());   }   return 0; }
#include <bits/stdc++.h> using namespace std;
using LL = long long;  int tt, cas;  inline void tpsqzqlhdr(int &p, std::string &s, int &i) {   if (s[i] != '?')     while (p <= i)       s[p++] = s[i]; }  string convert(string s) {   int p, i;   for (p = 0, i = 0; s[i]; i++)     tpsqzqlhdr(p, s, i);   if (!p)     return s;   while (s[--i] == '?')     s[i] = s[p - 1];   return s; }  
int main() {   int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_12_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/jiian/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_12_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/jiian/outer_temp/jiian/A-small-practice_transformation.out",           "w", stdout);   cin >> tt;   while (tt--) {     vector<string> a;     int n, m;     cin >> n >> m;     int p = 0, i;     {       i = 0;       while (i < n) {         string s;         cin >> s;         s = convert(s);         a.push_back(s);         if (s[0] != '?')           while (p <= i)             a[p++] = a[i];         i++;       }     }     while (a[--i][0] == '?')       a[i] = a[p - 1];     printf("Case #%d:\n", ++cas);     for (auto s : a)       printf("%s\n", s.c_str());   }   return ret_val; }
#include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <functional> #include <iomanip> #include <map> #include <math.h> #include <numeric> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <utility> #include <vector> using namespace std; 
typedef long long LL; typedef pair<int, int> PII; typedef unsigned long long ull; typedef vector<int> VI; typedef long double LD; typedef vector<vector<int>> vvi;  int n, m; char s[50][50]; 
int main(void) {   int ret_val = 0;   int get;   scanf("%d", &get);   for (int T = 1; T <= get; T++) {     scanf("%d%d", &n, &m);     for (int i = 0; i < n; ++i)       scanf("%s", s[i]);      int ufx, ufy = 0;     for (int i = 0; i < n; ++i) {       ufx = 0;       bool fill = false;       for (int j = 0; j < m; ++j) {         if (s[i][j] == '?')           continue;         fill = 1;         int st = ufx, ed = j + 1;         for (; ed < m && s[i][ed] == '?'; ++ed)           ;         for (int x = st; x < ed; ++x)           for (int y = ufy; y <= i; ++y)             s[y][x] = s[i][j];         ufx = ed;       }       if (fill)         ufy = i + 1;     }      for (int i = 0; i < n; ++i)       for (int j = 0; j < m; ++j)         if (s[i][j] == '?') {           s[i][j] = s[i - 1][j];         }      printf("Case #%d:\n", T);     for (int i = 0; i < n; ++i)       printf("%s\n", s[i]);   }   return ret_val; }
#include <algorithm> #include <cstdio> #include <cstring> #include <iostream> using namespace std; 
int n, m; char s[50][50]; 
int main(void) {   int t;   cin >> t;   for (int tt = 1; tt <= t; tt++) {     cin >> n >> m;     for (int get = 0; get < n; ++get)       cin >> s[get];      int solve, ufy = 0;     for (int get = 0; get < n; ++get) {       solve = 0;       bool fill = false;       for (int j = 0; j < m; ++j) {         if (s[get][j] == '?')           continue;         fill = true;         int st = solve, ed = j + 1;         for (; ed < m && s[get][ed] == '?'; ++ed)           ;         for (int x = st; x < ed; ++x)           for (int y = ufy; y <= get; ++y)             s[y][x] = s[get][j];         solve = ed;       }       if (fill)         ufy = get + 1;     }      for (int get = 0; get < n; ++get)       for (int j = 0; j < m; ++j)         if (s[get][j] == '?') {           s[get][j] = s[get - 1][j];         }      printf("Case #%d:\n", tt);     for (int get = 0; get < n; ++get)       printf("%s\n", s[get]);   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> using namespace std; 
int n, m; char s[50][50]; 
int main(void) {   int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_13_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/iPeter/A-small-practice.in",           "r", stdin);   int ans;   scanf("%d", &ans);   for (int tt = 1; tt <= ans; tt++) {     scanf("%d%d", &n, &m);     for (int i = 0; i < n; ++i)       scanf("%s", s[i]);      int ufx, ufy = 0;     for (int i = 0; i < n; ++i) {       ufx = 0;       bool fill = false;       for (int cc = 0; cc < m; ++cc) {         if (s[i][cc] == '?')           continue;         fill = true;         int st = ufx, ed = cc + 1;         for (; ed < m && s[i][ed] == '?'; ++ed)           ;         for (int x = st; x < ed; ++x)           for (int y = ufy; y <= i; ++y)             s[y][x] = s[i][cc];         ufx = ed;       }       if (fill)         ufy = i + 1;     }      for (int i = 0; i < n; ++i)       for (int cc = 0; cc < m; ++cc)         if (s[i][cc] == '?') {           s[i][cc] = s[i - 1][cc];         }      printf("Case #%d:\n", tt);     for (int i = 0; i < n; ++i)       printf("%s\n", s[i]);   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <iomanip> #include <iostream> using namespace std;  
int n, m; char s[50][50]; inline void bcqfljodgo(int &i, int &tc) { s[i][tc] = s[i - 1][tc]; }  inline void ctdifuhtmr(int &i) {   for (int tc = 0; tc < m; ++tc) {     if (s[i][tc] == '?')       bcqfljodgo(i, tc);   }   ++i; }  
int main(void) {   int ret_val = 0;   int t;   cin >> t;   for (int tt = 1; tt <= t; tt++) {     cin >> n >> m;     for (int i = 0; i < n; ++i)       cin >> s[i];      int ufx, ufy = 0;     for (int i = 0; i < n; ++i) {       ufx = 0;       bool fill = false;        for (int tc = 0; tc < m; ++tc) {         if (s[i][tc] == '?')           continue;         fill = 1;         int st = ufx, ed = tc + 1;         for (; ed < m && s[i][ed] == '?'; ++ed)           ;         for (int x = st; x < ed; ++x)           for (int y = ufy; y <= i; ++y)             s[y][x] = s[i][tc];         ufx = ed;       }       if (fill)         ufy = i + 1;     }      {       int i = 0;       while (i < n)         ctdifuhtmr(i);     }      cout << "Case #" << tt << ":\n";     {       int i = 0;       for (; i < n;) {         cout << s[i] << "\n";         ++i;       }     }   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstring> #include <ctime> #include <fstream> #include <iostream> #include <iterator> #include <map> #include <math.h> #include <numeric> #include <stdio.h> #include <string>  using namespace std;
ifstream fin;  const int INF = 1000000000;  long long get(long long v, long long p, long long mod = (1000000007LL)) {   long long ans = 1;   while (p) {     if (p & 1)       ans = (ans * v) % mod;     v = (v * v) % mod;     p /= 2;   }   return ans; }  long long solve(long long a, long long b) {   if (b == 0)     return a;   return solve(b, a % b); }  int r, c; char arr[26][26];  
int main() {   fin.open("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_14_Usenix_RF_1.0_True_MCTS_Classic_True/Thanabhat/satyaki3794/A-small-practice.in");    cin.tie(0);    int t, x = 1;   fin >> t;    for (; t--;) {      fin >> r >> c;     int i;     for (i = 1; i <= r; i++)       fin >> (arr[i] + 1);      for (int i = 1; i <= r; i++)       for (int j = 1; j <= c; j++)         if (arr[i][j] != '?') {            int miny = j, maxy = j;            int y = j - 1;           while (y >= 1 && arr[i][y] == '?') {             arr[i][y--] = arr[i][j];             miny = y + 1;           }            y = j + 1;           while (y <= c && arr[i][y] == '?') {             arr[i][y++] = arr[i][j];             maxy = y - 1;           }         }      queue<pair<int, int>> qq;     for (int i = 1; i <= r; i++)       if (arr[i][1] != '?') {          int x = i - 1;         while (x >= 1 && arr[x][1] == '?') {           int j2;           for (j2 = 1; j2 <= c; j2++)             arr[x][j2] = arr[x + 1][j2];           x--;         }          x = i + 1;         while (x <= r && arr[x][1] == '?') {           for (int j2 = 1; j2 <= c; j2++)             arr[x][j2] = arr[x - 1][j2];           x++;         }       }      cout << "Case #" << x++ << ":" << endl;     for (int i = 1; i <= r; i++)       cout << (arr[i] + 1) << endl;   }    return 0; }
#include <bits/stdc++.h> #include <stdio.h>  using namespace std;  
long long pwr(long long base, long long p, long long mod = (1000000007LL)) {   long long ans = 1;   while (p) {     if (p & 1)       ans = (ans * base) % mod;     base = (base * base) % mod;     p /= 2;   }   return ans; }  long long gcd(long long a, long long b) {   if (b == 0)     return a;   return gcd(b, a % b); }  int r, c; char arr[26][26];  
int main() {   int ret_val = 0;   ios_base::sync_with_stdio(0);   cin.tie(0);   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_14_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/satyaki3794/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_14_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/satyaki3794/outer_temp/satyaki3794/A-small-practice_transformation.out",           "w", stdout);   int t, x = 1;   cin >> t;   while (t--) {      cin >> r >> c;     for (int i = 1; i <= r; i++)       cin >> (arr[i] + 1);      for (int i = 1; i <= r; i++) {       int j = 1;       while (j <= c) {         if (arr[i][j] != '?') {            int miny = j, maxy = j;            int y = j - 1;           while (y >= 1 && arr[i][y] == '?') {             arr[i][y--] = arr[i][j];             miny = y + 1;           }            y = j + 1;           while (y <= c && arr[i][y] == '?') {             arr[i][y++] = arr[i][j];             maxy = y - 1;           }         }         j++;       }     }     queue<pair<int, int>> qq;     {       int i = 1;       while (i <= r) {         if (arr[i][1] != '?') {            int x = i - 1;           while (x >= 1 && arr[x][1] == '?') {             for (int j2 = 1; j2 <= c; j2++)               arr[x][j2] = arr[x + 1][j2];             x--;           }            x = i + 1;           while (x <= r && arr[x][1] == '?') {             for (int j2 = 1; j2 <= c; j2++)               arr[x][j2] = arr[x - 1][j2];             x++;           }         }         i++;       }     }     printf("Case #%d:\n", x++);     for (int i = 1; i <= r; i++)       printf("%s\n", (arr[i] + 1));   }   return ret_val; }
#include <bits/stdc++.h>  using namespace std; 
typedef long long td_ll; typedef pair<int, int> ii; typedef pair<int, ii> iii;  long long pwr(long long base, long long p, long long mod = (1000000007LL)) {   td_ll ans = 1;   while (p) {     if (p & 1)       ans = (ans * base) % mod;     base = (base * base) % mod;     p /= 2;   }   return ans; }  int r, c; char arr[26][26];  
int main() {   int ret_val = 0;   cin.tie(0);   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_13_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/satyaki3794/A-small-practice.in",           "r", stdin);   int t, x = 1;   cin >> t;   while (t--) {      cin >> r >> c;     for (int i = 1; i <= r; i++)       cin >> (arr[i] + 1);      for (int i = 1; i <= r; i++)       for (int j = 1; j <= c; j++)         if (arr[i][j] != '?') {            int miny = j, maxy = j;            int y = j - 1;           for (; y >= 1 && arr[i][y] == '?';) {             arr[i][y--] = arr[i][j];             miny = y + 1;           }            y = j + 1;           while (y <= c && arr[i][y] == '?') {             arr[i][y++] = arr[i][j];             maxy = y - 1;           }         }      queue<ii> qq;     for (int i = 1; i <= r; i++)       if (arr[i][1] != '?') {          int x = i - 1;         while (x >= 1 && arr[x][1] == '?') {           for (int j2 = 1; j2 <= c; j2++)             arr[x][j2] = arr[x + 1][j2];           x--;         }          x = i + 1;         while (x <= r && arr[x][1] == '?') {           for (int j2 = 1; j2 <= c; j2++)             arr[x][j2] = arr[x - 1][j2];           x++;         }       }      cout << "Case #" << x++ << ":" << endl;     for (int i = 1; i <= r; i++)       cout << (arr[i] + 1) << endl;   }   return ret_val; }
#include <bits/stdc++.h> #include <stdio.h>  using namespace std; 
typedef long long ll; typedef pair<int, int> ii; typedef pair<int, ii> iii;  ll gcd(ll a, ll b) {   if (b == 0)     return a;   return gcd(b, a % b); }  int r, c; char arr[26][26];  
int main() {   int ret_val = 0;   ios_base::sync_with_stdio(0);   cin.tie(0);   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_13_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/satyaki3794/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_13_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/satyaki3794/outer_temp/satyaki3794/A-small-practice_transformation.out",           "w", stdout);   int t, x = 1;   cin >> t;   while (t--) {      cin >> r >> c;     for (int i = 1; i <= r; i++)       cin >> (arr[i] + 1);      for (int i = 1; i <= r; i++)       for (int j = 1; j <= c; j++)         if (arr[i][j] != '?') {            int miny = j, maxy = j;            int y = j - 1;           while (y >= 1 && arr[i][y] == '?') {             arr[i][y--] = arr[i][j];             miny = y + 1;           }            y = j + 1;           while (y <= c && arr[i][y] == '?') {             arr[i][y++] = arr[i][j];             maxy = y - 1;           }         }      queue<ii> qq;     for (int i = 1; i <= r; i++)       if (arr[i][1] != '?') {          int x = i - 1;         while (x >= 1 && arr[x][1] == '?') {           for (int j2 = 1; j2 <= c; j2++)             arr[x][j2] = arr[x + 1][j2];           x--;         }          x = i + 1;         while (x <= r && arr[x][1] == '?') {           for (int j2 = 1; j2 <= c; j2++)             arr[x][j2] = arr[x - 1][j2];           x++;         }       }      printf("Case #%d:\n", x++);     for (int i = 1; i <= r; i++)       printf("%s\n", (arr[i] + 1));   }   return ret_val; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> using namespace std;
inline void nllhugozay(int &c, vector<std::string> &v, int &i) {   for (int j = 0; j < c; ++j) {     printf("%c", v[i][j]);   }   printf("\n"); }  int main(int tt, char **ans) {   int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_15_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out",           "w", stdout);   ifstream cc("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_15_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/gultai4ukr/A-small-practice.in");   int bzii_Var;   cc >> bzii_Var;   for (int testcase = 0; testcase < bzii_Var; ++testcase) {     int r, c;     cc >> r >> c;     vector<string> v(r);     for (int i = 0; i < r; ++i) {       cc >> v[i];      }      for (int i = 0; i < r; ++i) {       for (int j = 0; j < c; ++j) {         if (v[i][j] == '?') {           int dist = c, index = j;           for (int glgi_Var = 0; glgi_Var < c; ++glgi_Var) {             if (v[i][glgi_Var] != '?') {               if (abs(j - glgi_Var) < dist) {                 dist = abs(j - glgi_Var);                 index = glgi_Var;               }             }           }           for (int glgi_Var = min(j, index); glgi_Var < max(j, index) + 1;                ++glgi_Var) {             v[i][glgi_Var] = v[i][index];           }         }       }     }      {       int i = 0;       while (i < r) {         if (v[i][0] == '?') {           int dist = r, index = -1;           for (int glgi_Var = 0; glgi_Var < r; ++glgi_Var) {             if (v[glgi_Var][0] != '?') {               if (abs(i - glgi_Var) < dist) {                 dist = abs(i - glgi_Var);                 index = glgi_Var;               }             }           }           assert(index >= 0);           for (int j = 0; j < c; ++j) {             v[i][j] = v[index][j];           }         }         ++i;       }     }      printf("Case #%d:\n", testcase + 1);     for (int i = 0; i < r; ++i)       nllhugozay(c, v, i);   }   cc.close();   return ret_val; }
#include <bits/stdc++.h> #include <iostream> #include <utility> using namespace std; 
typedef pair<int, int> pii; typedef double dbl;  
int main(int n, char **wtfc_Var) {   int ret_val = 0;    ofstream m("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_14_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out");   int t;   cin >> t;   for (int uami_Var = 0; uami_Var < t; ++uami_Var) {     int cpwi_Var, c;     cin >> cpwi_Var >> c;     vector<string> tezv_Var(cpwi_Var);     for (int i = 0; i < cpwi_Var; ++i) {       cin >> tezv_Var[i];       }      for (int i = 0; i < cpwi_Var; ++i) {       for (int tc = 0; tc < c; ++tc) {         if (tezv_Var[i][tc] == '?') {           int dist = c, index = tc;            for (int knci_Var = 0; knci_Var < c; ++knci_Var) {             if (tezv_Var[i][knci_Var] != '?') {               if (abs(tc - knci_Var) < dist) {                 dist = abs(tc - knci_Var);                 index = knci_Var;               }             }           }           for (int knci_Var = min(tc, index); knci_Var < max(tc, index) + 1;                ++knci_Var) {             tezv_Var[i][knci_Var] = tezv_Var[i][index];           }         }       }     }      {       int i = 0;       for (; i < cpwi_Var;) {         if (tezv_Var[i][0] == '?') {           int dist = cpwi_Var, index = -1;           for (int knci_Var = 0; knci_Var < cpwi_Var; ++knci_Var) {             if (tezv_Var[knci_Var][0] != '?') {               if (abs(i - knci_Var) < dist) {                 dist = abs(i - knci_Var);                 index = knci_Var;               }             }           }           assert(index >= 0);           for (int tc = 0; tc < c; ++tc) {             tezv_Var[i][tc] = tezv_Var[index][tc];           }         }         ++i;       }     }      m << "Case #" << uami_Var + 1 << ":" << endl;     for (int i = 0; i < cpwi_Var; ++i) {       for (int tc = 0; tc < c; ++tc) {         m << tezv_Var[i][tc];       }       m << endl;     }   }    m.close();   return ret_val; }
#include <bits/stdc++.h> #include <iostream> #include <set> #include <stdio.h> #include <utility> #include <vector> using namespace std;
const int MAXN = 1005; const double EPS = 1e-9; typedef set<int> si; typedef unsigned long long ull; typedef long double LD; typedef long long ll; typedef pair<int, int> pii; typedef vector<int> vi; typedef vector<int> VI; typedef vector<vector<int>> vvi;  
int main(int argc, char **q) {   ios::sync_with_stdio(1);    freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_14_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/gultai4ukr/A-small-practice.in",           "r", stdin);    int ret_val = 0;    ofstream fout("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_14_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out");   int t;   scanf("%d ", &t);   for (int y = 0; y < t; ++y) {     int r, c;     scanf("%d %d ", &r, &c);     vector<string> v(r);     for (int i = 0; i < r; ++i) {       cin >> v[i];        }      for (int i = 0; i < r; ++i) {       for (int j = 0; j < c; ++j) {         if (v[i][j] == '?') {           int dist = c, index = j;           for (int n = 0; n < c; ++n) {             if (v[i][n] != '?') {               if (abs(j - n) < dist) {                 dist = abs(j - n);                 index = n;               }             }           }           for (int n = min(j, index); n < max(j, index) + 1; ++n) {             v[i][n] = v[i][index];           }         }       }     }      for (int i = 0; i < r; ++i) {       if (v[i][0] == '?') {         int dist = r, index = -1;         for (int n = 0; n < r; ++n) {           if (v[n][0] != '?') {             if (abs(i - n) < dist) {               dist = abs(i - n);               index = n;             }           }         }         assert(index >= 0);         for (int j = 0; j < c; ++j) {           v[i][j] = v[index][j];         }       }     }      fout << "Case #" << y + 1 << ":" << endl;     for (int i = 0; i < r; ++i) {       for (int j = 0; j < c; ++j) {         fout << v[i][j];       }       fout << endl;     }   }    fout.close();   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> using namespace std; 
inline void gplegswhnj(std::ifstream &fin, vector<std::string> &v, int &solve) {   fin >> v[solve];  }  inline void dfirdpentu(int &dist, int &j, int &index, int &k) {   dist = abs(j - k);   index = k; }  inline void xopcdmrdqc(int &r, int &c, int &solve, vector<std::string> &v) {   if (v[solve][0] == '?') {     int dist = r, index = -1;     for (int k = 0; k < r; ++k) {       if (v[k][0] != '?') {         if (abs(solve - k) < dist) {           dist = abs(solve - k);           index = k;         }       }     }     assert(index >= 0);     for (int j = 0; j < c; ++j)       v[solve][j] = v[index][j];   } }  inline void dnrkkxkbvm(int &dist, int &j, int &index, int &k) {   if (abs(j - k) < dist)     dfirdpentu(dist, j, index, k); }  
int main(int argc, char **argv) {   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_14_Usenix_RF_1.0_True_MCTS_Classic_True/try/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out",           "w", stdout);    ifstream fin("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_14_Usenix_RF_1.0_True_MCTS_Classic_True/try/gultai4ukr/A-small-practice.in");    int t;   fin >> t;   {     int get = 0;     while (get < t) {       int r, c;       fin >> r >> c;       vector<string> v(r);       for (int solve = 0; solve < r; ++solve) {         gplegswhnj(fin, v, solve);       }        for (int solve = 0; solve < r; ++solve) {         for (int j = 0; j < c; ++j) {           if (v[solve][j] == '?') {             int dist = c, index = j;             for (int k = 0; k < c; ++k) {               if (v[solve][k] != '?')                 dnrkkxkbvm(dist, j, index, k);             }             for (int k = min(j, index); k < max(j, index) + 1; ++k)               v[solve][k] = v[solve][index];           }         }       }        for (int solve = 0; solve < r; ++solve)         xopcdmrdqc(r, c, solve, v);        printf("Case #%d:\n", get + 1);       for (int solve = 0; solve < r; ++solve) {         for (int j = 0; j < c; ++j) {           printf("%c", v[solve][j]);         }         printf("\n");       }       ++get;     }   }    fin.close();    return 0; }
#include <bits/stdc++.h> #include <stdio.h>  using namespace std; 
typedef vector<int> vi; typedef long long ll; typedef long double ld; typedef pair<int, int> pii; typedef pair<pii, int> para; const int inf = 1e9 + 7; const int maxN = 100 + 5;  int t, k, n; int can[maxN][maxN]; string s[maxN];  
int main() {   int ret_val = 0;    scanf("%d ", &t);   for (int x = (1); x <= ((t)); ++x) {     scanf("%d %d ", &n, &k);     for (int i = (0); i <= ((n)-1); ++i)       cin >> s[i];      int pom = -1;     for (int i = (0); i <= ((n)-1); ++i) {       for (int j = (0); j <= ((k)-1); ++j) {         if (s[i][j] != '?')           if ((pom == i || pom == -1)) {             for (int l = (0); l <= ((n)-1); ++l) {               for (int m = (0); m <= ((k)-1); ++m) {                 if (s[l][m] == '?' && l <= i && m <= j) {                   s[l][m] = s[i][j];                 }               }             }             pom = i;           }           if (pom != -1 && i > pom)           break;       }       if (pom != -1 && i > pom)         break;     }      for (int i = (0); i <= ((n)-1); ++i) {       int pos = -1;       for (int j = (0); j <= ((k)-1); ++j) {         if (s[i][j] != '?') {           pos = j;           break;         }       }        if (pos != -1) {         char first = s[i][pos];         for (int j = (0); j <= ((k)-1); ++j) {           if (s[i][j] == '?') {             s[i][j] = first;           } else {             first = s[i][j];           }         }       } else {         for (int j = (0); j <= ((k)-1); ++j)           s[i][j] = s[i - 1][j];       }     }      cout << "Case #" << x << ": " << endl;     for (int i = (0); i <= ((n)-1); ++i) {       cout << s[i] << endl;     }   }   return ret_val; }
#include <bits/stdc++.h> #include <stdio.h>  using namespace std; 
typedef vector<int> vi; typedef long long ll; typedef long double ld; typedef pair<int, int> pii; typedef pair<pii, int> para; const int inf = 1e9 + 7; const int maxN = 100 + 5;  int t, k, n; int can[maxN][maxN]; string s[maxN];  
int main() {   int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_15_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/Mucosolvan/A-small-practice.in",           "r", stdin);   scanf("%d ", &t);   for (int x = (1); x <= ((t)); ++x) {     scanf("%d %d ", &n, &k);     for (int i = (0); i <= ((n)-1); ++i)       cin >> s[i];      int pom = -1;     for (int i = (0); i <= ((n)-1); ++i) {       for (int j = (0); j <= ((k)-1); ++j) {         if (s[i][j] != '?' && (pom == i || pom == -1)) {           for (int l = (0); l <= ((n)-1); ++l) {             for (int m = (0); m <= ((k)-1); ++m) {               if (s[l][m] == '?' && l <= i && m <= j) {                 s[l][m] = s[i][j];               }             }           }           pom = i;         }                if (pom != -1 && i > pom)           break;       }       if (pom != -1 && i > pom)         break;     }      for (int i = (0); i <= ((n)-1); ++i) {       int pos = -1;       for (int j = (0); j <= ((k)-1); ++j) {         if (s[i][j] != '?') {           pos = j;           break;         }       }        if (pos != -1) {         char first = s[i][pos];         for (int j = (0); j <= ((k)-1); ++j) {           if (s[i][j] == '?') {             s[i][j] = first;           } else {             first = s[i][j];           }         }       } else {         for (int j = (0); j <= ((k)-1); ++j)           s[i][j] = s[i - 1][j];       }     }      cout << "Case #" << x << ": " << endl;     for (int i = (0); i <= ((n)-1); ++i) {       cout << s[i] << endl;     }   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std;
ifstream fin;  typedef unsigned long long ull; typedef long long ll;  const int inf = 1e9 + 7; const int maxN = 100 + 5;  int t, a, n; int can[maxN][maxN]; string s[maxN];  inline void hcmrvtmcqm(char &first, int &i, int &j) { first = s[i][j]; }  
int main() {   fin.open("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_15_Usenix_RF_1.0_True_MCTS_Classic_True/try/Mucosolvan/A-small-practice.in");    freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_15_Usenix_RF_1.0_True_MCTS_Classic_True/try/Mucosolvan/outer_temp/Mucosolvan/A-small-practice_transformation.out",           "w", stdout);    fin >> t;   int x;   for (x = (1); x <= ((t)); ++x) {     fin >> n >> a;     for (int i = (0); i <= ((n)-1); ++i)       fin >> s[i];      int pom = -1;     for (int i = (0); i <= ((n)-1); ++i) {       for (int j = (0); j <= ((a)-1); ++j) {         if (s[i][j] != '?' && (pom == i || pom == -1)) {           for (int l = (0); l <= ((n)-1); ++l) {             for (int m = (0); m <= ((a)-1); ++m) {               if (s[l][m] == '?' && l <= i && m <= j) {                 s[l][m] = s[i][j];               }             }           }           pom = i;         }                 if (pom != -1 && i > pom) {           break;         }       }       if (pom != -1 && i > pom)         break;     }      for (int i = (0); i <= ((n)-1); ++i) {       int pos = -1;       {         int j = (0);         while (j <= ((a)-1)) {           if (s[i][j] != '?') {             pos = j;             break;           }           ++j;         }       }        if (pos != -1) {         char first = s[i][pos];         for (int j = (0); j <= ((a)-1); ++j) {           if (s[i][j] == '?') {             s[i][j] = first;           } else             hcmrvtmcqm(first, i, j);         }       } else {         for (int j = (0); j <= ((a)-1); ++j)           s[i][j] = s[i - 1][j];       }     }      printf("Case #%d: \n", x);     for (int i = (0); i <= ((n)-1); ++i) {       printf("%s\n", s[i].c_str());     }   }   return 0; }
#include <bits/stdc++.h> #include <fstream>  using namespace std; 
ofstream fout;  const int inf = 1e9 + 7; const int maxN = 100 + 5;  int t, k, n; int can[maxN][maxN]; string s[maxN];  inline void get() {   int i = (0);   while (i <= ((n)-1)) {     cin >> s[i];     ++i;   } }  inline void tjievqbzck(int &solve, int &m, int &i, int &j) {   s[solve][m] = s[i][j]; }  
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_15_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Mucosolvan/outer_temp/Mucosolvan/A-small-practice_transformation.out");    int ret_val = 0;   ios_base::sync_with_stdio(0);   cin >> t;   {     int x = (1);     while (x <= ((t))) {       cin >> n >> k;       get();        int pom = -1;       for (int i = (0); i <= ((n)-1); ++i) {         for (int j = (0); j <= ((k)-1); ++j) {           if (s[i][j] != '?' && (pom == i || pom == -1)) {             for (int solve = (0); solve <= ((n)-1); ++solve) {               for (int m = (0); m <= ((k)-1); ++m) {                 if (s[solve][m] == '?' && solve <= i && m <= j)                   tjievqbzck(solve, m, i, j);               }             }             pom = i;           }                      if (pom != -1 && i > pom)             break;         }         if (pom != -1 && i > pom) {           break;         }       }        for (int i = (0); i <= ((n)-1); ++i) {         int pos = -1;         for (int j = (0); j <= ((k)-1); ++j) {           if (s[i][j] != '?') {             pos = j;             break;           }         }          if (pos != -1) {           char first = s[i][pos];           for (int j = (0); j <= ((k)-1); ++j) {             if (s[i][j] == '?')               s[i][j] = first;             else {               first = s[i][j];             }           }         } else {           for (int j = (0); j <= ((k)-1); ++j)             s[i][j] = s[i - 1][j];         }       }        fout << "Case #" << x << ": " << endl;       for (int i = (0); i <= ((n)-1); ++i)         fout << s[i] << endl;        ++x;     }   }   return ret_val; }
#include <bitset> #include <deque> #include <iomanip> #include <iostream> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std; 
const double EPS = 1e-9;  typedef vector<int> vi; typedef vector<vi> vvi; typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long LL;            typedef unsigned long long ULL;  typedef unsigned uint;    struct debugger {   template <typename T> debugger &operator,(const T &v) {     cerr << v << " ";     return *this;   } };  char str[50][50]; bool vis[50][50]; inline void oykdgtskzx(int &j, int &i, int &a) {   str[i][a] = str[i][j];   vis[i][a] = true;   a++; }  inline void nqrrzzxgyu(int &i, int &j, int &a) {   str[a][j] = str[i][j];   vis[a][j] = true;   a--; }  inline void hvitxjouhq(int &i) { cin >> str[i]; }  inline void rqaumeeomb(int &l, int &j, int &a, int &c, int &r, int &i) {   scanf("%d", &r);   ;   scanf("%d", &l);   ;   memset((vis), (0), sizeof(vis));   for (i = 0; i < r; i++)     hvitxjouhq(i);   for (i = 0; i < r; i++) {     for (j = 0; j < l; j++) {       if (str[i][j] != '?' && !vis[i][j]) {         a = i - 1;         while (a >= 0 && str[a][j] == '?')           nqrrzzxgyu(i, j, a);         a = i + 1;         while (a < r && str[a][j] == '?') {           str[a][j] = str[i][j];           vis[a][j] = 1;           a++;         }       }     }   }    memset((vis), (0), sizeof(vis));   for (i = 0; i < r; i++) {     for (j = 0; j < l; j++) {       if (str[i][j] != '?' && !vis[i][j]) {         a = j - 1;         while (a >= 0 && str[i][a] == '?') {           str[i][a] = str[i][j];           vis[i][a] = true;           a--;         }         a = j + 1;         while (a < l && str[i][a] == '?')           oykdgtskzx(j, i, a);       }     }   }   printf("Case #%d:\n", c++);   for (i = 0; i < r; i++) {     printf("%s\n", str[i]);   } }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_16_Usenix_RF_1.0_True_MCTS_Classic_True/try/lazyBit/A-small-practice.in",           "r", stdin);    freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_16_Usenix_RF_1.0_True_MCTS_Classic_True/try/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);     int n, i, j, a, l, q, t, s = 0, d, r;   scanf("%d", &t);   ;   int c = 1;   while (t--)     rqaumeeomb(l, j, a, c, r, i);   return (0); }
#include <bitset> #include <deque> #include <iomanip> #include <iostream> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std; 
const double EPS = 1e-9;  typedef vector<int> vi; typedef vector<vi> vvi; typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long LL;            typedef unsigned long long ULL;  typedef unsigned uint;    struct debugger {   template <typename T> debugger &operator,(const T &v) {     cerr << v << " ";     return *this;   } };  char str[50][50]; bool vis[50][50]; inline void oykdgtskzx(int &j, int &i, int &a) {   str[i][a] = str[i][j];   vis[i][a] = true;   a++; }  inline void nqrrzzxgyu(int &i, int &j, int &a) {   str[a][j] = str[i][j];   vis[a][j] = true;   a--; }  inline void hvitxjouhq(int &i) { cin >> str[i]; }  inline void rqaumeeomb(int &l, int &j, int &a, int &c, int &r, int &i) {   scanf("%d", &r);   ;   scanf("%d", &l);   ;   memset((vis), (0), sizeof(vis));   for (i = 0; i < r; i++)     hvitxjouhq(i);   for (i = 0; i < r; i++) {     for (j = 0; j < l; j++) {       if (str[i][j] != '?' && !vis[i][j]) {         a = i - 1;         while (a >= 0 && str[a][j] == '?')           nqrrzzxgyu(i, j, a);         a = i + 1;         while (a < r && str[a][j] == '?') {           str[a][j] = str[i][j];           vis[a][j] = 1;           a++;         }       }     }   }    memset((vis), (0), sizeof(vis));   for (i = 0; i < r; i++) {     for (j = 0; j < l; j++) {       if (str[i][j] != '?' && !vis[i][j]) {         a = j - 1;         while (a >= 0 && str[i][a] == '?') {           str[i][a] = str[i][j];           vis[i][a] = true;           a--;         }         a = j + 1;         while (a < l && str[i][a] == '?')           oykdgtskzx(j, i, a);       }     }   }   printf("Case #%d:\n", c++);   for (i = 0; i < r; i++) {     printf("%s\n", str[i]);   } }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_16_Usenix_RF_1.0_True_MCTS_Classic_True/try/lazyBit/A-small-practice.in",           "r", stdin);    freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_16_Usenix_RF_1.0_True_MCTS_Classic_True/try/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);     int n, i, j, a, l, q, t, s = 0, d, r;   scanf("%d", &t);   ;   int c = 1;   while (t--)     rqaumeeomb(l, j, a, c, r, i);   return (0); }
#include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <complex> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <queue> #include <set> #include <sstream> #include <stack>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std; 
ofstream fout;  typedef long double ld; typedef set<int> si; typedef vector<int> VI; typedef vector<VI> vvi; typedef pair<int, int> PII; typedef vector<PII> vii; typedef vector<string> vs;  typedef long long ll;            typedef unsigned long long ULL;   const double pi = acos(-1.0);  const double eps = 1e-11;      const int MAXI = 0x7fffffff; const int dx[] = {1, 0, -1, 0}; const int dy[] = {0, 1, 0, -1}; const char dz[] = "SENW"; struct debugger {  } p;  void solve(int *arr, int n) {   fout << "[";   for (int i = 0; i < n; i++)     fout << arr[i] << " ";   fout << "]" << endl; }  char str[50][50]; bool vis[50][50]; inline void hhagjfmyps(int &l, int &r, int &i, int &j, int &k) {   for (j = 0; j < l; j++) {     if (str[i][j] != '?' && !vis[i][j]) {       k = i - 1;       while (k >= 0 && str[k][j] == '?') {         str[k][j] = str[i][j];         vis[k][j] = true;         k--;       }       k = i + 1;       for (; k < r && str[k][j] == '?';) {         str[k][j] = str[i][j];         vis[k][j] = true;         k++;       }     }   } }  
int main() {   ios::sync_with_stdio(true);    fout.open("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_16_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out");     int n, i, j, k, l, m, t, s = 0, d, r;   scanf("%d", &t);   ;   int c = 1;   while (t--) {     scanf("%d", &r);     ;     scanf("%d", &l);     ;     memset((vis), (0), sizeof(vis));     {       i = 0;       while (i < r) {         cin >> str[i];         i++;       }     }     {       i = 0;       while (i < r) {         hhagjfmyps(l, r, i, j, k);         i++;       }     }      memset((vis), (0), sizeof(vis));     for (i = 0; i < r; i++) {       for (j = 0; j < l; j++) {         if (str[i][j] != '?' && !vis[i][j]) {           k = j - 1;           while (k >= 0 && str[i][k] == '?') {             str[i][k] = str[i][j];             vis[i][k] = 1;             k--;           }           k = j + 1;           while (k < l && str[i][k] == '?') {             str[i][k] = str[i][j];             vis[i][k] = true;             k++;           }         }       }     }     fout << "Case #" << c++ << ":\n";     for (i = 0; i < r; i++) {       fout << str[i] << endl;     }   }   return (0); }
#include <bitset> #include <climits> #include <complex> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <unordered_map>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std;  
typedef vector<int> vi; typedef vector<vi> vvi; typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long LL;            typedef unsigned long long ULL;  typedef unsigned uint;  const double pi = acos(-1.0);  const double eps = 1e-11;     const int MAXI = 0x7fffffff; const int dx[] = {1, 0, -1, 0}; const int dy[] = {0, 1, 0, -1}; const char dz[] = "SENW"; struct debugger {   template <typename T> debugger &operator,(const T &v) {     cerr << v << " ";     return *this;   } } dbg;  void debugarr(int *a, int n) {   cout << "[";   {     int i = 0;     while (i < n) {       cout << a[i] << " ";       i++;     }   }   cout << "]" << endl; }  char str[50][50]; bool vis[50][50]; inline void qcuadbifpo(int &j, int &i, int &x) {   str[i][x] = str[i][j];   vis[i][x] = true;   x++; }  inline void iyevkwoahv(int &l, int &j, int &i, int &x) {   if (str[i][j] != '?')     if (!vis[i][j]) {       x = j - 1;       while (x >= 0 && str[i][x] == '?') {         str[i][x] = str[i][j];         vis[i][x] = true;         x--;       }       x = j + 1;       while (x < l && str[i][x] == '?')         qcuadbifpo(j, i, x);     } }  inline void znlsxmmuga(int &r, int &i, int &j, int &x) {   x = i - 1;   for (; x >= 0 && str[x][j] == '?';) {     str[x][j] = str[i][j];     vis[x][j] = 1;     x--;   }   x = i + 1;   while (x < r && str[x][j] == '?') {     str[x][j] = str[i][j];     vis[x][j] = true;     x++;   } }  inline void qukshsovur(int &r, int &i, int &j, int &x) {   if (str[i][j] != '?' && !vis[i][j])     znlsxmmuga(r, i, j, x); }  inline void jmxqldrsje(int &l, int &j, int &x, int &c, int &r, int &i) {   cin >> r;   ;   cin >> l;   ;   memset((vis), (0), sizeof(vis));   for (i = 0; i < r; i++) {     cin >> str[i];   }   for (i = 0; i < r; i++) {     for (j = 0; j < l; j++)       qukshsovur(r, i, j, x);   }    memset((vis), (0), sizeof(vis));   for (i = 0; i < r; i++) {     for (j = 0; j < l; j++)       iyevkwoahv(l, j, i, x);   }   printf("Case #%d:\n", c++);   for (i = 0; i < r; i++) {     cout << str[i] << endl;   } }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_16_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_16_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/lazyBit/A-small-practice.in",           "r", stdin);      int n, i, j, x, l, m, t, s = 0, d, r;   cin >> t;   ;   int c = 1;   while (t--)     jmxqldrsje(l, j, x, c, r, i);   return (0); }
#include <bitset> #include <cctype> #include <climits> #include <cstdio> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string>  using namespace std; 
const long double PI = 3.1415926535897932384626433832795; const double eps = 1e-9;  inline void alpqxziyog(std::string str[30], int &i) {   printf("%s\n", str[i].c_str()); }  int solve(int p) {   int r, get;   scanf("%d %d ", &r, &get);   string str[30];   for (int i = 0; i < r; i++) {     cin >> str[i];   }   set<char> s;   for (int i = 0; i < r; i++) {     int j;     for (j = 0; j < get; j++) {       if (str[i][j] != '?')         if (s.find(str[i][j]) == s.end()) {              int jl = j, jr = j, it = i, ib = i;           while (jl - 1 >= 0 && str[i][jl - 1] == '?') {             jl--;           }           while (jr + 1 < get && str[i][jr + 1] == '?') {             jr++;           }           for (; true;) {             if (it - 1 >= 0) {               bool check = 1;               int k;               for (k = jl; k <= jr; k++) {                 if (str[it - 1][k] != '?') {                   check = false;                 }               }               if (check) {                 it--;               } else {                 break;               }             } else {               break;             }           }           while (true) {             if (ib + 1 < r) {               int check = true;               for (int k = jl; k <= jr; k++) {                 if (str[ib + 1][k] != '?') {                   check = false;                 }               }               if (check) {                 ib++;               } else {                 break;               }             } else {               break;             }           }           for (int k = it; k <= ib; k++) {             for (int l = jl; l <= jr; l++) {               str[k][l] = str[i][j];             }           }           s.insert(str[i][j]);         }     }   }   printf("Case #%d:\n", p);   for (int i = 0; i < r; i++)     alpqxziyog(str, i);   return 1; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_17_Usenix_RF_1.0_True_MCTS_Classic_True/try/Thanabhat/A-small-practice.in",           "r", stdin);    freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_17_Usenix_RF_1.0_True_MCTS_Classic_True/try/Thanabhat/outer_temp/Thanabhat/A-small-practice_transformation.out",           "w", stdout);    int t;   scanf("%d ", &t);   for (int i = 0; i < t; i++) {     solve(i + 1);   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdlib> #include <cstring> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <vector>  using namespace std; 
typedef long double ld; typedef long long LL; typedef unsigned long long ull; typedef vector<int> vi; typedef vector<int> VI; typedef set<int> si;  ifstream fin;  ofstream fout;  inline void gihpjgvsaf(int &k, int &l, std::string get[30], int &i, int &j) {   get[k][l] = get[i][j]; }  int solve(int cc) {   int ret_val = 1;   int r, c;   fin >> r >> c;   string get[30];   for (int i = 0; i < r; i++) {     fin >> get[i];   }   set<char> s;   for (int i = 0; i < r; i++) {     for (int j = 0; j < c; j++) {       if (get[i][j] != '?' && s.find(get[i][j]) == s.end()) {                  int jl = j, jr = j, it = i, ib = i;         while (jl - 1 >= 0 && get[i][jl - 1] == '?') {           jl--;         }         while (jr + 1 < c && get[i][jr + 1] == '?') {           jr++;         }         while (true) {           if (it - 1 >= 0) {             int check = true;             for (int k = jl; k <= jr; k++) {               if (get[it - 1][k] != '?') {                 check = false;               }             }             if (check) {               it--;             } else {               break;             }           } else {             break;           }         }         while (true) {           if (ib + 1 < r) {             bool check = true;             for (int k = jl; k <= jr; k++) {               if (get[ib + 1][k] != '?') {                 check = false;               }             }             if (check) {               ib++;             } else {               break;             }           } else {             break;           }         }         for (int k = it; k <= ib; k++) {           for (int l = jl; l <= jr; l++) {             gihpjgvsaf(k, l, get, i, j);           }         }         s.insert(get[i][j]);       }     }   }   fout << "Case #" << cc << ":" << endl;   for (int i = 0; i < r; i++) {     fout << get[i] << endl;   }   return ret_val; }  
int main() {   ios::sync_with_stdio(false);    int ret_val = 0;   fin.open("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_17_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Thanabhat/A-small-practice.in");   fout.open("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_17_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Thanabhat/outer_temp/Thanabhat/A-small-practice_transformation.out");   int t;   fin >> t;   for (int i = 0; i < t; i++) {     solve(i + 1);   }   return ret_val; }
#include <iostream> #include <set>  using namespace std; 
inline void yutelolrbo(int &ib) { ib++; }  inline void onkbqmedok(_Bool &check) { check = false; }  inline void nkctkgropg(int &k, int &l, std::string str[30], int &i, int &j) {   str[k][l] = str[i][j]; }  int solve(int cc) {   int r, c;   cin >> r >> c;   string str[30];   for (int i = 0; i < r; i++)     cin >> str[i];    set<char> s;   for (int i = 0; i < r; i++) {     for (int j = 0; j < c; j++) {       if (str[i][j] != '?' && s.find(str[i][j]) == s.end()) {                 int jl = j, jr = j, it = i, ib = i;         while (jl - 1 >= 0 && str[i][jl - 1] == '?') {           jl--;         }         while (jr + 1 < c && str[i][jr + 1] == '?') {           jr++;         }         while (true) {           if (it - 1 >= 0) {             bool check = true;             for (int k = jl; k <= jr; k++) {               if (str[it - 1][k] != '?')                 onkbqmedok(check);             }             if (check) {               it--;             } else {               break;             }           } else {             break;           }         }         while (true) {           if (ib + 1 < r) {             bool check = true;             for (int k = jl; k <= jr; k++) {               if (str[ib + 1][k] != '?') {                 check = false;               }             }             if (check)               yutelolrbo(ib);             else {               break;             }           } else {             break;           }         }         for (int k = it; k <= ib; k++) {           for (int l = jl; l <= jr; l++)             nkctkgropg(k, l, str, i, j);         }         s.insert(str[i][j]);       }     }   }   cout << "Case #" << cc << ":" << endl;   for (int i = 0; i < r; i++) {     cout << str[i] << endl;   }   return 1; }  
int main() {    freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_17_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/Thanabhat/outer_temp/Thanabhat/A-small-practice_transformation.out",           "w", stdout);    int get;   cin >> get;   for (int i = 0; i < get; i++) {     solve(i + 1);   }   return 0; }
#include <cassert> #include <cctype> #include <climits> #include <complex> #include <cstdio> #include <deque> #include <fstream> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility> #include <vector>  using namespace std; 
ofstream fout;  int get(int cc) {   int r, c;   cin >> r >> c;   vector<std::string> v(30);   for (int i = 0; i < r; i++) {     cin >> v[i];   }   set<char> s;   for (int i = 0; i < r; i++) {     for (int j = 0; j < c; j++) {       if (v[i][j] != '?' && s.find(v[i][j]) == s.end()) {                 int jl = j, jr = j, it = i, ib = i;         while (jl - 1 >= 0 && v[i][jl - 1] == '?') {           jl--;         }         while (jr + 1 < c && v[i][jr + 1] == '?') {           jr++;         }         while (true) {           if (it - 1 >= 0) {             bool check = true;             for (int a = jl; a <= jr; a++) {               if (v[it - 1][a] != '?') {                 check = false;               }             }             if (check) {               it--;             } else {               break;             }           } else {             break;           }         }         while (true) {           if (ib + 1 < r) {             bool check = true;             for (int a = jl; a <= jr; a++) {               if (v[ib + 1][a] != '?') {                 check = false;               }             }             if (check) {               ib++;             } else {               break;             }           } else {             break;           }         }         for (int a = it; a <= ib; a++) {           for (int l = jl; l <= jr; l++) {             v[a][l] = v[i][j];           }         }         s.insert(v[i][j]);       }     }   }   fout << "Case #" << cc << ":" << endl;   for (int i = 0; i < r; i++) {     fout << v[i] << endl;   }   return 1; }  
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_17_Usenix_RF_1.0_True_MCTS_Classic_True/WCG/Thanabhat/outer_temp/Thanabhat/A-small-practice_transformation.out");    int t;   cin >> t;   for (int i = 0; i < t; i++) {     get(i + 1);   }   return 0; }
#include <bits/stdc++.h> #include <fstream> #include <iomanip> #include <iostream>  using namespace std; 
ifstream fin;  ofstream fout;  char solve[77][77];  inline void hbuxsidxzi(int &i, int &get) { solve[i][get - 1] = solve[i][get]; }  inline void jqcfsayqmi(int &i, int &get) { solve[i + 1][get] = solve[i][get]; }  
int main() {   ios::sync_with_stdio(false);    fin.open("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_18_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/fragusbot/A-small-practice.in");    fout.open("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_18_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/fragusbot/outer_temp/fragusbot/A-small-practice_transformation.out");    int t;   fin >> t;   for (int cc = 1; cc <= t; ++cc) {     double begt = clock();     fout << "Case #" << cc << ":\n";     int n, m;     fin >> n >> m;     for (int i = 0; i < n; ++i) {       fin >> solve[i];     }     for (int i = 0; i < n; ++i) {       for (int get = 0; get < m - 1; ++get) {         if (solve[i][get] != '?' && solve[i][get + 1] == '?') {           solve[i][get + 1] = solve[i][get];         }       }       for (int get = m - 1; get > 0; --get) {         if (solve[i][get] != '?' && solve[i][get - 1] == '?')           hbuxsidxzi(i, get);       }     }     for (int i = 0; i < n - 1; ++i) {       int get;       for (get = 0; get < m; ++get) {         if (solve[i][get] != '?')           if (solve[i + 1][get] == '?')             jqcfsayqmi(i, get);       }     }     for (int i = n - 1; i > 0; --i) {       for (int get = 0; get < m; ++get) {         if (solve[i][get] != '?')           if (solve[i - 1][get] == '?') {             solve[i - 1][get] = solve[i][get];           }       }     }     for (int i = 0; i < n; ++i) {       fout << solve[i] << "\n";     }     fprintf(stderr, "case %d solved in %.3f\n", cc,             (clock() - begt) / CLOCKS_PER_SEC);   } }
#include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cstdio> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <queue> #include <set> #include <stdio.h> #include <stdlib.h>  using namespace std; 
char a[77][77];  inline void ntyybhsavz(int &i, int &j) {   if (a[i][j] != '?' && a[i - 1][j] == '?')     a[i - 1][j] = a[i][j]; }  inline void jtfmvrmqnk(int &m, int &i) {   for (int j = 0; j < m; ++j) {     if (a[i][j] != '?' && a[i + 1][j] == '?') {       a[i + 1][j] = a[i][j];     }   } }  inline void vebwxqxvfy(int &i, int &j) { a[i][j + 1] = a[i][j]; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_18_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/fragusbot/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_18_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/fragusbot/outer_temp/fragusbot/A-small-practice_transformation.out",           "w", stdout);   int tt;   cin >> tt;   for (int cc = 1; cc <= tt; ++cc) {     double begt = clock();     printf("Case #%d:\n", cc);     int n, m;     cin >> n >> m;     for (int i = 0; i < n; ++i) {       cin >> a[i];     }     for (int i = 0; i < n; ++i) {       for (int j = 0; j < m - 1; ++j) {         if (a[i][j] != '?' && a[i][j + 1] == '?')           vebwxqxvfy(i, j);       }       for (int j = m - 1; j > 0; --j) {         if (a[i][j] != '?' && a[i][j - 1] == '?') {           a[i][j - 1] = a[i][j];         }       }     }     for (int i = 0; i < n - 1; ++i)       jtfmvrmqnk(m, i);     for (int i = n - 1; i > 0; --i) {       for (int j = 0; j < m; ++j)         ntyybhsavz(i, j);     }     for (int i = 0; i < n; ++i) {       printf("%s\n", a[i]);     }     fprintf(stderr, "case %d solved in %.3f\n", cc,             (clock() - begt) / CLOCKS_PER_SEC);   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <utility> #include <vector>  using namespace std; 
const int MOD = 1000000007;  char a[77][77];  
int main() {   int solve;   cin >> solve;   for (int cc = 1; cc <= solve; ++cc) {     double t = clock();     cout << "Case #" << cc << ":\n";     int n, m;     cin >> n >> m;     int i;     for (i = 0; i < n; ++i) {       cin >> a[i];     }     for (int i = 0; i < n; ++i) {       {         int j = 0;         while (j < m - 1) {           if (a[i][j] != '?' && a[i][j + 1] == '?') {             a[i][j + 1] = a[i][j];           }           ++j;         }       }       for (int j = m - 1; j > 0; --j) {         if (a[i][j] != '?' && a[i][j - 1] == '?') {           a[i][j - 1] = a[i][j];         }       }     }     for (int i = 0; i < n - 1; ++i) {       for (int j = 0; j < m; ++j) {         if (a[i][j] != '?' && a[i + 1][j] == '?') {           a[i + 1][j] = a[i][j];         }       }     }     for (int i = n - 1; i > 0; --i) {       for (int j = 0; j < m; ++j) {         if (a[i][j] != '?' && a[i - 1][j] == '?') {           a[i - 1][j] = a[i][j];         }       }     }     for (int i = 0; i < n; ++i) {       cout << a[i] << "\n";     }     fprintf(stderr, "case %d solved in %.3f\n", cc,             (clock() - t) / CLOCKS_PER_SEC);   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <utility> #include <vector>  using namespace std; 
const int MAXN = 1005; typedef long long ll; typedef long long LL; typedef pair<int, int> PII; typedef unsigned long long ull; typedef vector<int> VI; typedef long double LD;  char a[77][77];  inline void bpwelrjmuk(int &i, int &get) { a[i][get + 1] = a[i][get]; }  
int main() {   ios::sync_with_stdio(false);    int t;   cin >> t;   for (int cc = 1; cc <= t; ++cc) {     double begt = clock();     printf("Case #%d:\n", cc);     int n, m;     cin >> n >> m;     for (int i = 0; i < n; ++i) {       cin >> a[i];     }     for (int i = 0; i < n; ++i) {       for (int get = 0; get < m - 1; ++get) {         if (a[i][get] != '?' && a[i][get + 1] == '?')           bpwelrjmuk(i, get);       }       for (int get = m - 1; get > 0; --get) {         if (a[i][get] != '?' && a[i][get - 1] == '?') {           a[i][get - 1] = a[i][get];         }       }     }     for (int i = 0; i < n - 1; ++i) {       for (int get = 0; get < m; ++get) {         if (a[i][get] != '?' && a[i + 1][get] == '?')           a[i + 1][get] = a[i][get];       }     }     for (int i = n - 1; i > 0; --i) {       for (int get = 0; get < m; ++get) {         if (a[i][get] != '?' && a[i - 1][get] == '?') {           a[i - 1][get] = a[i][get];         }       }     }     for (int i = 0; i < n; ++i) {       printf("%s\n", a[i]);     }     fprintf(stderr, "case %d solved in %.3f\n", cc,             (clock() - begt) / CLOCKS_PER_SEC);   }   return 0; }
#include <algorithm> #include <bitset> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <iostream> #include <map> #include <queue> #include <set> #include <stdio.h> #include <string> #include <vector> #pragma comment(linker, "/STACK:256000000")  using namespace std; 
const int MOD = 1000000007; const double eps = 1e-9;  void get() {}  const int maxN = 50; string s[maxN]; int n, m;  inline void tjoiuvpqjh(int &i) { cin >> s[i]; }  inline void geguuqxxzm() {   int i = 0;   while (i < n) {     for (int j = 1; j < m; ++j) {       if (s[i][j] == '?') {         s[i][j] = s[i][j - 1];       }     }     for (int j = m - 2; j >= 0; --j) {       if (s[i][j] == '?') {         s[i][j] = s[i][j + 1];       }     }     ++i;   } }  inline void ihxgtvvxxu(int &i, int &j) {   if (s[i][j] == '?') {     s[i][j] = s[i + 1][j];   } }  void solve(int N) {   cin >> n >> m;   for (int i = 0; i < n; ++i)     tjoiuvpqjh(i);    geguuqxxzm();    for (int j = 0; j < m; ++j) {     for (int i = 1; i < n; ++i) {       if (s[i][j] == '?') {         s[i][j] = s[i - 1][j];       }     }     for (int i = n - 2; i >= 0; --i)       ihxgtvvxxu(i, j);   }    for (int i = 0; i < n; ++i) {     for (int j = 0; j < m; ++j) {       if (s[i][j] == '?') {         cerr << "BAD" << endl;       }     }   }    printf("Case #%d:\n", N);   for (int i = 0; i < n; ++i) {     printf("%s\n", s[i].c_str());   } }  
int main(int v, char *c[]) {   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_19_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/sdya/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_19_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/sdya/outer_temp/sdya/A-small-practice_transformation.out",           "w", stdout);    int p, q;     int t;   cin >> t;   p = 1, q = t;   for (int i = 1; i <= t; ++i) {     if (i >= p && i <= q) {       solve(i);     } else {       get();     }     cerr << i << ": " << clock() << endl;   }    return 0; }
#include <algorithm> #include <bitset> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <iomanip> #include <iostream> #include <map> #include <queue> #include <set> #include <string> #include <vector> #pragma comment(linker, "/STACK:256000000")  using namespace std; 
const double EPS = 1e-9;  void get() {}  const int maxN = 50; string s[maxN]; int n, m;  inline void vrjisgjayp(int &i, int &j) { s[i][j] = s[i][j + 1]; }  inline void qfvghqsbpy(int &i) {   int j = 1;   while (j < m) {     if (s[i][j] == '?') {       s[i][j] = s[i][j - 1];     }     ++j;   } }  void solve(int q) {   cin >> n >> m;   for (int i = 0; i < n; ++i) {     cin >> s[i];   }    for (int i = 0; i < n; ++i) {     qfvghqsbpy(i);     for (int j = m - 2; j >= 0; --j) {       if (s[i][j] == '?') {         vrjisgjayp(i, j);       }     }   }    for (int j = 0; j < m; ++j) {     for (int i = 1; i < n; ++i) {       if (s[i][j] == '?') {         s[i][j] = s[i - 1][j];       }     }     for (int i = n - 2; i >= 0; --i) {       if (s[i][j] == '?')         s[i][j] = s[i + 1][j];     }   }    for (int i = 0; i < n; ++i) {     for (int j = 0; j < m; ++j) {       if (s[i][j] == '?') {         cerr << "BAD" << endl;       }     }   }    cout << "Case #" << q << ":\n";   for (int i = 0; i < n; ++i) {     cout << s[i] << "\n";   } }  
int main(int r, char *x[]) {   int ret_val = 0;   int y, a;   int t;   cin >> t;   y = 1, a = t;   for (int i = 1; i <= t; ++i) {     if (i >= y && i <= a) {       solve(i);     } else {       get();     }     cerr << i << ": " << clock() << endl;   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <functional> #include <iomanip> #include <iostream> #include <map> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility> #include <vector> #pragma comment(linker, "/STACK:256000000")  using namespace std; 
const long double PI = 3.1415926535897932384626433832795;  typedef unsigned long long ull; typedef vector<int> vi; typedef vector<int> VI; typedef long double LD; typedef long long ll; typedef long long LL; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef set<int> si;  void get() {}  const int maxN = 50; string s[maxN]; int n, m;  inline void pdozeaphgz(int &i, int &j) {   if (s[i][j] == '?') {     s[i][j] = s[i - 1][j];   } }  void solve(int test) {   cin >> n >> m;   for (int i = 0; i < n; ++i) {     cin >> s[i];   }    for (int i = 0; i < n; ++i) {     for (int j = 1; j < m; ++j) {       if (s[i][j] == '?') {         s[i][j] = s[i][j - 1];       }     }     for (int j = m - 2; j >= 0; --j) {       if (s[i][j] == '?') {         s[i][j] = s[i][j + 1];       }     }   }    for (int j = 0; j < m; ++j) {     for (int i = 1; i < n; ++i)       pdozeaphgz(i, j);     for (int i = n - 2; i >= 0; --i) {       if (s[i][j] == '?') {         s[i][j] = s[i + 1][j];       }     }   }    for (int i = 0; i < n; ++i) {     for (int j = 0; j < m; ++j) {       if (s[i][j] == '?') {         cerr << "BAD" << endl;       }     }   }    printf("Case #%d:\n", test);   for (int i = 0; i < n; ++i) {     printf("%s\n", s[i].c_str());   } }  
int main(int argc, char *argv[]) {   int ret_val = 0;   ios::sync_with_stdio(false);   int left_bound, ans;   int t;   cin >> t;   left_bound = 1, ans = t;   for (int i = 1; i <= t; ++i) {     if (i >= left_bound && i <= ans) {       solve(i);     } else {       get();     }     cerr << i << ": " << clock() << endl;   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <iostream> #include <map> #include <queue> #include <set> #include <stdio.h> #include <string> #include <vector> #pragma comment(linker, "/STACK:256000000")  using namespace std; 
typedef vector<int> vi; typedef long long ll; typedef long long LL;  void readData() {}  const int maxN = 50; string s[maxN]; int n, m;  inline void ovzyuroifa(int &i, int &j) { s[i][j] = s[i - 1][j]; }  void solve(int test) {   scanf("%d %d ", &n, &m);   for (int i = 0; i < n; ++i) {     cin >> s[i];   }    for (int i = 0; i < n; ++i) {     for (int j = 1; j < m; ++j) {       if (s[i][j] == '?') {         s[i][j] = s[i][j - 1];       }     }     for (int j = m - 2; j >= 0; --j) {       if (s[i][j] == '?') {         s[i][j] = s[i][j + 1];       }     }   }    for (int j = 0; j < m; ++j) {     for (int i = 1; i < n; ++i) {       if (s[i][j] == '?')         ovzyuroifa(i, j);     }     for (int i = n - 2; i >= 0; --i) {       if (s[i][j] == '?') {         s[i][j] = s[i + 1][j];       }     }   }    for (int i = 0; i < n; ++i) {     for (int j = 0; j < m; ++j) {       if (s[i][j] == '?') {         cerr << "BAD" << endl;       }     }   }    printf("Case #%d:\n", test);   {     int i = 0;     while (i < n) {       printf("%s\n", s[i].c_str());       ++i;     }   } }  
int main(int argc, char *argv[]) {   int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_19_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sdya/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_5304486_5760761888505856_19_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sdya/outer_temp/sdya/A-small-practice_transformation.out",           "w", stdout);   int left_bound, right_bound;   int ct;   scanf("%d ", &ct);   left_bound = 1, right_bound = ct;   for (int i = 1; i <= ct; ++i) {     if (i >= left_bound && i <= right_bound) {       solve(i);     } else {       readData();     }     cerr << i << ": " << clock() << endl;   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stdio.h> #include <stdlib.h> #include <string> #include <vector> using namespace std; 
int tc;  long long d, n, a, b; vector<pair<long long, long long>> ks;  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_1_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/4yn/outer_temp/4yn/A-small-practice_transformation.out",           "w", stdout);   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_1_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/4yn/A-small-practice.in",           "r", stdin);   cin >> tc;   for (int t = 1; t <= tc; t++) {     ks.clear();     cin >> d >> n;     double lb, ub, ex;     lb = 0;     ub = 0;     for (int i = 0; i < n; i++) {       cin >> a >> b;       ks.push_back(pair<long long, long long>(a, b));       if (ub == 0) {         if (a != d) {           ub = d * b / (d - a + 0.0);         }       } else if (a != d) {         ub = min(ub, d * b / (d - a + 0.0));       }     }     while (abs(ub - lb) > 0.0000005f) {       ex = (ub + lb) / 2;       int p = true;        for (int i = 0; i < n; i++) {          if (ks[i].second >= ex)           continue;          if (ks[i].first / (ex - ks[i].second) * ex < d) {           p = false;         }       }       if (p) {         lb = ex;       } else {         ub = ex;       }     }     printf("Case #%d: %.7f\n", t, ub);   }   return 0; }
#include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
ofstream fout;  typedef double td_d;  const int INF = 1000000000;  int tc;  long long d, n, a, b; vector<pair<long long, long long>> ks;  
int main() {   fout.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_1_Usenix_RF_1.0_True_MCTS_Classic_True/WCG/4yn/outer_temp/4yn/A-small-practice_transformation.out");    cin >> tc;   for (int t = 1; t <= tc; t++) {     ks.clear();     cin >> d >> n;     td_d lb, ans, ex;     lb = 0;     ans = 0;     for (int i = 0; i < n; i++) {       cin >> a >> b;       ks.push_back(pair<long long, long long>(a, b));       if (ans == 0) {         if (a != d) {           ans = d * b / (d - a + 0.0);         }       } else if (a != d) {         ans = min(ans, d * b / (d - a + 0.0));       }     }     for (; abs(ans - lb) > 0.0000005f;) {       ex = (ans + lb) / 2;       int f = true;        for (int i = 0; i < n; i++) {                  if (ks[i].second >= ex) {           continue;         }           if (ks[i].first / (ex - ks[i].second) * ex < d)           f = false;       }       if (f) {         lb = ex;       } else {         ans = ex;       }     }     fout << fixed << setprecision(7) << "Case #" << t << ": " << ans << endl;   }   return 0; }
#include <bits/stdc++.h> #include <fstream> #include <iostream> #include <set> #include <utility> #include <vector> using namespace std;
ofstream fout;  typedef set<int> si; typedef vector<vector<int>> vvi; typedef long double ld; typedef pair<int, int> PII; typedef unsigned long long ull; typedef vector<int> vi; typedef long double LD; typedef long long ll; typedef pair<ll, ll> pii; typedef double dbl;  int tc;  ll d, n, a, b; vector<pii> ks;  
int main() {   ios::sync_with_stdio(false);    fout.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_1_Usenix_RF_1.0_True_MCTS_Classic_True/bennikartefla/4yn/outer_temp/4yn/A-small-practice_transformation.out");   cin >> tc;   int t;   for (t = 1; t <= tc; t++) {     ks.clear();     cin >> d >> n;     dbl lb, ub, ex;     lb = 0;     ub = 0;     for (int i = 0; i < n; i++) {       cin >> a >> b;       ks.push_back(pii(a, b));       if (ub == 0) {         if (a != d) {           ub = d * b / (d - a + 0.0);         }       } else if (a != d) {         ub = min(ub, d * b / (d - a + 0.0));       }     }     while (abs(ub - lb) > 0.0000005f) {       ex = (ub + lb) / 2;       bool f = true;        for (int i = 0; i < n; i++) {                  if (ks[i].second >= ex)           continue;               if (ks[i].first / (ex - ks[i].second) * ex < d) {           f = false;         }       }       if (f) {         lb = ex;       } else {         ub = ex;       }     }     fout << fixed << setprecision(7) << "Case #" << t << ": " << ub << endl;   }   return 0; }
#include <bits/stdc++.h> #include <stdio.h> #include <utility> #include <vector> using namespace std;  
typedef pair<int, int> ii; typedef vector<int> vi; typedef long long int lli; typedef pair<lli, lli> pii; typedef double dbl;  int tc;  lli d, n, a, b; vector<pii> ks;  inline void sywqliqzmy(dbl &ub) { ub = d * b / (d - a + 0.0); }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_1_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/4yn/A-small-practice.in",           "r", stdin);    freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_1_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/4yn/outer_temp/4yn/A-small-practice_transformation.out",           "w", stdout);   scanf("%d ", &tc);   for (int ct = 1; ct <= tc; ct++) {     ks.clear();     scanf("%lld %lld ", &d, &n);     dbl lb, ub, ex;     lb = 0;     ub = 0;     for (int i = 0; i < n; i++) {       scanf("%lld %lld ", &a, &b);       ks.push_back(pii(a, b));       if (ub == 0) {         if (a != d)           sywqliqzmy(ub);       } else if (a != d) {         ub = min(ub, d * b / (d - a + 0.0));       }     }     while (abs(ub - lb) > 0.0000005f) {       ex = (ub + lb) / 2;       bool f = true;        for (int i = 0; i < n; i++) {                  if (ks[i].second >= ex)           continue;               if (ks[i].first / (ex - ks[i].second) * ex < d) {           f = false;         }       }       if (f) {         lb = ex;       } else {         ub = ex;       }     }     cout << fixed << setprecision(7) << "Case #" << ct << ": " << ub << endl;   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cmath> #include <complex> #include <cstdio> #include <ctime> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <queue> #include <stdio.h> #include <unordered_map> #include <vector> using namespace std; 
ifstream fin;  ofstream ans;  typedef unsigned long long ull; typedef long double LD; typedef long long LL; typedef pair<int, int> ii; typedef pair<LL, LL> pll; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<LL> vll;  const int N = 100002; int t, d, n, pos[N], speed[N];  
int main() {   fin.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_2_Usenix_RF_1.0_True_MCTS_Classic_True/WCG/KhaleD/A-small-practice.in");    ans.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_2_Usenix_RF_1.0_True_MCTS_Classic_True/WCG/KhaleD/outer_temp/KhaleD/A-small-practice_transformation.out");    fin >> t;   for (int c = (1); c <= (int)(t); ++c) {     fin >> d >> n;     for (int i = (1); i <= (int)(n); ++i)       fin >> pos[i] >> speed[i];      double get = 0;     for (int i = (1); i <= (int)(n); ++i) {       get = max(get, 1.0 * (d - pos[i]) / speed[i]);     }      ans << "Case #" << c << ": " << fixed << setprecision(6) << d / get << "\n";   }   return 0; }  
#include <bits/stdc++.h> #include <fstream> #include <iostream> using namespace std;
const int MOD = 1000000007;  typedef long long ll; typedef pair<int, int> pii; typedef pair<ll, ll> pll; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<ll> vll;  const int N = 100002; int t, d, n, pos[N], speed[N];  inline void vhpmklbjse(int &i) {   cin >> pos[i] >> speed[i];   ++i; }  inline void zovybdxzmb(int &solve) {   cin >> d >> n;   {     int i = (1);     while (i <= (int)(n))       vhpmklbjse(i);   }    double maxT = 0;   int i;   for (i = (1); i <= (int)(n); ++i)     maxT = max(maxT, 1.0 * (d - pos[i]) / speed[i]);    printf("Case #%d: %.6f\n", solve, d / maxT); }  inline void qzmrapxvii(int &solve) { zovybdxzmb(solve); }  
int main() {    cin >> t;   for (int solve = (1); solve <= (int)(t); ++solve)     qzmrapxvii(solve);   return 0; }  
#include <bits/stdc++.h> using namespace std; 
typedef long long ll; typedef pair<int, int> pii; typedef pair<ll, ll> pll; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<ll> vll; typedef set<int> si;  const int N = 100002; int ct, d, n, pos[N], speed[N];  inline void dxfgpkohjj(int &test) {   scanf("%d%d", &d, &n);   for (int i = (1); i <= (int)(n); ++i)     scanf("%d%d", &pos[i], &speed[i]);    double maxT = 0;   for (int i = (1); i <= (int)(n); ++i)     maxT = max(maxT, 1.0 * (d - pos[i]) / speed[i]);    printf("Case #%d: %.6f\n", test, d / maxT); }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_2_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/KhaleD/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_2_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/KhaleD/outer_temp/KhaleD/A-small-practice_transformation.out",           "w", stdout);   scanf("%d", &ct);   for (int test = (1); test <= (int)(ct); ++test)     dxfgpkohjj(test);   return 0; }  
#include <bits/stdc++.h> #include <iomanip> #include <iostream> using namespace std; 
const double EPS = 1e-9;  typedef long long LL; typedef pair<int, int> PII; typedef pair<LL, LL> pll; typedef vector<int> VI; typedef vector<VI> vvi; typedef vector<LL> vll;  const int N = 100002; int t, d, y, pos[N], speed[N];  inline void hsshnctnmn(double &maxT, int &T) {   maxT = max(maxT, 1.0 * (d - pos[T]) / speed[T]); }  
int main() {    scanf("%d", &t);   for (int v = (1); v <= (int)(t); ++v) {     scanf("%d%d", &d, &y);     int T;     for (T = (1); T <= (int)(y); ++T)       scanf("%d%d", &pos[T], &speed[T]);      double maxT = 0;     for (int T = (1); T <= (int)(y); ++T)       hsshnctnmn(maxT, T);      cout << "Case #" << v << ": " << fixed << setprecision(6) << d / maxT          << "\n";   }   return 0; }  
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <climits> #include <cstdio> #include <cstdlib> #include <ctime> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <numeric> #include <queue> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const int MOD = 1000000007; ofstream fout;  typedef long double ld; typedef long long ll; typedef pair<int, int> ii; typedef vector<int> VI; typedef long double LD; typedef vector<vector<int>> vvi;  int main() {   ios::sync_with_stdio(false);    fout.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_3_Usenix_RF_1.0_True_MCTS_Classic_True/bennikartefla/try/outer_temp/try/A-small-practice_transformation.out");    int c, t, i, d, n, q, s;   double a;   cin >> t;   for (c = 0; c < t; c++) {     cin >> d >> n;     a = 0.0;     for (i = 0; i < n; i++) {       cin >> q >> s;       a = max(a, 1.0 * (d - q) / s);     }     fout << "Case #" << c + 1 << ": " << fixed << setprecision(6) << d / a          << "\n";   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <iostream> using namespace std; 
typedef long long ll; typedef long long LL; 
int main() {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_3_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/try/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_3_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/try/outer_temp/try/A-small-practice_transformation.out",           "w", stdout);   int t, d, n, k, s;   double m;   scanf("%d", &t);   for (int c = 0; c < t; c++) {     scanf("%d %d", &d, &n);     m = 0.0;     for (int i = 0; i < n; i++) {       scanf("%d %d", &k, &s);       m = max(m, 1.0 * (d - k) / s);     }     printf("Case #%d: %.6f\n", c + 1, d / m);   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cassert> #include <climits> #include <cmath> #include <cstdio> #include <ctime> #include <functional> #include <iomanip> #include <iostream> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <vector> using namespace std; 
inline void lsihuwuoll(double &m, int &get, int &T, int &s) {   scanf("%d %d", &T, &s);   m = max(m, 1.0 * (get - T) / s); }  inline void ntfkjvygim(int &n, int &i, int &T, int &s, int &c, int &get,                        double &m) {   scanf("%d %d", &get, &n);   m = 0.0;   for (i = 0; i < n; i++) {     lsihuwuoll(m, get, T, s);   }   cout << "Case #" << c + 1 << ": " << fixed << setprecision(6) << get / m        << "\n"; }  
int main() {    int c, t, i, get, n, T, s;   double m;   scanf("%d", &t);   for (c = 0; c < t; c++)     ntfkjvygim(n, i, T, s, c, get, m);   return 0; }
#include <algorithm> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const double eps = 1e-9; const int INF = 1000000000; const int MAXN = 1005;  const double EPS = 1e-9;  inline void oqenbdjcrg(double &m, int &d, int &k, int &s) {   cin >> k >> s;   m = max(m, 1.0 * (d - k) / s); }  inline void rprlzuikvu(double &m, int &d, int &k, int &s) {   oqenbdjcrg(m, d, k, s); }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_3_Usenix_RF_1.0_True_MCTS_Classic_True/kuzphi/try/A-small-practice.in",           "r", stdin);    int t, i, d, n, k, s;   double m;   cin >> t;   for (int c = 0; c < t; c++) {     cin >> d >> n;     m = 0.0;     for (i = 0; i < n; i++)       rprlzuikvu(m, d, k, s);     printf("Case #%d: %.6f\n", c + 1, d / m);   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> #include <utility> #include <vector> using namespace std; 
typedef pair<int, int> ii; typedef vector<int> vi; typedef double td_d; typedef long long ll;  ofstream fout("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_4_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  void open() {   ll dest, nh;   scanf("%lld %lld ", &dest, &nh);   td_d ct = 0;   for (int i = 0; i < nh; i++) {     ll cur, speed;     scanf("%lld %lld ", &cur, &speed);     ct = max(ct, 1.0 * (dest - cur) / speed);   }   fout << fixed << setprecision(12);   fout << dest / ct << '\n'; }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_4_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sammyMaX/A-small-practice.in",           "r", stdin);   cin.tie(0);   int tc;   scanf("%d ", &tc);   for (int i = 0; i < tc; i++)     fout << "Case #" << i + 1 << ": ", open();   return 0; }
#include <bits/stdc++.h> #include <fstream> #include <iostream> #include <set> #include <utility> #include <vector> using namespace std; 
ofstream fout;  const int mod = 1000000007;  typedef vector<int> vi; typedef vector<int> VI; typedef pair<int, int> ii; typedef pair<int, int> PII; typedef long double LD; typedef set<int> si; typedef vector<vector<int>> vvi;  ifstream q("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_4_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/sammyMaX/A-small-practice.in");  inline void aeekgjlhli(double &T, long long &dest) {   long long cur, speed;   q >> cur >> speed;   T = max(T, 1.0 * (dest - cur) / speed); }  void solve() {   long long dest, nh;   q >> dest >> nh;   double T = 0;   for (int i = 0; i < nh; i++) {     aeekgjlhli(T, dest);   }   fout << fixed << setprecision(12);   fout << dest / T << '\n'; }  
int main() {   fout.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_4_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");    ios_base::sync_with_stdio(false);   cin.tie(0);   int t;   q >> t;   for (int i = 0; i < t; i++) {     fout << "Case #" << i + 1 << ": ", solve();   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;
const int mod = 1000000007; const double EPS = 1e-9; const int INF = 1000000000; const double eps = 1e-9;  ifstream fin("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_4_Usenix_RF_1.0_True_MCTS_Classic_True/kuzphi/sammyMaX/A-small-practice.in"); ofstream r("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_4_Usenix_RF_1.0_True_MCTS_Classic_True/kuzphi/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  inline void statbqqkta(double &ans, long long &dest) {   long long cur, speed;   fin >> cur >> speed;   ans = max(ans, 1.0 * (dest - cur) / speed); }  void solve() {   long long dest, nh;   fin >> dest >> nh;   double ans = 0;   {     int i = 0;     while (i < nh) {       statbqqkta(ans, dest);       i++;     }   }   r << fixed << setprecision(12);   r << dest / ans << '\n'; }  
int main() {    cin.tie(0);   int get;   fin >> get;   for (int i = 0; i < get; i++)     r << "Case #" << i + 1 << ": ", solve();   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
typedef long long ll;  ifstream tc("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_4_Usenix_RF_1.0_True_MCTS_Classic_True/ibrahim5253/sammyMaX/A-small-practice.in");  inline void rjjfjuaofh(double &N, ll &dest) {   ll cur, speed;   tc >> cur >> speed;   N = max(N, 1.0 * (dest - cur) / speed); }  void get() {   ll dest, a;   tc >> dest >> a;   double N = 0;   for (int i = 0; i < a; i++)     rjjfjuaofh(N, dest);   cout << fixed << setprecision(12);   cout << dest / N << '\n'; }  inline void ovuvpmljmv(int &i) {   cout << "Case #" << i + 1 << ": ", get();   i++; }  
int main() {   ios_base::sync_with_stdio(false);   cin.tie(0);   int t;   tc >> t;   {     int i = 0;     while (i < t)       ovuvpmljmv(i);   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cctype> #include <cmath> #include <cstdio> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <string> #include <utility> #include <vector>  using namespace std; 
const int INF = 1000000000; const double EPS = 1e-9; const int MAXN = 1005; const double eps = 1e-9; typedef long double LD; typedef unsigned long long ull; typedef long long ll; typedef long long LL; typedef pair<int, int> ii; typedef vector<int> VI; typedef set<int> si; typedef vector<vector<int>> vvi;  const int N = 1100; int T[N], s[N];  inline void ldhwndhnqf(double &mt, int &d, int &i) {   scanf("%d%d", &T[i], &s[i]);   mt = max(mt, double(d - T[i]) / s[i]); }  void get() {   int d, n;   cin >> d >> n;   double mt = 0;   for (int i = 1; i <= n; ++i)     ldhwndhnqf(mt, d, i);   printf("%.9f\n", d / mt); }  inline void poptvdiazn(int &i) {   printf("Case #%d: ", i);   get(); }  
int main() {   ios::sync_with_stdio(true);    int q;   cin >> q;   for (int i = 1; i <= q; ++i)     poptvdiazn(i);   return 0; }
#include <algorithm> #include <bitset> #include <cassert> #include <cctype> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
const double eps = 1e-9;  const int N = 1100; int k[N], s[N];  void work() {   int d, n;   cin >> d >> n;   double mt = 0;   for (int i = 1; i <= n; ++i) {     scanf("%d%d", &k[i], &s[i]);     mt = max(mt, double(d - k[i]) / s[i]);   }   cout << fixed << setprecision(9) << d / mt << endl; }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_5_Usenix_RF_1.0_True_MCTS_Classic_True/kuzphi/Tashi711/A-small-practice.in",           "r", stdin);    int q;   cin >> q;   for (int i = 1; i <= q; ++i) {     printf("Case #%d: ", i);     work();   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cassert> #include <cctype> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <math.h> #include <set> #include <sstream> #include <stack> #include <stdlib.h> #include <string> #include <unordered_map> #include <vector>  using namespace std;  
const int N = 1100; int t[N], s[N];  inline void ideqozphtq(double &mt, int &v, int &i) {   cin >> t[i] >> s[i];   mt = max(mt, double(v - t[i]) / s[i]); }  void work() {   int v, n;   cin >> v >> n;   double mt = 0;   for (int i = 1; i <= n; ++i)     ideqozphtq(mt, v, i);   cout << fixed << setprecision(9) << v / mt << endl; }  inline void tc(int &i) {   cout << "Case #" << i << ": ";   work(); }  inline void fasuqzgkqq(int &q) {   int i = 1;   while (i <= q) {     tc(i);     ++i;   } }  
int main() {   ios::sync_with_stdio(1);    int q;   cin >> q;    fasuqzgkqq(q);   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cmath> #include <cstdio> #include <iomanip> #include <iostream> #include <map> #include <set> #include <stdio.h> #include <string> #include <vector>  using namespace std; 
typedef double td_d;  const int N = 1100; int r[N], ans[N];  void work() {   int d, n;   cin >> d >> n;   td_d mt = 0;    for (int i = 1; i <= n; ++i) {     cin >> r[i] >> ans[i];     mt = max(mt, double(d - r[i]) / ans[i]);   }   printf("%.9f\n", d / mt); }  
int main() {   ios::sync_with_stdio(0);    freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_5_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/Tashi711/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_5_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/Tashi711/outer_temp/Tashi711/A-small-practice_transformation.out",           "w", stdout);    int cas;   cin >> cas;   for (int i = 1; i <= cas; ++i) {     printf("Case #%d: ", i);     work();   }   return 0; }
#include <algorithm> #include <bitset> #include <cassert> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility> #include <vector> using namespace std; 
const double eps = 1e-9; const int MOD = 1000000007;  typedef long long LL; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef unsigned long long ull;  const long double PI = 3.1415926535897932384626433832795;  inline void nzlwepkyog(int &t) {   int d, n;   cin >> d >> n;    LL bk, bs, tc, s;   cin >> tc >> s;   tc = d - tc;   bk = tc;   bs = s;   for (int i = 1; i < n; ++i) {     cin >> tc >> s;     tc = d - tc;     if (s * bk < bs * tc) {       bs = s;       bk = tc;     }   }   bs *= d;   LL T = bs / bk, r = bs % bk;    printf("Case #%d: %lld.", t, T);   int i;   for (i = 0; i < 6; ++i) {     r = r * 10;     printf("%lld", r / tc);     r = r % tc;   }   printf("\n"); }  int main() {   int p;    cin >> p;    for (int t = 1; t <= p; ++t)     nzlwepkyog(t);    return 0; }
#include <algorithm> #include <bitset> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <map> #include <math.h> #include <numeric> #include <sstream> #include <stack> #include <stdlib.h> #include <string> #include <vector> using namespace std;  
ofstream fout;  const long double PI = 3.1415926535897932384626433832795;  inline void ggqqzcixof(long long &N, long long &ans, long long &bk,                        long long &p) {   N = ans;   bk = p; }  
int main() {   fout.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_6_Usenix_RF_1.0_True_MCTS_Classic_True/ibrahim5253/WCG/outer_temp/WCG/A-small-practice_transformation.out");    ios::sync_with_stdio(0);    int b;    cin >> b;    int t;   for (t = 1; t <= b; ++t) {     int a, n;     cin >> a >> n;      long long bk, N, p, ans;     cin >> p >> ans;     p = a - p;     bk = p;     N = ans;     for (int i = 1; i < n; ++i) {       cin >> p >> ans;       p = a - p;       if (ans * bk < N * p)         ggqqzcixof(N, ans, bk, p);     }     N *= a;     long long q = N / bk, r = N % bk;      fout << "Case #" << t << ": " << q << ".";     for (int i = 0; i < 6; ++i) {       r = r * 10;       fout << r / p;       r = r % p;     }     fout << endl;   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <iostream> #include <stdio.h> #include <string> #include <vector> using namespace std; 
typedef long long td_ll;  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_6_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/WCG/outer_temp/WCG/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_6_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/WCG/A-small-practice.in",           "r", stdin);    int tt;    cin >> tt;    for (int m = 1; m <= tt; ++m) {     int d, n;     cin >> d >> n;      td_ll bk, bs, k, s;     cin >> k >> s;     k = d - k;     bk = k;     bs = s;     for (int i = 1; i < n; ++i) {       cin >> k >> s;       k = d - k;       if (s * bk < bs * k) {         bs = s;         bk = k;       }     }     bs *= d;     td_ll q = bs / bk, r = bs % bk;      printf("Case #%d: %lld.", m, q);     {       int i = 0;       while (i < 6) {         r = r * 10;         printf("%lld", r / k);         r = r % k;         ++i;       }     }     printf("\n");   }    return 0; }
#include <algorithm> #include <cstdio> #include <cstring> #include <fstream> #include <iostream> #include <stdio.h> #include <string> #include <vector> using namespace std;
ifstream fin;  
int main() {   fin.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_6_Usenix_RF_1.0_True_MCTS_Classic_True/iPeter/WCG/A-small-practice.in");    int tt;    fin >> tt;    int t;   for (t = 1; t <= tt; ++t) {     int d, n;     fin >> d >> n;      long long bk, bs, k, s;     fin >> k >> s;     k = d - k;     bk = k;     bs = s;     for (int i = 1; i < n; ++i) {       fin >> k >> s;       k = d - k;       if (s * bk < bs * k) {         bs = s;         bk = k;       }     }     bs *= d;     long long q = bs / bk, r = bs % bk;      printf("Case #%d: %lld.", t, q);     for (int i = 0; i < 6; ++i) {       r = r * 10;       printf("%lld", r / k);       r = r % k;     }     printf("\n");   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;  
typedef pair<int, int> ii; typedef vector<int> vi; typedef vector<ii> vii; typedef long long ll; const int INF = ~(1 << 31); const double pi = acos(-1);  inline void htxkawhfxy(double &n, double &t2) {   double a, b;   cin >> a >> b;   double t = (n - a) / b;   t2 = max(t, t2); }  inline void mfoqornija(double &n, double &t2, int &get) {   htxkawhfxy(n, t2);   get++; }  
int main() {   cin.sync_with_stdio(false);   ofstream v("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_7_Usenix_RF_1.0_True_MCTS_Classic_True/ibrahim5253/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out");   int t;   cin >> t;    for (int u = (0); u < (t); u++) {     double n, x;     cin >> n >> x;     double t2 = 0;     {       int get = (0);       for (; get < (x);)         mfoqornija(n, t2, get);     }     v << "Case #" << u + 1 << ": " << setprecision(10) << fixed << n / t2       << endl;   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> using namespace std;
typedef double td_d; 
int main() {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_7_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/bennikartefla/A-small-practice.in",           "r", stdin);    freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_7_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out",           "w", stdout);    int cas;   cin >> cas;   for (int u = (0); u < (cas); u++) {     td_d n, m;     cin >> n >> m;     td_d t2 = 0;      for (int i = (0); i < (m); i++) {       td_d r, b;       cin >> r >> b;       td_d cas = (n - r) / b;       t2 = max(cas, t2);     }     printf("Case #%d: %.10f\n", u + 1, n / t2);   }   return 0; }
#include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <stdio.h> using namespace std; 
const int INF = ~(1 << 31); const double pi = acos(-1);  inline void bsnoeplpcq(double &ans, double &t2) {   double tt, b;   scanf("%lf %lf ", &tt, &b);   double t = (ans - tt) / b;   t2 = max(t, t2); }  inline void dkgufnewdt(std::ofstream &fout, int &u) {   double ans, m;   scanf("%lf %lf ", &ans, &m);   double t2 = 0;   for (int i = (0); i < (m); i++)     bsnoeplpcq(ans, t2);   fout << "Case #" << u + 1 << ": " << setprecision(10) << fixed << ans / t2        << endl; }  
int main() {    ofstream fout("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_7_Usenix_RF_1.0_True_MCTS_Classic_True/iPeter/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out");   int t;   scanf("%d ", &t);    for (int u = (0); u < (t); u++)     dkgufnewdt(fout, u);    return 0; }
#include <bits/stdc++.h> #include <iostream> using namespace std; 
typedef pair<int, int> ii; typedef vector<int> vi; typedef vector<ii> vii; typedef long long ll; const int INF = ~(1 << 31); const double pi = acos(-1);  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_7_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out", "w", stdout);    freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_7_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/bennikartefla/A-small-practice.in",           "r", stdin);    int get;   cin >> get;   for (int u = (0); u < (get); u++) {     double n, m;     cin >> n >> m;     double t2 = 0;     for (int i = (0); i < (m); i++) {       double a, b;       cin >> a >> b;       double get = (n - a) / b;       t2 = max(get, t2);     }     cout << "Case #" << u + 1 << ": " << setprecision(10) << fixed << n / t2          << endl;   }   return 0; }
#include <bits/stdc++.h> #include <iostream> using namespace std;
typedef double td_d;  void open() {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_8_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/ccsnoopy/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_8_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/ccsnoopy/outer_temp/ccsnoopy/A-small-practice_transformation.out",           "w", stdout); }  inline void pfsnmzygil(double &maxi, int &d) {   int m, sp;   cin >> m;   cin >> sp;   maxi = max(maxi, 1.0 * (d - m) / sp); }  inline void jinalepgjb(int &r) {   int d, n;   cin >> d;   cin >> n;   td_d maxi = 0.0;    for (int i = 0; i < n; i++)     pfsnmzygil(maxi, d);    printf("Case #%d: %.7lf\n", r, 1.0 * d / maxi);   cerr << "Test " << r << " done \n"; }  
int main(void) {   open();   int ans;   cin >> ans;    {     int r = 1;     while (r <= ans) {       jinalepgjb(r);       r++;     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> using namespace std; 
typedef long long ll; typedef long long LL; typedef pair<int, int> ii; typedef vector<ii> vii;  void do_voixho_fct() {}  inline void efptxzxwsy(double &maxi, int &d) {   int st, sp;   scanf("%d", &st);   scanf("%d", &sp);   maxi = max(maxi, 1.0 * (d - st) / sp); }  inline void xouvjcgraq(double &maxi, int &d) { efptxzxwsy(maxi, d); }  inline void hzedtdrewj(int &ans) {   int d, t;   scanf("%d", &d);   scanf("%d", &t);   double maxi = 0.0;    for (int tt = 0; tt < t; tt++)     xouvjcgraq(maxi, d);    printf("Case #%d: %.7lf\n", ans, 1.0 * d / maxi);   cerr << "Test " << ans << " done \n"; }  
int main(void) {   do_voixho_fct();   int s;   scanf("%d", &s);    for (int ans = 1; ans <= s; ans++)     hzedtdrewj(ans);   return 0; }
#include <bits/stdc++.h> #include <iostream> using namespace std;
const long double PI = 3.1415926535897932384626433832795;  typedef double td_d; typedef long long ll; typedef long long LL; typedef pair<int, int> ii;  void get() {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_8_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/ccsnoopy/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_8_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/ccsnoopy/outer_temp/ccsnoopy/A-small-practice_transformation.out",           "w", stdout); }  inline void vosgywxpjn(double &r, int &d) {   int t, q;   cin >> t;   cin >> q;   r = max(r, 1.0 * (d - t) / q); }  inline void rdubdtdcrx(int &v) {   int d, n;   cin >> d;   cin >> n;   td_d r = 0.0;    {     int i = 0;     for (; i < n;) {       vosgywxpjn(r, d);       i++;     }   }    printf("Case #%d: %.7lf\n", v, 1.0 * d / r);   cerr << "Test " << v << " done \n"; }  
int main(void) {   ios::sync_with_stdio(false);    get();   int tc;   cin >> tc;    {     int v = 1;     while (v <= tc) {       rdubdtdcrx(v);       v++;     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <deque> #include <fstream> #include <iostream> #include <list> #include <math.h> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <unordered_map> #include <utility> #include <vector> using namespace std;
const int MOD = 1000000007; const double eps = 1e-9; ifstream fin;  typedef double td_d; typedef vector<vector<int>> vvi; typedef long long ll; typedef long long LL; typedef pair<int, int> pii; typedef vector<pii> vii; typedef vector<int> VI; void open() {}  inline void rqkatqfiyp(td_d &maxi, int &d) {   int st, sp;   fin >> st;   fin >> sp;   maxi = max(maxi, 1.0 * (d - st) / sp); }  inline void npouclzbul(int &N) {   int d, n;   fin >> d;   fin >> n;   td_d maxi = 0.0;    for (int i = 0; i < n; i++)     rqkatqfiyp(maxi, d);    printf("Case #%d: %.7lf\n", N, 1.0 * d / maxi);   cerr << "Test " << N << " done \n"; }  inline void fsbcflyfge(int &t) {   int N = 1;   while (N <= t) {     npouclzbul(N);     N++;   } }  
int main(void) {   fin.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_8_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ccsnoopy/A-small-practice.in");    open();   int t;   fin >> t;    fsbcflyfge(t);   return 0; }
#include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <stdio.h> using namespace std; 
using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &tt, pair<S, T> &p) {   return tt >> p.first >> p.second; } template <class S, class T> ostream &operator<<(ostream &bfrs_Var, const pair<S, T> &p) {   return bfrs_Var << p.first << " " << p.second; } template <class T> void maxi(T &x, T kaeT_Var) {   if (x < kaeT_Var)     x = kaeT_Var; } template <class T> void mini(T &x, T kaeT_Var) {   if (x > kaeT_Var)     x = kaeT_Var; }  inline void eibobyjllv(int &t) {   LL D, N;   scanf("%lld %lld ", &D, &N);   double mn = 0;   vector<PLL> xs(N);   int i;   for (i = (0); i < (N); ++i)     cin >> xs[i];   {     int i = (0);     while (i < (N)) {       mn = max(mn, (D - xs[i].first) * 1. / xs[i].second);       ++i;     }   }   double ans = D / mn;   printf("Case #%d: %.9f\n", t, ans); }  inline void hpfyiazanu(int &t) {   eibobyjllv(t);   ++t; }  inline void ecfuaxnezp(int &s, int &t) {   t = (1);   for (; t < (s + 1);)     hpfyiazanu(t); }  
int main() {   cin.tie(0);    int s;   scanf("%d ", &s);   int t;   ecfuaxnezp(s, t);    return 0; }
#include <bits/stdc++.h> #include <iostream> #include <set> #include <utility> #include <vector> using namespace std; 
typedef set<int> si; typedef vector<vector<int>> vvi; typedef long long ll; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef unsigned long long ull;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &j, pair<S, T> &p) {   return j >> p.first >> p.second; } template <class S, class T> ostream &operator<<(ostream &q, const pair<S, T> &p) {   return q << p.first << " " << p.second; }  const double EPS = 1e-10; const double PI = acos(-1.0); const LL MOD = 1e9 + 7;  inline void xdtmbbsqao(int &t) {   LL D, N;   cin >> D >> N;   double mn = 0;   vector<PLL> tc(N);   for (int i = (0); i < (N); ++i)     cin >> tc[i];   for (int i = (0); i < (N); ++i) {     mn = max(mn, (D - tc[i].first) * 1. / tc[i].second);   }   double ans = D / mn;   cout << "Case #" << t << ": " << fixed << setprecision(9) << ans << endl; }  
int main() {   ios::sync_with_stdio(false);    freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_9_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/okaduki/A-small-practice.in",           "r", stdin);    freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_9_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/okaduki/outer_temp/okaduki/A-small-practice_transformation.out",           "w", stdout);    cin.tie(0);    int T;   cin >> T;   {     int t = (1);     while (t < (T + 1)) {       xdtmbbsqao(t);       ++t;     }   }    return 0; }
#include <bits/stdc++.h> #include <fstream> using namespace std; 
const long double PI = 3.1415926535897932384626433832795; const double EPS = 1e-9; ifstream fin;  ofstream fout;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &j, pair<S, T> &p) {   return j >> p.first >> p.second; } template <class S, class T> ostream &get(ostream &os, const pair<S, T> &p) {   return os << p.first << " " << p.second; }  template <class T> void mini(T &x, T y) {   if (x > y)     x = y; }  inline void mnmenlwtlt(LL &N, double &mn, LL &D, vector<PLL> &xs) {   int i = (0);   while (i < (N)) {     mn = max(mn, (D - xs[i].first) * 1. / xs[i].second);     ++i;   } }  
int main() {   int ret_val = 0;   fin.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_9_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/okaduki/A-small-practice.in");   fout.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_9_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/okaduki/outer_temp/okaduki/A-small-practice_transformation.out");   cin.tie(0);   int T;   fin >> T;   int t;   for (t = (1); t < (T + 1); ++t) {     LL D, N;     fin >> D >> N;     double mn = 0;     vector<PLL> xs(N);     int i;     for (i = (0); i < (N); ++i)       fin >> xs[i];     mnmenlwtlt(N, mn, D, xs);     double ans = D / mn;     fout << "Case #" << t << ": " << fixed << setprecision(9) << ans << endl;   }   return ret_val; }
#include <bits/stdc++.h> #include <utility> #include <vector> using namespace std; 
const int MAXN = 1005; const int mod = 1000000007; const int INF = 1000000000; const int MOD = 1000000007; typedef double td_d; typedef long long ll; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef unsigned long long ull;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &s, pair<S, T> &p) {   return s >> p.first >> p.second; } template <class S, class T> ostream &operator<<(ostream &a, const pair<S, T> &p) {   return a << p.first << " " << p.second; } template <class T> void maxi(T &x, T y) {   if (x < y)     x = y; } template <class T> void mini(T &x, T y) {   if (x > y)     x = y; }  
int main() {   cin.tie(0);   ios_base::sync_with_stdio(0);    int T;   cin >> T;   for (int t = (1); t < (T + 1); ++t) {     LL D, N;     cin >> D >> N;     td_d mn = 0;     vector<PLL> xs(N);     for (int i = (0); i < (N); ++i)       cin >> xs[i];      for (int i = (0); i < (N); ++i)       mn = max(mn, (D - xs[i].first) * 1. / xs[i].second);     td_d ans = D / mn;     cout << "Case #" << t << ": " << fixed << setprecision(9) << ans << endl;   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <limits> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const int Maxn = 310;  int T; const int INF = 1000000000; typedef long double ld; typedef long long ll; typedef pair<int, int> ii;  int cs;   int s[Maxn], v[Maxn], D, N; double t; 
int main() {   ios::sync_with_stdio(false);    freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_10_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/kuzphi/A-small-practice.in",           "r", stdin);    freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_10_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/kuzphi/outer_temp/kuzphi/A-small-practice_transformation.out",           "w", stdout);    cin >> T;   while (T--) {     cout << "Case #" << ++cs << ": ";     cin >> D >> N;     t = -1;      for (int i = 1; i <= N; i++) {       cin >> s[i] >> v[i];        t = max(t, 1. * (D - s[i]) / v[i]);     }         cout << fixed << setprecision(6) << D / t << "\n";   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <limits> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;  
const int Maxn = 310;  int T;  const int MOD = 1000000007; const double eps = 1e-9;  ofstream fout;  ifstream fin;  int cs;   int s[Maxn], v[Maxn], r, N; double t; inline void heuianrvlb(int &i) {   fin >> s[i] >> v[i];    t = max(t, 1. * (r - s[i]) / v[i]); }  
int main() {   fout.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_10_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/kuzphi/outer_temp/kuzphi/A-small-practice_transformation.out");    fin.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_10_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/kuzphi/A-small-practice.in");    fin >> T;   while (T--) {     fout << "Case #" << ++cs << ": ";     fin >> r >> N;     t = -1;     for (int i = 1; i <= N; i++) {       heuianrvlb(i);     }       fout << fixed << setprecision(6) << r / t << "\n";   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <limits> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const int Maxn = 310;  int solve; const int mod = 1000000007;  typedef set<int> si; typedef long double LD; typedef long long ll; typedef pair<int, int> ii; typedef pair<int, int> PII; typedef unsigned long long ull;  int cs;   int s[Maxn], v[Maxn], tc, N; double t; inline void qsbwyommch(int &i) {   cin >> s[i] >> v[i];    t = max(t, 1. * (tc - s[i]) / v[i]); }  
int main() {   ios::sync_with_stdio(0);    cin >> solve;   for (; solve--;) {     cout << "Case #" << ++cs << ": ";     cin >> tc >> N;     t = -1;     for (int i = 1; i <= N; i++)       qsbwyommch(i);      cout << fixed << setprecision(6) << tc / t << "\n";   }   return 0; }
#include <algorithm> #include <bitset> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iostream> #include <limits> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const double pi = acos(-1.), eps = 1e-6; const int Maxn = 310, Maxk = 5010, Mo = 1e9 + 7, oo = INT_MAX >> 2; const int sp[4][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}}; int T;  typedef long long LL; typedef pair<int, int> PII; typedef unsigned long long ull; typedef vector<int> VI; typedef long double LD; typedef vector<vector<int>> vvi;  long long f[Maxn][Maxn][2], vis[Maxn][Maxn][2]; int a[Maxn]; int n, m, k, cs, ans; struct Rec {   int a, b, l; } w[Maxn];  int s[Maxn], v[Maxn], D, N; double t; 
int main() {   int ret_val = 0;   scanf("%d ", &T);   while (T--) {     printf("Case #%d: ", ++cs);     scanf("%d %d ", &D, &N);     t = -1;     for (int i = 1; i <= N; i++) {       scanf("%d %d ", &s[i], &v[i]);        t = max(t, 1. * (D - s[i]) / v[i]);     }       printf("%.6f\n", D / t);   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std;
const int MAXN = 1005;  ofstream fout;  ifstream fin;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  inline void kbylxgkteo(ll &a, ll &b, ll &t) {   a = b;   b = t; }  ll gcd(ll a, ll b) {   ll t;   while ((t = a % b) != 0)     kbylxgkteo(a, b, t);   return b; }  bool is_set(int i, ll mask) { return (mask >> i) & 1; }  int get(ll mask) {   int ans = 0;   for (int i = 0; i < 64; ++i)     if (is_set(i, mask))       ++ans;   return ans; }  int first_bit(ll mask) {   int i = 0;   while (i < 64) {     if (is_set(i++, mask))       return i - 1;   }   return -1; }  
int main() {   fout.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_11_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ibrahim5253/outer_temp/ibrahim5253/A-small-practice_transformation.out");    fin.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_11_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ibrahim5253/A-small-practice.in");    int t;   fin >> t;   for (int i = 1; i <= t; ++i) {     ll d, n;     fin >> d >> n;     double mt = 0;     for (int j = 0; j < n; ++j) {       ll k, s;       fin >> k >> s;       mt = max(mt, (d - k) / static_cast<double>(s));     }     fout << "Case #" << i << ": " << fixed << setprecision(10) << d / mt          << "\n";   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
const double eps = 1e-9; typedef pair<int, int> ii; typedef double td_d; typedef long double LD; typedef vector<int> VI; typedef set<int> si;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  ll gcd(ll a, ll b) {   ll t;   for (; (t = a % b) != 0;) {     a = b;     b = t;   }   return b; }  ll fast_exp(ll base, ll n, ll m) {   if (n == 0)     return 1;   ll t = fast_exp(base, n / 2, m);   if (n % 2 == 0)     return (t * t) % m;   else     return (((t * t) % m) * base) % m; }  bool solve(int i, ll x) { return (x >> i) & 1; }  int count_bits(ll x) {   int ans = 0;   for (int i = 0; i < 64; ++i)     if (solve(i, x))       ++ans;   return ans; }  inline void eklhulyzrc(double &mt, ll &d) {   ll k, s;   cin >> k >> s;   mt = max(mt, (d - k) / static_cast<double>(s)); } 
int main() {   ios::sync_with_stdio(0);   int t;   cin >> t;   for (int i = 1; i <= t; ++i) {     ll d, n;     cin >> d >> n;     td_d mt = 0;     for (int j = 0; j < n; ++j)       eklhulyzrc(mt, d);     printf("Case #%d: %.10f\n", i, d / mt);   }   return 0; }
#include <algorithm> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
const int mod = 1000000007; const long double PI = 3.1415926535897932384626433832795; const double EPS = 1e-9; typedef double td_d; typedef set<int> si; typedef vector<int> VI; typedef long double ld; typedef long long LL; typedef pair<int, int> PII; typedef long double LD;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  bool is_set(int i, ll mask) { return (mask >> i) & 1; }  int count_bits(ll mask) {   int ans = 0;   for (int i = 0; i < 64; ++i)     if (is_set(i, mask))       ++ans;   return ans; }  int first_bit(ll mask) {   int ret_val = -1;   int i = 0;   while (i < 64) {     if (is_set(i++, mask))       return i - 1;   }   return ret_val; }  inline void qvpuagmncp(td_d &mt, ll &d) {   ll k, s;   scanf("%lld %lld ", &k, &s);   mt = max(mt, (d - k) / static_cast<double>(s)); }  inline void zsgffrjlbv(int &i) {   ll d, n;   scanf("%lld %lld ", &d, &n);   td_d mt = 0;   for (int j = 0; j < n; ++j)     qvpuagmncp(mt, d);   printf("Case #%d: %.10f\n", i, d / mt); }  
int main() {   int ret_val = 0;    int t;   scanf("%d ", &t);   for (int i = 1; i <= t; ++i)     zsgffrjlbv(i);   return ret_val; }
#include <algorithm> #include <cassert> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
const int MOD = 1000000007; const int mod = 1000000007; const int MAXN = 1005; const int INF = 1000000000; const double EPS = 1e-9; ifstream fin;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  ll do_llskf_fct(ll a, ll b) {   ll t;   for (; (t = a % b) != 0;) {     a = b;     b = t;   }   return b; }  ll solve(ll base, ll n, ll x) {   if (n == 0)     return 1;   ll t = solve(base, n / 2, x);   if (n % 2 == 0)     return (t * t) % x;   else     return (((t * t) % x) * base) % x; }  bool is_set(int i, ll p) { return (p >> i) & 1; }  int get(ll p) {   int ans = 0;   for (int i = 0; i < 64; ++i)     if (is_set(i, p))       ++ans;   return ans; }  int do_intqlu_fct(ll p) {   int ret_val = -1;   int i = 0;   while (i < 64)     if (is_set(i++, p))       return i - 1;   return ret_val; }  inline void ginuribzrt(double &mt, ll &d) {   ll k, s;   fin >> k >> s;   mt = max(mt, (d - k) / static_cast<double>(s)); }  
int main() {   fin.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_11_Usenix_RF_1.0_True_MCTS_Classic_True/Thanabhat/ibrahim5253/A-small-practice.in");    int t;   fin >> t;   for (int i = 1; i <= t; ++i) {     ll d, n;     fin >> d >> n;     double mt = 0;     for (int j = 0; j < n; ++j)       ginuribzrt(mt, d);     printf("Case #%d: %.10f\n", i, d / mt);   }   return 0; }
#include <bits/stdc++.h> #include <iomanip> #include <iostream> #include <utility> #include <vector> using namespace std; 
const int INF = 1000000000; typedef long double ld; typedef long long ll; typedef pair<int, int> PII; typedef vector<int> vi;  using LL = long long; 
int main() {   ios::sync_with_stdio(false);    int get, cas = 0;   cin >> get;   while (get--) {     int d, n;     cin >> d >> n;     double t = 0;     while (n--) {       int k, s;       cin >> k >> s;       t = max((1.0 * d - k) / s, t);     }     double ans = d / t;     cout << "Case #" << ++cas << ": " << fixed << setprecision(10) << ans          << "\n";   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <queue> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
typedef long double ld; typedef pair<int, int> ii; typedef unsigned long long ull; typedef vector<int> vi; typedef vector<int> VI; typedef set<int> si; typedef vector<vector<int>> vvi;  using LL = long long;  inline void ijxkhuwxdq(int &d, double &t) {   int k, s;   scanf("%d %d ", &k, &s);   t = max((1.0 * d - k) / s, t); }  inline void nvmotbikwb(int &cas) {   int d, n;   scanf("%d %d ", &d, &n);   double t = 0;   while (n--)     ijxkhuwxdq(d, t);   double ans = d / t;   printf("Case #%d: %.10f\n", ++cas, ans); }  
int main() {   int ret_val = 0;   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_12_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/jiian/A-small-practice.in",           "r", stdin);    int T, cas = 0;   scanf("%d ", &T);   while (T--)     nvmotbikwb(cas);   return ret_val; }
#include <bits/stdc++.h> #include <fstream> #include <iomanip> #include <iostream> using namespace std;  
using LL = long long;  
int main() {    int T, tc = 0;   cin >> T;   for (; T--;) {     int d, n;     cin >> d >> n;     double solve = 0;     while (n--) {       int k, get;       cin >> k >> get;       solve = max((1.0 * d - k) / get, solve);     }     double ans = d / solve;     cout << "Case #" << ++tc << ": " << fixed << setprecision(10) << ans          << "\n";   }   return 0; }
#include <bits/stdc++.h> using namespace std; 
using LL = long long;  
int main() {   int ret_val = 0;   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_12_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/jiian/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_12_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/jiian/outer_temp/jiian/A-small-practice_transformation.out",           "w", stdout);   int tt, cas = 0;   cin >> tt;   while (tt--) {     int d, n;     cin >> d >> n;     double t = 0;     while (n--) {       int k, s;       cin >> k >> s;       t = max((1.0 * d - k) / s, t);     }     double ans = d / t;     printf("Case #%d: %.10f\n", ++cas, ans);   }   return ret_val; }
#include <algorithm> #include <cctype> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <fstream> #include <functional> #include <iomanip> #include <list> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <string> #include <utility> #include <vector> using namespace std; 
typedef long double ld; typedef long long LL; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef vector<int> vi; typedef long double LD;  int n; double m, s[2000], d[2000]; 
int main(void) {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_13_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/iPeter/A-small-practice.in", "r", stdin);    int ret_val = 0;   int t;   scanf("%d", &t);   for (int tt = 1; tt <= t; tt++) {     scanf("%lf%d", &m, &n);     double lo = 0;     for (int i = 0; i < n; ++i) {       scanf("%lf%lf", &d[i], &s[i]);       lo = max(lo, (m - d[i]) / s[i]);     }       printf("Case #%d: %.8lf\n", tt, m / lo);   }   return ret_val; }
#include <algorithm> #include <cstdio> #include <cstring> #include <iostream> using namespace std; 
int n; double m, s[2000], d[2000]; inline void rrxlbilawj(int &j) {   cin >> m >> n;   double solve = 0;   for (int i = 0; i < n; ++i) {     cin >> d[i] >> s[i];     solve = max(solve, (m - d[i]) / s[i]);   }     printf("Case #%d: %.8lf\n", j, m / solve); }  
int main(void) {   int t;   cin >> t;   for (int j = 1; j <= t; j++)     rrxlbilawj(j);   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> using namespace std;  
int n; double m, cc[2000], d[2000]; 
int main(void) {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_13_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/iPeter/outer_temp/iPeter/A-small-practice_transformation.out",           "w", stdout);    int ret_val = 0;   int ans;   scanf("%d", &ans);   for (int tt = 1; tt <= ans; tt++) {     scanf("%lf%d", &m, &n);     double lo = 0;     for (int i = 0; i < n; ++i) {       scanf("%lf%lf", &d[i], &cc[i]);       lo = max(lo, (m - d[i]) / cc[i]);     }       printf("Case #%d: %.8lf\n", tt, m / lo);   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <fstream> #include <iostream> #include <utility> using namespace std; 
ifstream fin;  int n; double m, mvld_Var[2000], d[2000]; inline void nnllfrvcrd(double &lo, int &i) {   fin >> d[i] >> mvld_Var[i];   lo = max(lo, (m - d[i]) / mvld_Var[i]); }  inline void urgepyjafa(double &lo, int &i) { nnllfrvcrd(lo, i); }  inline void mqlhogimqw(int &tc) {   fin >> m >> n;   double lo = 0;   for (int i = 0; i < n; ++i)     urgepyjafa(lo, i);     printf("Case #%d: %.8lf\n", tc, m / lo); }  
int main(void) {   fin.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_12_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/iPeter/A-small-practice.in");    int ret_val = 0;   int t;   fin >> t;   for (int tc = 1; tc <= t; tc++)     mqlhogimqw(tc);   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <cassert> #include <cmath> #include <complex> #include <ctime> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stdlib.h> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
ifstream fin;  typedef unsigned long long ull; typedef vector<int> VI; typedef long double ld; typedef set<int> si; typedef vector<vector<int>> vvi; typedef long long LL; typedef pair<int, int> PII; typedef pair<int, PII> iii;  LL solve(LL c, LL p, LL N = (1000000007LL)) {   LL ans = 1;   while (p) {     if (p & 1)       ans = (ans * c) % N;     c = (c * c) % N;     p /= 2;   }   return ans; }  LL get(LL a, LL b) {   if (b == 0)     return a;   return get(b, a % b); }  int n; double D, dist[1005], speed[1005];  bool possible(double mid) {   int i;   for (i = 1; i <= n; i++) {     if (speed[i] > mid)       continue;     double x = (dist[i] / speed[i]) / (1.0 / speed[i] - 1.0 / mid);     if (x <= D)       return 0;   }   return 1; }  
int main() {   fin.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_14_Usenix_RF_1.0_True_MCTS_Classic_True/Thanabhat/satyaki3794/A-small-practice.in");    cin.tie(0);    int t, x = 1;   fin >> t;   while (t--) {      fin >> D >> n;     int i;     for (i = 1; i <= n; i++)       fin >> dist[i] >> speed[i];      double ans = 0, lo = 0, hi = 1e18 + 2;     for (int iter = 0; iter < 100; iter++) {       double mid = (lo + hi) / 2;       if (possible(mid)) {         ans = max(ans, mid);         lo = mid;       } else {         hi = mid;       }     }      cout << "Case #" << x++ << ": " << fixed << setprecision(7) << ans << endl;   }    return 0; }
#include <bits/stdc++.h> #include <stdio.h>  using namespace std; 
typedef pair<int, int> ii; typedef pair<int, ii> iii;  long long pwr(long long base, long long p, long long mod = (1000000007LL)) {   long long ans = 1;   while (p) {     if (p & 1)       ans = (ans * base) % mod;     base = (base * base) % mod;     p /= 2;   }   return ans; }  long long gcd(long long a, long long b) {   if (b == 0)     return a;   return gcd(b, a % b); }  int n; double D, dist[1005], speed[1005];  bool possible(double mid) {   for (int i = 1; i <= n; i++) {     if (speed[i] > mid)       continue;     double x = (dist[i] / speed[i]) / (1.0 / speed[i] - 1.0 / mid);     if (x <= D)       return false;   }   return true; }  
int main() {   int ret_val = 0;   ios_base::sync_with_stdio(0);   cin.tie(0);   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_14_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/satyaki3794/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_14_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/satyaki3794/outer_temp/satyaki3794/A-small-practice_transformation.out",           "w", stdout);   int t, x = 1;   cin >> t;   while (t--) {      cin >> D >> n;     for (int i = 1; i <= n; i++)       cin >> dist[i] >> speed[i];      double ans = 0, lo = 0, hi = 1e18 + 2;     for (int iter = 0; iter < 100; iter++) {       double mid = (lo + hi) / 2;       if (possible(mid)) {         ans = max(ans, mid);         lo = mid;       } else         hi = mid;     }      printf("Case #%d: %.7f\n", x++, ans);   }   return ret_val; }
#include <bits/stdc++.h> #include <fstream> #include <stdio.h>  using namespace std;
ifstream fin;  typedef double td_d;  long long do_lonqgk_fct(long long base, long long p,                         long long mod = (1000000007LL)) {   long long ans = 1;   while (p) {     if (p & 1)       ans = (ans * base) % mod;     base = (base * base) % mod;     p /= 2;   }   return ans; }  long long gcd(long long m, long long tc) {   if (tc == 0)     return m;   return gcd(tc, m % tc); }  int n; double D, dist[1005], speed[1005];  bool possible(double mid) {   for (int i = 1; i <= n; i++) {     if (speed[i] > mid)       continue;      td_d x = (dist[i] / speed[i]) / (1.0 / speed[i] - 1.0 / mid);     if (x <= D)       return 0;   }   return 1; }  
int main() {   fin.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_13_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/satyaki3794/A-small-practice.in");    int ret_val = 0;   cin.tie(0);   int t, x = 1;   fin >> t;   while (t--) {      fin >> D >> n;     for (int i = 1; i <= n; i++)       fin >> dist[i] >> speed[i];      td_d ans = 0, lo = 0, hi = 1e18 + 2;     for (int iter = 0; iter < 100; iter++) {       td_d mid = (lo + hi) / 2;       if (possible(mid)) {         ans = max(ans, mid);         lo = mid;       } else {         hi = mid;       }     }      printf("Case #%d: %.7f\n", x++, ans);   }   return ret_val; }
#include <bits/stdc++.h> #include <stdio.h>  using namespace std; 
typedef long long ll; typedef pair<int, int> ii; typedef pair<int, ii> iii;  ll gcd(ll a, ll b) {   if (b == 0)     return a;   return gcd(b, a % b); }  int n; double D, dist[1005], speed[1005];  bool possible(double mid) {   for (int i = 1; i <= n; i++) {     if (speed[i] > mid)       continue;     double x = (dist[i] / speed[i]) / (1.0 / speed[i] - 1.0 / mid);     if (x <= D)       return false;   }   return 1; }  
int main() {   int ret_val = 0;   ios_base::sync_with_stdio(0);   cin.tie(0);   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_13_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/satyaki3794/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_13_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/satyaki3794/outer_temp/satyaki3794/A-small-practice_transformation.out",           "w", stdout);   int t, x = 1;   cin >> t;   while (t--) {      cin >> D >> n;     for (int i = 1; i <= n; i++)       cin >> dist[i] >> speed[i];      double ans = 0, lo = 0, hi = 1e18 + 2;     for (int iter = 0; iter < 100; iter++) {       double mid = (lo + hi) / 2;       if (possible(mid)) {         ans = max(ans, mid);         lo = mid;       } else {         hi = mid;       }     }      printf("Case #%d: %.7f\n", x++, ans);   }   return ret_val; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> using namespace std; 
int main(int tt, char **ans) {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_15_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_15_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/gultai4ukr/A-small-practice.in",           "r", stdin);    int ret_val = 0;    int mhmi_Var;   scanf("%d ", &mhmi_Var);   {     int testcase = 0;     while (testcase < mhmi_Var) {       long long int d, n, k, yhzl_Var;       scanf("%lld %lld ", &d, &n);       double max_time = 0;        for (int i = 0; i < n; ++i) {         scanf("%lld %lld ", &k, &yhzl_Var);             max_time = max(max_time, 1.0 * (d - k) / yhzl_Var);       }        printf("Case #%d: %.7f\n", testcase + 1, d / max_time);       ++testcase;     }   }    return ret_val; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> #include <utility> using namespace std; 
typedef pair<int, int> pii; typedef double dbl;  inline void xjtynjckun(dbl &max_time, long long &d, long long &k,                        long long &ghql_Var, int &i) {   cin >> k >> ghql_Var;    max_time = max(max_time, 1.0 * (d - k) / ghql_Var);   ++i; }  int main(int tc, char **m) {   int ret_val = 0;    int t;   cin >> t;   {     int zevi_Var = 0;     while (zevi_Var < t) {       long long int d, n, k, ghql_Var;       cin >> d >> n;       dbl max_time = 0;        {         int i = 0;         for (; i < n;)           xjtynjckun(max_time, d, k, ghql_Var, i);       }        printf("Case #%d: %.7f\n", zevi_Var + 1, d / max_time);       ++zevi_Var;     }   }    return ret_val; }
#include <bits/stdc++.h> #include <iostream> #include <set> #include <stdio.h> #include <utility> #include <vector> using namespace std; 
const int INF = 1000000000; typedef double td_d; typedef set<int> si; typedef long long ll; typedef pair<int, int> PII; typedef pair<int, int> pii; typedef unsigned long long ull; typedef vector<int> VI; typedef long double LD;  inline void xvqjwlmpwf(int &solve) {   int testcase = 0;   while (testcase < solve) {     ll d, n, N, s;     scanf("%lld %lld ", &d, &n);     td_d max_time = 0;     for (int i = 0; i < n; ++i) {       scanf("%lld %lld ", &N, &s);              max_time = max(max_time, 1.0 * (d - N) / s);     }      printf("Case #%d: %.7f\n", testcase + 1, d / max_time);     ++testcase;   } }  
int main(int j, char **argv) {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_14_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_14_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/gultai4ukr/A-small-practice.in",           "r", stdin);    int ret_val = 0;    int solve;   scanf("%d ", &solve);   xvqjwlmpwf(solve);    return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;
const double EPS = 1e-9;  inline void ioioxonkaw(std::ifstream &fin, double &max_time, long long &d,                        long long &k, long long &s, int &i) {   fin >> k >> s;    max_time = max(max_time, 1.0 * (d - k) / s);   ++i; }  inline void nvrjcyqnwq(long long &get, std::ifstream &fin, double &max_time,                        long long &d, long long &k, long long &s, int &i) {   i = 0;   while (i < get)     ioioxonkaw(fin, max_time, d, k, s, i); }  inline void cqritguncc(std::ifstream &fin, int &testcase) {   long long int d, get, k, s;   fin >> d >> get;   double max_time = 0;   int i;   nvrjcyqnwq(get, fin, max_time, d, k, s, i);    printf("Case #%d: %.7f\n", testcase + 1, d / max_time); }  
int main(int argc, char **argv) {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_14_Usenix_RF_1.0_True_MCTS_Classic_True/try/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out",           "w", stdout);    ifstream fin("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_14_Usenix_RF_1.0_True_MCTS_Classic_True/try/gultai4ukr/A-small-practice.in");    int t;   fin >> t;   int testcase;   {     testcase = 0;     while (testcase < t) {       cqritguncc(fin, testcase);       ++testcase;     }   }    fin.close();    return 0; }
#include <bits/stdc++.h> #include <fstream>  using namespace std; 
ofstream fout;  ifstream fin;  const int maxN = 1e6 + 5;  int d, n, start[maxN], speed[maxN], t;  
int main() {   fout.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_15_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/Mucosolvan/outer_temp/Mucosolvan/A-small-practice_transformation.out");    fin.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_15_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/Mucosolvan/A-small-practice.in");    int ret_val = 0;    fin >> t;   int m;   for (m = (1); m <= ((t)); ++m) {     fin >> d >> n;     long double tc = 0;     int i;     for (i = (0); i <= ((n)-1); ++i) {       fin >> start[i] >> speed[i];       long double time = (long double)(d - start[i]) / (long double)speed[i];       tc = max(tc, time);     }      fout << "Case #" << m << ": ";     fout << fixed << setprecision(12) << d / tc << endl;   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <complex> #include <cstring> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <numeric> #include <sstream> #include <stack> #include <stdio.h> #include <unordered_map> #include <utility> #include <vector>  using namespace std;
typedef vector<int> vi; typedef long long ll; typedef long double ld; typedef pair<int, int> pii; typedef pair<pii, int> para; const int inf = 1e9 + 7; const int maxN = 1e6 + 5;  int d, n, start[maxN], speed[maxN], t;  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_15_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/Mucosolvan/A-small-practice.in",           "r", stdin);    int ret_val = 0;    scanf("%d ", &t);   for (int x = (1); x <= ((t)); ++x) {     scanf("%d %d ", &d, &n);     long double maxim = 0;     for (int i = (0); i <= ((n)-1); ++i) {       scanf("%d %d ", &start[i], &speed[i]);       long double time = (long double)(d - start[i]) / (long double)speed[i];       maxim = max(maxim, time);     }      cout << "Case #" << x << ": ";     cout << fixed << setprecision(12) << d / maxim << endl;   }   return ret_val; }
#include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <fstream> #include <functional> #include <iostream> #include <list> #include <map> #include <math.h> #include <stdio.h> #include <stdlib.h> #include <utility> #include <vector>  using namespace std; 
typedef unsigned long long ull; typedef vector<vector<int>> vvi; typedef vector<int> vi; typedef long long LL; typedef long double LD; typedef pair<int, int> pii; typedef pair<pii, int> para; const int inf = 1e9 + 7; const int maxN = 1e6 + 5;  int d, n, start[maxN], speed[maxN], t;  inline void piueesfmco(int &i, long double &c) {   scanf("%d %d ", &start[i], &speed[i]);   long double time = (long double)(d - start[i]) / (long double)speed[i];   c = max(c, time); }  inline void liyozxrceo(long double &c, int &i) {   i = (0);   while (i <= ((n)-1)) {     piueesfmco(i, c);     ++i;   } }  inline void r(int &x) {   scanf("%d %d ", &d, &n);   long double c = 0;   int i;   liyozxrceo(c, i);    cout << "Case #" << x << ": ";   cout << fixed << setprecision(12) << d / c << endl; }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_15_Usenix_RF_1.0_True_MCTS_Classic_True/try/Mucosolvan/outer_temp/Mucosolvan/A-small-practice_transformation.out",           "w", stdout);    scanf("%d ", &t);   int x;   for (x = (1); x <= ((t)); ++x)     r(x);   return 0; }
#include <bits/stdc++.h> #include <fstream>  using namespace std;
ifstream fin;  typedef long double ld; typedef pair<int, int> pii; typedef pair<pii, int> para; const int inf = 1e9 + 7; const int maxN = 1e6 + 5;  int d, n, start[maxN], speed[maxN], t;  inline void pbrjzkrdik(int &solve, long double &maxim) {   fin >> start[solve] >> speed[solve];   long double time =       (long double)(d - start[solve]) / (long double)speed[solve];   maxim = max(maxim, time); }  
int main() {   fin.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_15_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Mucosolvan/A-small-practice.in");    int ret_val = 0;    fin >> t;   for (int x = (1); x <= ((t)); ++x) {     fin >> d >> n;     long double maxim = 0;     for (int solve = (0); solve <= ((n)-1); ++solve)       pbrjzkrdik(solve, maxim);      cout << "Case #" << x << ": ";     cout << fixed << setprecision(12) << d / maxim << endl;   }   return ret_val; }
#include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <complex> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std; 
typedef double td_d; typedef long double ld; typedef long double LD; typedef set<int> si; typedef vector<int> vi; typedef vector<vi> vvi; typedef pair<int, int> pii; typedef vector<pii> vii; typedef vector<string> vs;  typedef long long ll;            typedef unsigned long long ULL;  typedef unsigned uint;    struct debugger {   template <typename T> debugger &get(const T &v) {     cerr << v << " ";     return *this;   } };  void debugarr(int *arr, int n) {   printf("[");   for (int i = 0; i < n; i++)     printf("%d ", arr[i]);   printf("]\n"); }  
int main() {   ios::sync_with_stdio(false);    freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_16_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_16_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/lazyBit/A-small-practice.in",           "r", stdin);   ;     int n, i, j, b, l, m, t, s = 0, d, p;   scanf("%d", &t);   ;   int c = 1;   while (t--) {     scanf("%d", &d);     ;     scanf("%d", &n);     ;     td_d ans = 0.0;     td_d r;      for (i = 0; i < n; i++) {       scanf("%d", &b);       ;       scanf("%d", &s);       ;       td_d r = ((d - b) * 1.0) / s;        ans = max(ans, r);     }     printf("Case #%d: %0.6lf\n", c++, d / ans);   }   return (0); }
#include <bitset> #include <deque> #include <iomanip> #include <iostream> #include <queue> #include <set> #include <sstream> #include <stack>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std; 
const long double PI = 3.1415926535897932384626433832795;  typedef vector<int> vi; typedef vector<vi> vvi; typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long LL;            typedef unsigned long long ULL; typedef unsigned uint;    struct debugger {};  inline void ucwtltjxap(int &d, int &k, int &s, double &ans) {   scanf("%d", &k);   ;   scanf("%d", &s);   ;   double r = ((d - k) * 1.0) / s;    ans = max(ans, r); }  inline void nmezavkozh(int &n, int &i, int &k, int &s, int &c, int &d) {   scanf("%d", &d);   ;   scanf("%d", &n);   ;   double ans = 0.0;   double r;    for (i = 0; i < n; i++)     ucwtltjxap(d, k, s, ans);   printf("Case #%d: %0.6lf\n", c++, d / ans); }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_16_Usenix_RF_1.0_True_MCTS_Classic_True/try/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_16_Usenix_RF_1.0_True_MCTS_Classic_True/try/lazyBit/A-small-practice.in",           "r", stdin);   ;     int n, i, j, k, l, m, t, s = 0, d, p;   scanf("%d", &t);   ;   int c = 1;   while (t--)     nmezavkozh(n, i, k, s, c, d);   return (0); }
#include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std; 
ifstream fin;  typedef long double ld; typedef long double LD; typedef vector<int> vi; typedef vector<vi> vvi; typedef pair<int, int> PII; typedef vector<PII> vii; typedef vector<string> vs;  typedef long long LL;            typedef unsigned long long ull;  typedef unsigned uint;   struct debugger {};  void solve(int *b, int n) {   cout << "[";   int i;   for (i = 0; i < n; i++) {     cout << b[i] << " ";   }   cout << "]\n"; }  inline void fijpkktjub(int &d, int &k, int &s, double &ans, int &i) {   fin >> k;   ;   fin >> s;   ;   double r = ((d - k) * 1.0) / s;    ans = max(ans, r);   i++; }  
int main() {   fin.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_16_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/lazyBit/A-small-practice.in");    ;     int n, i, j, k, l, m, t, s = 0, d, p;   fin >> t;   ;   int c = 1;   while (t--) {     fin >> d;     ;     fin >> n;     ;     double ans = 0.0;     double r;      {       i = 0;       while (i < n)         fijpkktjub(d, k, s, ans, i);     }     printf("Case #%d: %0.6lf\n", c++, d / ans);   }   return (0); }
#include <bitset> #include <deque> #include <iomanip> #include <iostream> #include <queue> #include <set> #include <sstream> #include <stack>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std; 
typedef double td_d; typedef vector<int> vi;  typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long LL;            typedef unsigned long long ULL;  typedef unsigned uint;    struct debugger {};  void debugarr(int *q, int n) {   cout << "[";   for (int i = 0; i < n; i++)     cout << q[i] << " ";   cout << "]" << endl; }  inline void yoylwsnimp(int &d, int &a, int &s, double &ans) {   cin >> a;   ;   cin >> s;   ;   td_d r = ((d - a) * 1.0) / s;    ans = max(ans, r); }  inline void vjeyzreifh(int &n, int &a, int &s, int &c, int &d) {   cin >> d;   ;   cin >> n;   ;   td_d ans = 0.0;   td_d r;    for (int i = 0; i < n; i++)     yoylwsnimp(d, a, s, ans);   printf("Case #%d: %0.6lf\n", c++, d / ans); }  inline void kzfdwouwrv(int &n, int &a, int &s, int &c, int &d) {   vjeyzreifh(n, a, s, c, d); }  
int main() {    freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_16_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_16_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/lazyBit/A-small-practice.in",           "r", stdin);   ;     int n, j, a, l, m, t, s = 0, d, p;   cin >> t;   ;   int c = 1;   while (t--)     kzfdwouwrv(n, a, s, c, d);   return (0); }
#include <bitset> #include <cassert> #include <cctype> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <fstream> #include <functional> #include <iostream> #include <list> #include <math.h> #include <set> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility>  using namespace std;
typedef long double td_ld;  inline void fbiitepgqr(long long &d, long long &k, long long &s, int &i,                        td_ld &mt) {   scanf("%lld %lld ", &k, &s);   td_ld tt = (d - k);   tt /= s;   if (mt < tt) {     mt = tt;   } else if (i == 0) {     mt = tt;   } }  int solve(int q) {   long long d, n, k, s;   td_ld mt = 0;   scanf("%lld %lld ", &d, &n);   int i;   for (i = 0; i < n; i++)     fbiitepgqr(d, k, s, i, mt);   cout << "Case #" << q << ": " << fixed << d / mt << endl;   return 1; }  inline void mgntkmhipy(int &get) {   int i = 1;   while (i <= get) {     solve(i);     i++;   } } 
int main() {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_17_Usenix_RF_1.0_True_MCTS_Classic_True/try/Thanabhat/A-small-practice.in",           "r", stdin);    int get;   scanf("%d ", &get);   cout.precision(7);   mgntkmhipy(get);   return 0; }
#include <bits/stdc++.h> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <ctime> #include <fstream> #include <iostream> #include <iterator> #include <list> #include <numeric> #include <queue> #include <set> #include <stdlib.h> #include <utility> #include <vector>  using namespace std; 
const double EPS = 1e-9; ifstream fin;  int solve(int cc) {   int ret_val = 1;   long long d, n, k, s;   long double mt = 0;   fin >> d >> n;   for (int i = 0; i < n; i++) {     fin >> k >> s;     long double tt = (d - k);     tt /= s;     if (mt < tt) {       mt = tt;     } else if (i == 0) {       mt = tt;     }   }   cout << "Case #" << cc << ": " << fixed << d / mt << endl;   return ret_val; }  
int main() {   int ret_val = 0;   ios::sync_with_stdio(false);   fin.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_17_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Thanabhat/A-small-practice.in");   int t;   fin >> t;   cout.precision(7);   for (int i = 1; i <= t; i++) {     solve(i);   }   return ret_val; }
#include <iostream>  using namespace std; 
inline void fyupukorrj(long double &mt, long double &j) { mt = j; }  inline void ogdvvbickj(long double &mt, long double &j) { fyupukorrj(mt, j); }  int solve(int cc) {   long long d, n, v, s;   long double mt = 0;   cin >> d >> n;   {     int i = 0;     while (i < n) {       cin >> v >> s;       long double j = (d - v);       j /= s;       if (i == 0 || mt < j)         ogdvvbickj(mt, j);       i++;     }   }   cout << "Case #" << cc << ": " << fixed << d / mt << endl;   return 1; }  inline void mgydadqtni(int &i) { solve(i); }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_17_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/Thanabhat/outer_temp/Thanabhat/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_17_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/Thanabhat/A-small-practice.in",           "r", stdin);    int get;   cin >> get;   cout.precision(7);    for (int i = 1; i <= get; i++) {     mgydadqtni(i);   }   return 0; }
#include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cstdio> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <queue> #include <stdio.h> #include <stdlib.h> #include <vector>  using namespace std;  
int solve(int cc) {   long long d, n, k, s;   long double mt = 0;   scanf("%lld %lld ", &d, &n);   for (int i = 0; i < n; i++) {     scanf("%lld %lld ", &k, &s);     long double tt = (d - k);     tt /= s;     if (i == 0 || mt < tt) {       mt = tt;     }   }   cout << "Case #" << cc << ": " << fixed << d / mt << endl;   return 1; }  
int main() {   int get;   scanf("%d ", &get);   cout.precision(7);   for (int i = 1; i <= get; i++) {     solve(i);   }   return 0; }
#include <bits/stdc++.h> #include <set> #include <vector>  using namespace std; 
typedef long double ld; typedef unsigned long long ull; typedef vector<int> vi; typedef vector<int> VI; typedef set<int> si; typedef vector<vector<int>> vvi;  const int N = 1010;  int a[N]; long long b[N];  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_18_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/fragusbot/A-small-practice.in",           "r", stdin);    int t;   scanf("%d", &t);   for (int cc = 1; cc <= t; ++cc) {     double begt = clock();     printf("Case #%d: ", cc);     int d, n;     scanf("%d %d", &d, &n);     for (int i = 0; i < n; ++i) {       int foo, bar;       scanf("%d %d", &foo, &bar);       a[i] = d - foo;       b[i] = 1LL * d * bar;     }     ld solve = 0, r = 1e16;     for (int it = 0; it < 1000; ++it) {       ld s = (solve + r) * 0.5;       bool can = true;       for (int i = 0; i < n; ++i) {         if (b[i] < a[i] * s) {           can = false;         }       }       if (can) {         solve = s;       } else {         r = s;       }     }     printf("%.15f\n", (double)((solve + r) * 0.5));     fprintf(stderr, "case %d solved in %.3f\n", cc,             (clock() - begt) / CLOCKS_PER_SEC);   } }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <functional> #include <iostream> #include <iterator> #include <list> #include <map> #include <queue> #include <stdlib.h> #include <string> #include <utility>  using namespace std; 
const int N = 1010;  int a[N]; long long b[N];  inline void zamftmeeyh(int &i, int &d) {   int foo, bar;   cin >> foo >> bar;   a[i] = d - foo;   b[i] = 1LL * d * bar; }  inline void get(int &cc) {   double begt = clock();   printf("Case #%d: ", cc);   int d, n;   cin >> d >> n;   for (int i = 0; i < n; ++i)     zamftmeeyh(i, d);   long double l = 0, r = 1e16;   for (int it = 0; it < 1000; ++it) {     long double s = (l + r) * 0.5;     bool can = true;     for (int i = 0; i < n; ++i) {       if (b[i] < a[i] * s) {         can = false;       }     }     if (can) {       l = s;     } else {       r = s;     }   }   printf("%.15f\n", (double)((l + r) * 0.5));   fprintf(stderr, "case %d solved in %.3f\n", cc,           (clock() - begt) / CLOCKS_PER_SEC); }  
int main() {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_18_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/fragusbot/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_18_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/fragusbot/outer_temp/fragusbot/A-small-practice_transformation.out",           "w", stdout);   int tt;   cin >> tt;   for (int cc = 1; cc <= tt; ++cc)     get(cc);   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cassert> #include <cctype> #include <climits> #include <cstdio> #include <cstring> #include <fstream> #include <iomanip> #include <iostream> #include <list> #include <map> #include <math.h> #include <queue> #include <string> #include <utility> #include <vector>  using namespace std; 
const int N = 1010;  int a[N]; long long b[N];  inline void wkxqyijdbe(int &n, int &d) {   int get = 0;   while (get < n) {     int solve, bar;     cin >> solve >> bar;     a[get] = d - solve;     b[get] = 1LL * d * bar;     ++get;   } }  
int main() {    int tt;   cin >> tt;   {     int cc = 1;     for (; cc <= tt;) {       double begt = clock();       cout << "Case #" << cc << ": ";       int d, n;       cin >> d >> n;       wkxqyijdbe(n, d);       long double l = 0, r = 1e16;       for (int it = 0; it < 1000; ++it) {         long double s = (l + r) * 0.5;         int can = true;         for (int get = 0; get < n; ++get) {           if (b[get] < a[get] * s)             can = false;         }         if (can) {           l = s;         } else {           r = s;         }       }       cout << fixed << setprecision(15) << (double)((l + r) * 0.5) << "\n";       fprintf(stderr, "case %d solved in %.3f\n", cc,               (clock() - begt) / CLOCKS_PER_SEC);       ++cc;     }   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <set> #include <utility> #include <vector>  using namespace std; 
typedef set<int> si; typedef vector<vector<int>> vvi; typedef long long ll; typedef pair<int, int> PII; typedef pair<int, int> pii; typedef vector<int> VI;  const int N = 1010;  int a[N]; long long b[N];  inline void rlkdiqrkeb(int &can) { can = false; }  inline void djuwxxyklu(int &n, long double &l, long double &r) {   long double s = (l + r) * 0.5;   int can = 1;   int i;   for (i = 0; i < n; ++i) {     if (b[i] < a[i] * s)       rlkdiqrkeb(can);   }   if (can) {     l = s;   } else {     r = s;   } }  
int main() {   ios::sync_with_stdio(0);   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_18_Usenix_RF_1.0_True_MCTS_Classic_True/bennikartefla/fragusbot/A-small-practice.in",           "r", stdin);   int j;   scanf("%d", &j);   for (int cc = 1; cc <= j; ++cc) {     double begt = clock();     printf("Case #%d: ", cc);     int d, n;     scanf("%d %d", &d, &n);     for (int i = 0; i < n; ++i) {       int foo, bar;       scanf("%d %d", &foo, &bar);       a[i] = d - foo;       b[i] = 1LL * d * bar;     }     long double l = 0, r = 1e16;     int it;     for (it = 0; it < 1000; ++it)       djuwxxyklu(n, l, r);     printf("%.15f\n", (double)((l + r) * 0.5));     fprintf(stderr, "case %d solved in %.3f\n", cc,             (clock() - begt) / CLOCKS_PER_SEC);   }   return 0; }
#include <algorithm> #include <bitset> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <iostream> #include <map> #include <queue> #include <set> #include <string> #include <vector> #pragma comment(linker, "/STACK:256000000")  using namespace std; 
const long double PI = 3.1415926535897932384626433832795;  void get() {}  const int maxN = 1100; double d; long long n; double s[maxN], q[maxN];  inline void uphvojqfme(int &i) {   i = 0;   while (i < n) {     cin >> q[i] >> s[i];     ++i;   } }  void solve(int test) {   if (test == 29) {     int f = 0;   }   cin >> d >> n;   int i;   uphvojqfme(i);    double l = 0.0, r = 1e18;   for (int t = 0; t < 400; ++t) {     double m = (l + r) / 2.0;     int ok = 1;      double p = d / m;     for (int j = 0; j < n; ++j) {       if (q[j] + s[j] * p < d) {         ok = false;         break;       }     }      if (ok) {       l = m;     } else {       r = m;     }   }    printf("Case #%d: %.10lf\n", test, (l + r) / 2.0); }  
int main(int argc, char *argv[]) {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_19_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/sdya/outer_temp/sdya/A-small-practice_transformation.out",           "w", stdout);    int left_bound, right_bound;      int t;   cin >> t;   left_bound = 1, right_bound = t;   int i;   {     i = 1;     while (i <= t) {       if (i >= left_bound && i <= right_bound) {         solve(i);       } else {         get();       }       cerr << i << ": " << clock() << endl;       ++i;     }   }    return 0; }
#include <algorithm> #include <bitset> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <fstream> #include <iostream> #include <map> #include <queue> #include <set> #include <string> #include <vector> #pragma comment(linker, "/STACK:256000000")  using namespace std; 
ifstream fin;  void readData() {}  const int maxN = 1100; double d; long long n; double s[maxN], k[maxN];  inline void enapqtkknc(double &l, double &m) { l = m; }  inline void rrjosgqiqw(double &r, double &m) { r = m; }  inline void fqadgjxvsl(int &i) { fin >> k[i] >> s[i]; }  void solve(int test) {   if (test == 29) {     int f = 0;   }   fin >> d >> n;   for (int i = 0; i < n; ++i)     fqadgjxvsl(i);    double l = 0.0, r = 1e18;    for (int t = 0; t < 400; ++t) {     double m = (l + r) / 2.0;     bool ok = true;      double p = d / m;     for (int j = 0; j < n; ++j) {       if (k[j] + s[j] * p < d) {         ok = false;         break;       }     }      if (ok)       enapqtkknc(l, m);     else       rrjosgqiqw(r, m);   }    printf("Case #%d: %.10lf\n", test, (l + r) / 2.0); }  inline void secmpuhptu(int &i) { solve(i); }  inline void znigspcaob() { readData(); }  
int main(int argc, char *argv[]) {   fin.open("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_19_Usenix_RF_1.0_True_MCTS_Classic_True/WCG/sdya/A-small-practice.in");    int left_bound, right_bound;      int t;   fin >> t;   left_bound = 1, right_bound = t;   for (int i = 1; i <= t; ++i) {     if (i >= left_bound && i <= right_bound)       secmpuhptu(i);     else       znigspcaob();     cerr << i << ": " << clock() << endl;   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility> #include <vector> #pragma comment(linker, "/STACK:256000000")  using namespace std; 
typedef long long ll; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef long double LD;  void get() {}  const int maxN = 1100; double d; long long n; double s[maxN], k[maxN];  void solve(int test) {   if (test == 29) {     int f = 0;   }   cin >> d >> n;   for (int i = 0; i < n; ++i)     cin >> k[i] >> s[i];    double l = 0.0, r = 1e18;   for (int t = 0; t < 400; ++t) {     double m = (l + r) / 2.0;     bool ok = true;      double p = d / m;     for (int j = 0; j < n; ++j) {       if (k[j] + s[j] * p < d) {         ok = false;         break;       }     }      if (ok) {       l = m;     } else {       r = m;     }   }    printf("Case #%d: %.10lf\n", test, (l + r) / 2.0); }  
int main(int argc, char *argv[]) {   ios::sync_with_stdio(false);    int left_bound, right_bound;      int t;   cin >> t;   left_bound = 1, right_bound = t;   for (int i = 1; i <= t; ++i) {     if (i >= left_bound && i <= right_bound) {       solve(i);     } else {       get();     }     cerr << i << ": " << clock() << endl;   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <iostream> #include <map> #include <queue> #include <set> #include <stdio.h> #include <string> #include <utility> #include <vector> #pragma comment(linker, "/STACK:256000000")  using namespace std; 
typedef pair<int, int> ii; typedef vector<int> vi; typedef long long ll;  void readData() {}  const int maxN = 1100; double d; long long n; double s[maxN], k[maxN];  void solve(int test) {   if (test == 29) {     int f = 0;   }   scanf("%lf %lld ", &d, &n);   for (int i = 0; i < n; ++i) {     scanf("%lf %lf ", &k[i], &s[i]);   }    double l = 0.0, r = 1e18;   for (int ct = 0; ct < 400; ++ct) {     double m = (l + r) / 2.0;     bool ok = true;      double p = d / m;     for (int j = 0; j < n; ++j) {       if (k[j] + s[j] * p < d) {         ok = false;         break;       }     }      if (ok)       l = m;     else {       r = m;     }   }    printf("Case #%d: %.10lf\n", test, (l + r) / 2.0); }  
int main(int argc, char *argv[]) {   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_19_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sdya/A-small-practice.in",           "r", stdin);   freopen("/home/tom/project/ramdisk/blackbox_8294486_5630967708385280_19_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sdya/outer_temp/sdya/A-small-practice_transformation.out",           "w", stdout);    int left_bound, right_bound;     int ct;   scanf("%d ", &ct);   left_bound = 1, right_bound = ct;   for (int i = 1; i <= ct; ++i) {     if (i >= left_bound && i <= right_bound) {       solve(i);     } else {       readData();     }     cerr << i << ": " << clock() << endl;   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility> #include <vector> using namespace std; 
struct AugPath {   int A, B;                 vector<vector<int>> G;    vector<bool> visited;     vector<int> P;            AugPath(int _A, int _B) : A(_A), B(_B), G(_A), P(_B, -1) {}    void AddEdge(int a, int b) {      G[a].push_back(b);   }   bool Aug(int x) {     if (visited[x])       return 0;     visited[x] = 1;      for (auto it : G[x]) {       if (P[it] == -1) {         P[it] = x;         return 1;       }     }     for (auto it : G[x]) {       if (Aug(P[it])) {         P[it] = x;         return 1;       }     }     return 0;   }   int MCBM() {     int v = 0;     for (int i = 0; i < A; ++i) {       visited.resize(A, 0);       v += Aug(i);       visited.clear();     }     return v;   }   vector<pair<int, int>> GetMatchings() {     vector<pair<int, int>> v;     for (int i = 0; i < B; ++i) {       if (P[i] != -1)         v.emplace_back(P[i], i);     }     return v;   } };  int tc;  int d[7][7] = {      {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 1, 1, 1, 0},      {0, 0, 0, 0, 0, 1, 0},                             {0, 1, 0, 0, 0, 1, 1},                             {0, 1, 0, 0, 0, 0, 0},                             {0, 1, 1, 1, 0, 0, 0},                             {0, 0, 0, 1, 0, 0, 0},                         };  char color_dict[7] = {     '-', 'R', 'O', 'Y', 'G', 'B', 'V', };  int next_node[1009], visited[1009]; int c[7]; int color[1009], adj[1009][1009]; vector<string> stables;  string dfs(int node, string cur_string) {   if (visited[node] == 1) {     return cur_string;   }   visited[node] = 1;   cur_string = cur_string + color_dict[color[node]];   return dfs(next_node[node], cur_string); }  string merge(string a, string b) {   int found = 0;   int x = 0, y = 0;   for (int i = 0; i < a.size(); i++) {     for (int j = 0; j < b.size(); j++) {       if (a[i] == b[j]) {         x = i;         y = j;         found = 1;         break;       }     }     if (found) {       break;     }   }   if (!found) {     return "";   }    string c = "";   for (int i = 0; i < b.size(); i++) {     c += b[(y + i) % b.size()];   }   string rt = "";   {     int i = 0;     while (i < x) {       rt += a[i];       i++;     }   }   rt += c;   for (int i = x; i < a.size(); i++) {     rt += a[i];   }   return rt; } inline void yyvgmjsmxr(struct AugPath &mcbm, int &i, int &j) {   mcbm.AddEdge(i, j); }  inline void eevebbzqax(std::string &test, int &j) {   stables[0] = test;   stables[j] = ""; }  inline void pirtadosjv(int &j, int &i) { color[j] = i; }  inline void ljfxwpmijt(int &j) {   string test = merge(stables[0], stables[j]);   if (test != "")     eevebbzqax(test, j); }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_1_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/4yn/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_1_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/4yn/outer_temp/4yn/A-small-practice_transformation.out",           "w", stdout);   cin >> tc;   for (int t = 1; t <= tc; t++) {     int n;     cin >> n;     int counter = 0;     c[0] = 0;     for (int i = 1; i < 7; i++) {       cin >> c[i];       c[i] += c[i - 1];       for (int j = c[i - 1]; j < c[i]; j++)         pirtadosjv(j, i);     }     AugPath mcbm(n, n);     memset(adj, 0, sizeof(adj));     for (int i = 0; i < n; i++) {       for (int j = 0; j < n; j++) {         adj[i][j] = d[color[i]][color[j]];         if (adj[i][j] == 1)           yyvgmjsmxr(mcbm, i, j);       }     }     auto matches = mcbm.MCBM();      if (matches != n) {       printf("Case #%d: IMPOSSIBLE\n", t);       continue;     }      auto match = mcbm.GetMatchings();      memset(next_node, -1, sizeof(next_node));     memset(visited, -1, sizeof(visited));      for (auto i : match) {       next_node[i.first] = i.second;      }     stables.clear();     for (int i = 0; i < n; i++) {       if (next_node[i] != -1)         if (visited[i] == -1) {           stables.push_back(dfs(i, ""));         }     }      for (int i = 0; i < stables.size(); i++) {       for (int j = 1; j < stables.size(); j++)         ljfxwpmijt(j);     }     printf("Case #%d: %s\n", t, stables[0].c_str());   }   return 0; }
#include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <queue> #include <set> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const int MAXN = 1005; const int MOD = 1000000007; const int mod = 1000000007; const long double PI = 3.1415926535897932384626433832795; ofstream fout;  struct AugPath {   int A, B;                 vector<vector<int>> G;    vector<bool> visited;     vector<int> P;             AugPath(int _A, int _B) : A(_A), B(_B), G(_A), P(_B, -1) {}    void AddEdge(int a, int b) {      G[a].push_back(b);   }   bool Aug(int x) {     if (visited[x])       return 0;     visited[x] = 1;      for (auto it : G[x]) {       if (P[it] == -1) {         P[it] = x;         return 1;       }     }     for (auto it : G[x]) {       if (Aug(P[it])) {         P[it] = x;         return 1;       }     }     return 0;   }   int MCBM() {     int matchings = 0;     for (int i = 0; i < A; ++i) {       visited.resize(A, 0);       matchings += Aug(i);       visited.clear();     }     return matchings;   }   vector<pair<int, int>> GetMatchings() {     vector<pair<int, int>> matchings;     for (int i = 0; i < B; ++i) {       if (P[i] != -1)         matchings.emplace_back(P[i], i);     }     return matchings;   } };  int tc;  int d[7][7] = {      {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 1, 1, 1, 0},      {0, 0, 0, 0, 0, 1, 0},                            {0, 1, 0, 0, 0, 1, 1},                             {0, 1, 0, 0, 0, 0, 0},                            {0, 1, 1, 1, 0, 0, 0},                             {0, 0, 0, 1, 0, 0, 0},                         };  char color_dict[7] = {     '-', 'R', 'O', 'Y', 'G', 'B', 'V', };  int next_node[1009], visited[1009]; int c[7]; int color[1009], adj[1009][1009]; vector<string> stables;  string dfs(int node, string cur_string) {   if (visited[node] == 1) {     return cur_string;   }   visited[node] = 1;   cur_string = cur_string + color_dict[color[node]];   return dfs(next_node[node], cur_string); }  string merge(string a, string b) {   bool found = false;   int x = 0, y = 0;   for (int i = 0; i < a.size(); i++) {     for (int j = 0; j < b.size(); j++) {       if (a[i] == b[j]) {         x = i;         y = j;         found = true;         break;       }     }     if (found) {       break;     }   }   if (!found) {     return "";   }    string c = "";   for (int i = 0; i < b.size(); i++) {     c += b[(y + i) % b.size()];   }   string rt = "";   for (int i = 0; i < x; i++) {     rt += a[i];   }   rt += c;   for (int i = x; i < a.size(); i++) {     rt += a[i];   }   return rt; } inline void bbmthywxja(struct AugPath &mcbm, int &i, int &j) {   mcbm.AddEdge(i, j); }  
int main() {    fout.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_1_Usenix_RF_1.0_True_MCTS_Classic_True/WCG/4yn/outer_temp/4yn/A-small-practice_transformation.out");    cin >> tc;   for (int t = 1; t <= tc; t++) {     int n;     cin >> n;     int q = 0;     c[0] = 0;     for (int i = 1; i < 7; i++) {       cin >> c[i];       c[i] += c[i - 1];       for (int j = c[i - 1]; j < c[i]; j++) {         color[j] = i;       }     }     AugPath mcbm(n, n);     memset(adj, 0, sizeof(adj));     int i;     for (i = 0; i < n; i++) {       for (int j = 0; j < n; j++) {         adj[i][j] = d[color[i]][color[j]];         if (adj[i][j] == 1)           bbmthywxja(mcbm, i, j);       }     }     auto matches = mcbm.MCBM();          if (matches != n) {       fout << "Case #" << t << ": "            << "IMPOSSIBLE" << endl;       continue;     }      auto match = mcbm.GetMatchings();      memset(next_node, -1, sizeof(next_node));     memset(visited, -1, sizeof(visited));      for (auto i : match) {       next_node[i.first] = i.second;            }     stables.clear();     for (int i = 0; i < n; i++) {       if (next_node[i] != -1)         if (visited[i] == -1) {           stables.push_back(dfs(i, ""));         }     }      for (int i = 0; i < stables.size(); i++) {       for (int j = 1; j < stables.size(); j++) {         string test = merge(stables[0], stables[j]);         if (test != "") {           stables[0] = test;           stables[j] = "";         }       }     }     fout << "Case #" << t << ": " << stables[0] << endl;   }   return 0; }
#include <bits/stdc++.h> #include <fstream> #include <iostream> #include <set> #include <utility> #include <vector> using namespace std; 
ofstream fout;  typedef long long ll; typedef pair<int, int> PII; typedef unsigned long long ull; typedef vector<int> vi; typedef set<int> si;  struct AugPath {   int A, B;                 vector<vector<int>> G;   vector<bool> visited;    vector<int> P;             AugPath(int _A, int _B) : A(_A), B(_B), G(_A), P(_B, -1) {}    void AddEdge(int a, int b) {      G[a].push_back(b);   }   bool Aug(int x) {     if (visited[x])       return 0;     visited[x] = 1;      for (auto it : G[x]) {       if (P[it] == -1) {         P[it] = x;         return 1;       }     }     for (auto it : G[x]) {       if (Aug(P[it])) {         P[it] = x;         return 1;       }     }     return 0;   }   int MCBM() {     int matchings = 0;     for (int i = 0; i < A; ++i) {       visited.resize(A, 0);       matchings += Aug(i);       visited.clear();     }     return matchings;   }   vector<pair<int, int>> GetMatchings() {     vector<pair<int, int>> matchings;     for (int i = 0; i < B; ++i) {       if (P[i] != -1)         matchings.emplace_back(P[i], i);     }     return matchings;   } };  int tc;  int d[7][7] = {      {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 1, 1, 1, 0},      {0, 0, 0, 0, 0, 1, 0},                             {0, 1, 0, 0, 0, 1, 1},                            {0, 1, 0, 0, 0, 0, 0},                             {0, 1, 1, 1, 0, 0, 0},                            {0, 0, 0, 1, 0, 0, 0},                         };  char color_dict[7] = {     '-', 'R', 'O', 'Y', 'G', 'B', 'V', };  int next_node[1009], visited[1009]; int c[7]; int color[1009], adj[1009][1009]; vector<string> stables;  string dfs(int node, string cur_string) {   if (visited[node] == 1) {     return cur_string;   }   visited[node] = 1;   cur_string = cur_string + color_dict[color[node]];   return dfs(next_node[node], cur_string); }  string merge(string a, string b) {   bool found = false;   int x = 0, y = 0;   for (int i = 0; i < a.size(); i++) {     for (int j = 0; j < b.size(); j++) {       if (a[i] == b[j]) {         x = i;         y = j;         found = true;         break;       }     }     if (found) {       break;     }   }   if (!found) {     return "";   }    string c = "";   for (int i = 0; i < b.size(); i++) {     c += b[(y + i) % b.size()];   }   string rt = "";   for (int i = 0; i < x; i++) {     rt += a[i];   }   rt += c;   for (int i = x; i < a.size(); i++) {     rt += a[i];   }   return rt; } 
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_1_Usenix_RF_1.0_True_MCTS_Classic_True/bennikartefla/4yn/outer_temp/4yn/A-small-practice_transformation.out");    ios::sync_with_stdio(false);   cin >> tc;   for (int t = 1; t <= tc; t++) {     int n;     cin >> n;     int counter = 0;     c[0] = 0;     for (int i = 1; i < 7; i++) {       cin >> c[i];       c[i] += c[i - 1];       for (int j = c[i - 1]; j < c[i]; j++) {         color[j] = i;       }     }     AugPath mcbm(n, n);     memset(adj, 0, sizeof(adj));     for (int i = 0; i < n; i++) {       for (int j = 0; j < n; j++) {         adj[i][j] = d[color[i]][color[j]];         if (adj[i][j] == 1) {           mcbm.AddEdge(i, j);         }       }     }     auto matches = mcbm.MCBM();          if (matches != n) {       fout << "Case #" << t << ": "            << "IMPOSSIBLE" << endl;       continue;     }      auto match = mcbm.GetMatchings();      memset(next_node, -1, sizeof(next_node));     memset(visited, -1, sizeof(visited));      for (auto i : match) {       next_node[i.first] = i.second;            }     stables.clear();     for (int i = 0; i < n; i++) {       if (next_node[i] != -1 && visited[i] == -1) {         stables.push_back(dfs(i, ""));       }     }      for (int i = 0; i < stables.size(); i++) {       for (int j = 1; j < stables.size(); j++) {         string test = merge(stables[0], stables[j]);         if (test != "") {           stables[0] = test;           stables[j] = "";         }       }     }     fout << "Case #" << t << ": " << stables[0] << endl;   }   return 0; }
#include <bits/stdc++.h> #include <stdio.h> #include <vector> using namespace std;
typedef long long ll; typedef vector<int> vi;  struct AugPath {   int A, B;                 vector<vector<int>> G;   vector<bool> visited;     vector<int> P;             AugPath(int _A, int _B) : A(_A), B(_B), G(_A), P(_B, -1) {}    void AddEdge(int a, int b) {      G[a].push_back(b);   }   bool Aug(int x) {     if (visited[x])       return 0;     visited[x] = 1;      for (auto it : G[x]) {       if (P[it] == -1) {         P[it] = x;         return 1;       }     }     for (auto it : G[x]) {       if (Aug(P[it])) {         P[it] = x;         return 1;       }     }     return 0;   }   int MCBM() {     int matchings = 0;     for (int i = 0; i < A; ++i) {       visited.resize(A, 0);       matchings += Aug(i);       visited.clear();     }     return matchings;   }   vector<pair<int, int>> GetMatchings() {     vector<pair<int, int>> matchings;     for (int i = 0; i < B; ++i) {       if (P[i] != -1)         matchings.emplace_back(P[i], i);     }     return matchings;   } };  int tc;  int d[7][7] = {      {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 1, 1, 1, 0},      {0, 0, 0, 0, 0, 1, 0},                           {0, 1, 0, 0, 0, 1, 1},                            {0, 1, 0, 0, 0, 0, 0},                             {0, 1, 1, 1, 0, 0, 0},                             {0, 0, 0, 1, 0, 0, 0},                         };  char color_dict[7] = {     '-', 'R', 'O', 'Y', 'G', 'B', 'V', };  int next_node[1009], visited[1009]; int c[7]; int color[1009], adj[1009][1009]; vector<string> stables;  string dfs(int node, string cur_string) {   if (visited[node] == 1) {     return cur_string;   }   visited[node] = 1;   cur_string = cur_string + color_dict[color[node]];   return dfs(next_node[node], cur_string); }  string merge(string a, string b) {   bool found = false;   int x = 0, y = 0;   for (int i = 0; i < a.size(); i++) {     for (int j = 0; j < b.size(); j++) {       if (a[i] == b[j]) {         x = i;         y = j;         found = true;         break;       }     }     if (found) {       break;     }   }   if (!found) {     return "";   }    string c = "";   for (int i = 0; i < b.size(); i++) {     c += b[(y + i) % b.size()];   }   string rt = "";   for (int i = 0; i < x; i++) {     rt += a[i];   }   rt += c;   for (int i = x; i < a.size(); i++) {     rt += a[i];   }   return rt; } 
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_1_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/4yn/A-small-practice.in", "r", stdin);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_1_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/4yn/outer_temp/4yn/A-small-practice_transformation.out",           "w", stdout);   scanf("%d ", &tc);   for (int t = 1; t <= tc; t++) {     int n;     scanf("%d ", &n);     int counter = 0;     c[0] = 0;     for (int i = 1; i < 7; i++) {       scanf("%d ", &c[i]);       c[i] += c[i - 1];       for (int j = c[i - 1]; j < c[i]; j++) {         color[j] = i;       }     }     AugPath mcbm(n, n);     memset(adj, 0, sizeof(adj));     for (int i = 0; i < n; i++) {       for (int j = 0; j < n; j++) {         adj[i][j] = d[color[i]][color[j]];         if (adj[i][j] == 1) {           mcbm.AddEdge(i, j);         }       }     }     auto matches = mcbm.MCBM();         if (matches != n) {       cout << "Case #" << t << ": "            << "IMPOSSIBLE" << endl;       continue;     }      auto match = mcbm.GetMatchings();      memset(next_node, -1, sizeof(next_node));     memset(visited, -1, sizeof(visited));      for (auto i : match) {       next_node[i.first] = i.second;           }     stables.clear();     for (int i = 0; i < n; i++) {       if (next_node[i] != -1 && visited[i] == -1) {         stables.push_back(dfs(i, ""));       }     }      for (int i = 0; i < stables.size(); i++) {       for (int j = 1; j < stables.size(); j++) {         string test = merge(stables[0], stables[j]);         if (test != "") {           stables[0] = test;           stables[j] = "";         }       }     }     cout << "Case #" << t << ": " << stables[0] << endl;   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <queue> #include <set> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> using namespace std; 
const int INF = 1000000000; const int MAXN = 1005; typedef unsigned long long ull; typedef long double ld; typedef long long LL; typedef pair<int, int> ii; typedef pair<LL, LL> pll; typedef vector<int> VI; typedef vector<VI> vvi; typedef vector<LL> vll; typedef set<int> si; typedef map<int, int> mii;  const int N = 100002; int t, n, r, o, y, g, b, v; char ans[N];  bool conflict(int i, int j) {   if (ans[i] == ans[j])     return true;   if ((ans[i] == 'R' or ans[i] == 'B' or ans[i] == 'Y') and       (ans[j] == 'R' or ans[j] == 'B' or ans[j] == 'Y'))     return false;   if (ans[i] == 'O' and ans[j] != 'B')     return 1;   if (ans[i] == 'G' and ans[j] != 'R')     return true;   if (ans[i] == 'V' and ans[j] != 'Y')     return true;   swap(i, j);   if (ans[i] == 'O' and ans[j] != 'B')     return true;   if (ans[i] == 'G' and ans[j] != 'R')     return true;   if (ans[i] == 'V' and ans[j] != 'Y')     return true;   return false; }  bool check() {   int i;   for (i = (0); i <= (int)(n - 1); ++i)     if (conflict(i, (i + 1) % n))       return false;   return true; }  inline void fxjrkssaac(int &i) {   ans[i++] = 'O', --o;   if (b)     ans[i++] = 'B', --b; }  
int main() {    cin >> t;   {     int c = (1);     while (c <= (int)(t)) {       cin >> n >> r >> o >> y >> g >> b >> v;       ans[n] = '\0';       cout << "Case #" << c << ": ";        if (b >= o and r >= g and y >= v) {         int i = 0;         if (o) {           ans[i++] = 'B';           --b;           while (o)             fxjrkssaac(i);         }         if (g) {           ans[i++] = 'R';           --r;           while (g) {             ans[i++] = 'G', --g;             if (r)               ans[i++] = 'R', --r;           }         }         if (v) {           ans[i++] = 'Y';           --y;           while (v) {             ans[i++] = 'V', --v;             if (y)               ans[i++] = 'Y', --y;           }         }          int rr = r, bb = b, yy = y;         int j = i;          while (rr or bb or yy) {           if (rr)             ans[j++] = 'R', --rr;           if (bb)             ans[j++] = 'B', --bb;           if (yy)             ans[j++] = 'Y', --yy;         }         if (check()) {           puts(ans);           ++c;           continue;         }          rr = r, bb = b, yy = y;         j = i;          while (rr or bb or yy) {           if (rr)             ans[j++] = 'R', --rr;           if (yy)             ans[j++] = 'Y', --yy;           if (bb)             ans[j++] = 'B', --bb;         }         if (check()) {           puts(ans);           ++c;           continue;         }          rr = r, bb = b, yy = y;         j = i;          while (rr or bb or yy) {           if (yy)             ans[j++] = 'Y', --yy;           if (bb)             ans[j++] = 'B', --bb;           if (rr)             ans[j++] = 'R', --rr;         }         if (check()) {           puts(ans);           ++c;           continue;         }          rr = r, bb = b, yy = y;         j = i;          while (rr or bb or yy) {           if (bb)             ans[j++] = 'B', --bb;           if (rr)             ans[j++] = 'R', --rr;           if (yy)             ans[j++] = 'Y', --yy;         }         if (check()) {           puts(ans);           ++c;           continue;         }          rr = r, bb = b, yy = y;         j = i;          while (rr or bb or yy) {           if (yy)             ans[j++] = 'Y', --yy;           if (rr)             ans[j++] = 'R', --rr;           if (bb)             ans[j++] = 'B', --bb;         }         if (check()) {           puts(ans);           ++c;           continue;         }          rr = r, bb = b, yy = y;         j = i;          while (rr or bb or yy) {           if (bb)             ans[j++] = 'B', --bb;           if (yy)             ans[j++] = 'Y', --yy;           if (rr)             ans[j++] = 'R', --rr;         }         if (check()) {           puts(ans);           ++c;           continue;         }         puts("IMPOSSIBLE");       } else         cout << "IMPOSSIBLE\n";       ++c;     }   }   return 0; } 
#include <bits/stdc++.h> using namespace std; 
const double EPS = 1e-9;  typedef long double LD; typedef long long ll; typedef pair<int, int> ii; typedef pair<ll, ll> pll; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<ll> vll; typedef set<int> si;  const int N = 100002; int t, n, r, o, y, g, b, v; char ans[N];  bool conflict(int i, int j) {   if (ans[i] == ans[j])     return true;   if ((ans[i] == 'R' or ans[i] == 'B' or ans[i] == 'Y'))     if ((ans[j] == 'R' or ans[j] == 'B' or ans[j] == 'Y'))       return false;   if (ans[i] == 'O' and ans[j] != 'B')     return true;   if (ans[i] == 'G' and ans[j] != 'R')     return 1;   if (ans[i] == 'V')     if (ans[j] != 'Y')       return true;   swap(i, j);   if (ans[i] == 'O' and ans[j] != 'B')     return true;   if (ans[i] == 'G' and ans[j] != 'R')     return true;   if (ans[i] == 'V')     if (ans[j] != 'Y')       return true;   return false; }  bool get() {   {     int i = (0);     while (i <= (int)(n - 1)) {       if (conflict(i, (i + 1) % n))         return false;       ++i;     }   }   return true; }  
int main() {    scanf("%d", &t);   for (int test = (1); test <= (int)(t); ++test) {     scanf("%d%d%d%d%d%d%d", &n, &r, &o, &y, &g, &b, &v);     ans[n] = '\0';     printf("Case #%d: ", test);      if (b >= o and r >= g and y >= v) {       int i = 0;       if (o) {         ans[i++] = 'B';         --b;         while (o) {           ans[i++] = 'O', --o;           if (b)             ans[i++] = 'B', --b;         }       }       if (g) {         ans[i++] = 'R';         --r;         while (g) {           ans[i++] = 'G', --g;           if (r)             ans[i++] = 'R', --r;         }       }       if (v) {         ans[i++] = 'Y';         --y;         while (v) {           ans[i++] = 'V', --v;           if (y)             ans[i++] = 'Y', --y;         }       }        int rr = r, bb = b, yy = y;       int j = i;         while (rr or bb or yy) {         if (rr)           ans[j++] = 'R', --rr;         if (bb)           ans[j++] = 'B', --bb;         if (yy)           ans[j++] = 'Y', --yy;       }       if (get()) {         puts(ans);         continue;       }        rr = r, bb = b, yy = y;       j = i;           for (; rr or bb or yy;) {         if (rr)           ans[j++] = 'R', --rr;         if (yy)           ans[j++] = 'Y', --yy;         if (bb)           ans[j++] = 'B', --bb;       }       if (get()) {         puts(ans);         continue;       }        rr = r, bb = b, yy = y;       j = i;         for (; rr or bb or yy;) {         if (yy)           ans[j++] = 'Y', --yy;         if (bb)           ans[j++] = 'B', --bb;         if (rr)           ans[j++] = 'R', --rr;       }       if (get()) {         puts(ans);         continue;       }        rr = r, bb = b, yy = y;       j = i;           for (; rr or bb or yy;) {         if (bb)           ans[j++] = 'B', --bb;         if (rr)           ans[j++] = 'R', --rr;         if (yy)           ans[j++] = 'Y', --yy;       }       if (get()) {         puts(ans);         continue;       }        rr = r, bb = b, yy = y;       j = i;           while (rr or bb or yy) {         if (yy)           ans[j++] = 'Y', --yy;         if (rr)           ans[j++] = 'R', --rr;         if (bb)           ans[j++] = 'B', --bb;       }       if (get()) {         puts(ans);         continue;       }        rr = r, bb = b, yy = y;       j = i;             while (rr or bb or yy) {         if (bb)           ans[j++] = 'B', --bb;         if (yy)           ans[j++] = 'Y', --yy;         if (rr)           ans[j++] = 'R', --rr;       }       if (get()) {         puts(ans);         continue;       }       puts("IMPOSSIBLE");     } else       printf("IMPOSSIBLE\n");   }   return 0; }  
#include <bits/stdc++.h> using namespace std; 
typedef long long ll; typedef pair<int, int> pii; typedef pair<ll, ll> pll; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<ll> vll; typedef set<int> si; typedef map<int, int> mii;  const int N = 100002; int tc, n, r, o, y, g, b, v; char ans[N];  bool conflict(int i, int j) {   if (ans[i] == ans[j])     return true;   if ((ans[i] == 'R' or ans[i] == 'B' or ans[i] == 'Y') and       (ans[j] == 'R' or ans[j] == 'B' or ans[j] == 'Y'))     return false;   if (ans[i] == 'O' and ans[j] != 'B')     return true;   if (ans[i] == 'G' and ans[j] != 'R')     return true;   if (ans[i] == 'V' and ans[j] != 'Y')     return true;   swap(i, j);   if (ans[i] == 'O' and ans[j] != 'B')     return true;   if (ans[i] == 'G' and ans[j] != 'R')     return true;   if (ans[i] == 'V' and ans[j] != 'Y')     return true;   return false; }  bool check() {   for (int i = (0); i <= (int)(n - 1); ++i)     if (conflict(i, (i + 1) % n))       return false;   return true; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_2_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/KhaleD/outer_temp/KhaleD/A-small-practice_transformation.out", "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_2_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/KhaleD/A-small-practice.in",           "r", stdin);   scanf("%d", &tc);   for (int test = (1); test <= (int)(tc); ++test) {     scanf("%d%d%d%d%d%d%d", &n, &r, &o, &y, &g, &b, &v);     ans[n] = '\0';     printf("Case #%d: ", test);      if (b >= o and r >= g and y >= v) {       int i = 0;       if (o) {         ans[i++] = 'B';         --b;         while (o) {           ans[i++] = 'O', --o;           if (b)             ans[i++] = 'B', --b;         }       }       if (g) {         ans[i++] = 'R';         --r;         while (g) {           ans[i++] = 'G', --g;           if (r)             ans[i++] = 'R', --r;         }       }       if (v) {         ans[i++] = 'Y';         --y;         while (v) {           ans[i++] = 'V', --v;           if (y)             ans[i++] = 'Y', --y;         }       }        int rr = r, bb = b, yy = y;       int j = i;             while (rr or bb or yy) {         if (rr)           ans[j++] = 'R', --rr;         if (bb)           ans[j++] = 'B', --bb;         if (yy)           ans[j++] = 'Y', --yy;       }       if (check()) {         puts(ans);         continue;       }        rr = r, bb = b, yy = y;       j = i;             while (rr or bb or yy) {         if (rr)           ans[j++] = 'R', --rr;         if (yy)           ans[j++] = 'Y', --yy;         if (bb)           ans[j++] = 'B', --bb;       }       if (check()) {         puts(ans);         continue;       }        rr = r, bb = b, yy = y;       j = i;              while (rr or bb or yy) {         if (yy)           ans[j++] = 'Y', --yy;         if (bb)           ans[j++] = 'B', --bb;         if (rr)           ans[j++] = 'R', --rr;       }       if (check()) {         puts(ans);         continue;       }        rr = r, bb = b, yy = y;       j = i;              while (rr or bb or yy) {         if (bb)           ans[j++] = 'B', --bb;         if (rr)           ans[j++] = 'R', --rr;         if (yy)           ans[j++] = 'Y', --yy;       }       if (check()) {         puts(ans);         continue;       }        rr = r, bb = b, yy = y;       j = i;              while (rr or bb or yy) {         if (yy)           ans[j++] = 'Y', --yy;         if (rr)           ans[j++] = 'R', --rr;         if (bb)           ans[j++] = 'B', --bb;       }       if (check()) {         puts(ans);         continue;       }        rr = r, bb = b, yy = y;       j = i;             while (rr or bb or yy) {         if (bb)           ans[j++] = 'B', --bb;         if (yy)           ans[j++] = 'Y', --yy;         if (rr)           ans[j++] = 'R', --rr;       }       if (check()) {         puts(ans);         continue;       }       puts("IMPOSSIBLE");     } else       printf("IMPOSSIBLE\n");   }   return 0; }  
#include <bits/stdc++.h> #include <iostream> using namespace std; 
const double eps = 1e-9; typedef unsigned long long ull; typedef long double LD; typedef long long LL; typedef pair<int, int> ii; typedef pair<LL, LL> pll; typedef vector<int> VI; typedef vector<VI> vvi; typedef vector<LL> vll; typedef set<int> si;  const int N = 100002; int t, n, r, o, y, g, b, d; char ans[N];  bool conflict(int i, int j) {   if (ans[i] == ans[j])     return true;   if ((ans[i] == 'R' or ans[i] == 'B' or ans[i] == 'Y') and       (ans[j] == 'R' or ans[j] == 'B' or ans[j] == 'Y'))     return false;   if (ans[i] == 'O' and ans[j] != 'B')     return true;   if (ans[i] == 'G' and ans[j] != 'R')     return true;   if (ans[i] == 'V' and ans[j] != 'Y')     return true;   swap(i, j);   if (ans[i] == 'O')     if (ans[j] != 'B')       return true;   if (ans[i] == 'G' and ans[j] != 'R')     return true;   if (ans[i] == 'V' and ans[j] != 'Y')     return true;   return false; }  bool get() {   {     int i = (0);     while (i <= (int)(n - 1)) {       if (conflict(i, (i + 1) % n))         return false;       ++i;     }   }   return true; } 
int main() {   ios::sync_with_stdio(0);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_2_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/KhaleD/A-small-practice.in",           "r", stdin);   scanf("%d", &t);   int T;   for (T = (1); T <= (int)(t); ++T) {     scanf("%d%d%d%d%d%d%d", &n, &r, &o, &y, &g, &b, &d);     ans[n] = '\0';     printf("Case #%d: ", T);      if (b >= o and r >= g and y >= d) {       int i = 0;       if (o) {         ans[i++] = 'B';         --b;         while (o) {           ans[i++] = 'O', --o;           if (b)             ans[i++] = 'B', --b;         }       }       if (g) {         ans[i++] = 'R';         --r;         while (g) {           ans[i++] = 'G', --g;           if (r)             ans[i++] = 'R', --r;         }       }       if (d) {         ans[i++] = 'Y';         --y;         while (d) {           ans[i++] = 'V', --d;           if (y)             ans[i++] = 'Y', --y;         }       }        int rr = r, bb = b, yy = y;       int j = i;             while (rr or bb or yy) {         if (rr) {           ans[j++] = 'R', --rr;         }         if (bb)           ans[j++] = 'B', --bb;         if (yy)           ans[j++] = 'Y', --yy;       }       if (get()) {         puts(ans);         continue;       }        rr = r, bb = b, yy = y;       j = i;              while (rr or bb or yy) {         if (rr)           ans[j++] = 'R', --rr;         if (yy)           ans[j++] = 'Y', --yy;         if (bb)           ans[j++] = 'B', --bb;       }       if (get()) {         puts(ans);         continue;       }        rr = r, bb = b, yy = y;       j = i;              for (; rr or bb or yy;) {         if (yy)           ans[j++] = 'Y', --yy;         if (bb)           ans[j++] = 'B', --bb;         if (rr)           ans[j++] = 'R', --rr;       }       if (get()) {         puts(ans);         continue;       }        rr = r, bb = b, yy = y;       j = i;             while (rr or bb or yy) {         if (bb)           ans[j++] = 'B', --bb;         if (rr)           ans[j++] = 'R', --rr;         if (yy)           ans[j++] = 'Y', --yy;       }       if (get()) {         puts(ans);         continue;       }        rr = r, bb = b, yy = y;       j = i;              while (rr or bb or yy) {         if (yy)           ans[j++] = 'Y', --yy;         if (rr)           ans[j++] = 'R', --rr;         if (bb)           ans[j++] = 'B', --bb;       }       if (get()) {         puts(ans);         continue;       }        rr = r, bb = b, yy = y;       j = i;             while (rr or bb or yy) {         if (bb)           ans[j++] = 'B', --bb;         if (yy)           ans[j++] = 'Y', --yy;         if (rr)           ans[j++] = 'R', --rr;       }       if (get()) {         puts(ans);         continue;       }       puts("IMPOSSIBLE");     } else       printf("IMPOSSIBLE\n");   }   return 0; }  
#include <algorithm> #include <bits/stdc++.h> #include <cassert> #include <cctype> #include <climits> #include <cstdio> #include <cstring> #include <deque> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <math.h> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility> #include <vector>  using namespace std; 
typedef long double ld; typedef long long ll; typedef long long LL; typedef pair<int, int> PII; typedef vector<int> vi; typedef vector<int> VI;  char ans[1000 + 1]; int ord[1000 + 1]; int n, m, r, o, y, g, b, v;  
int main() {   ios::sync_with_stdio(false);    int t, i;   scanf("%d", &t);   for (int c = 0; c < t; c++) {     scanf("%d %d %d %d %d %d %d", &n, &r, &o, &y, &g, &b, &v);     printf("Case #%d: ", c + 1);     if ((r * 2 > n) || (y * 2 > n) || (b * 2 > n)) {       printf("IMPOSSIBLE\n");       continue;     }     m = 0;     for (i = 0; i < n; i = i + 2) {       ord[m++] = i;     }     for (i = 1; i < n; i = i + 2) {       ord[m++] = i;     }     m = 0;     if ((r >= y) && (y >= b)) {       while (--r >= 0) {         ans[ord[m++]] = 'R';       }       while (--y >= 0) {         ans[ord[m++]] = 'Y';       }       while (--b >= 0) {         ans[ord[m++]] = 'B';       }     } else if ((r >= b) && (b >= y)) {       while (--r >= 0) {         ans[ord[m++]] = 'R';       }       while (--b >= 0) {         ans[ord[m++]] = 'B';       }       while (--y >= 0) {         ans[ord[m++]] = 'Y';       }     } else if ((y >= b) && (b >= r)) {       while (--y >= 0) {         ans[ord[m++]] = 'Y';       }       while (--b >= 0) {         ans[ord[m++]] = 'B';       }       while (--r >= 0) {         ans[ord[m++]] = 'R';       }     } else if ((y >= r) && (r >= b)) {       while (--y >= 0) {         ans[ord[m++]] = 'Y';       }       while (--r >= 0) {         ans[ord[m++]] = 'R';       }       while (--b >= 0) {         ans[ord[m++]] = 'B';       }     } else {       if ((b >= r) && (r >= y)) {         for (; --b >= 0;) {           ans[ord[m++]] = 'B';         }         while (--r >= 0) {           ans[ord[m++]] = 'R';         }         while (--y >= 0) {           ans[ord[m++]] = 'Y';         }       } else {         while (--b >= 0) {           ans[ord[m++]] = 'B';         }         while (--y >= 0) {           ans[ord[m++]] = 'Y';         }         while (--r >= 0) {           ans[ord[m++]] = 'R';         }       }     }     ans[m] = '\0';     printf("%s\n", ans);   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <iostream> #include <utility> #include <vector>  using namespace std;
typedef vector<int> vi; typedef pair<int, int> ii; typedef long long ll; typedef long long LL;  char ans[1000 + 1]; int ord[1000 + 1]; int n, m, r, o, y, g, b, v;  inline void twobkfsmvi() { ans[ord[m++]] = 'R'; }  inline void qvufmvqbqs() {   while (--b >= 0) {     ans[ord[m++]] = 'B';   }   while (--r >= 0) {     ans[ord[m++]] = 'R';   }   while (--y >= 0) {     ans[ord[m++]] = 'Y';   } }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_3_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/try/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_3_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/try/outer_temp/try/A-small-practice_transformation.out",           "w", stdout);   int c, tc, i;   scanf("%d", &tc);   for (c = 0; c < tc; c++) {     scanf("%d %d %d %d %d %d %d", &n, &r, &o, &y, &g, &b, &v);     printf("Case #%d: ", c + 1);     if ((r * 2 > n) || (y * 2 > n) || (b * 2 > n)) {       printf("IMPOSSIBLE\n");       continue;     }     m = 0;     for (i = 0; i < n; i = i + 2) {       ord[m++] = i;     }     for (i = 1; i < n; i = i + 2) {       ord[m++] = i;     }     m = 0;     if ((r >= y) && (y >= b)) {       while (--r >= 0) {         ans[ord[m++]] = 'R';       }       while (--y >= 0) {         ans[ord[m++]] = 'Y';       }       while (--b >= 0) {         ans[ord[m++]] = 'B';       }     } else if ((r >= b) && (b >= y)) {       while (--r >= 0) {         ans[ord[m++]] = 'R';       }       while (--b >= 0) {         ans[ord[m++]] = 'B';       }       while (--y >= 0) {         ans[ord[m++]] = 'Y';       }     } else if ((y >= b) && (b >= r)) {       while (--y >= 0) {         ans[ord[m++]] = 'Y';       }       while (--b >= 0) {         ans[ord[m++]] = 'B';       }       while (--r >= 0) {         ans[ord[m++]] = 'R';       }     } else {       if ((y >= r) && (r >= b)) {         while (--y >= 0) {           ans[ord[m++]] = 'Y';         }         while (--r >= 0)           twobkfsmvi();         while (--b >= 0) {           ans[ord[m++]] = 'B';         }       } else if ((b >= r) && (r >= y))         qvufmvqbqs();       else {         while (--b >= 0) {           ans[ord[m++]] = 'B';         }         while (--y >= 0) {           ans[ord[m++]] = 'Y';         }         while (--r >= 0) {           ans[ord[m++]] = 'R';         }       }     }     ans[m] = '\0';     printf("%s\n", ans);   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
typedef long long LL; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef pair<int, int> PII; typedef unsigned long long ull; typedef vector<int> VI;  char ans[1000 + 1]; int ord[1000 + 1]; int n, T, r, o, y, a, b, v;  
int main() {   ios::sync_with_stdio(0);    int t, i;   scanf("%d", &t);   for (int c = 0; c < t; c++) {     scanf("%d %d %d %d %d %d %d", &n, &r, &o, &y, &a, &b, &v);     cout << "Case #" << c + 1 << ": ";     if ((b * 2 > n)) {       cout << "IMPOSSIBLE\n";       continue;     } else if ((r * 2 > n) || (y * 2 > n)) {       cout << "IMPOSSIBLE\n";       continue;     }     T = 0;     for (i = 0; i < n; i = i + 2) {       ord[T++] = i;     }     {       i = 1;       while (i < n) {         ord[T++] = i;         i = i + 2;       }     }     T = 0;     if ((r >= y) && (y >= b)) {       while (--r >= 0) {         ans[ord[T++]] = 'R';       }       while (--y >= 0) {         ans[ord[T++]] = 'Y';       }       while (--b >= 0) {         ans[ord[T++]] = 'B';       }     } else if ((r >= b) && (b >= y)) {       while (--r >= 0) {         ans[ord[T++]] = 'R';       }       while (--b >= 0) {         ans[ord[T++]] = 'B';       }       while (--y >= 0) {         ans[ord[T++]] = 'Y';       }     } else if ((y >= b) && (b >= r)) {       while (--y >= 0) {         ans[ord[T++]] = 'Y';       }       while (--b >= 0) {         ans[ord[T++]] = 'B';       }       while (--r >= 0) {         ans[ord[T++]] = 'R';       }     } else if ((y >= r) && (r >= b)) {       while (--y >= 0) {         ans[ord[T++]] = 'Y';       }       while (--r >= 0) {         ans[ord[T++]] = 'R';       }       while (--b >= 0) {         ans[ord[T++]] = 'B';       }     } else if ((b >= r) && (r >= y)) {       while (--b >= 0) {         ans[ord[T++]] = 'B';       }       while (--r >= 0) {         ans[ord[T++]] = 'R';       }       while (--y >= 0) {         ans[ord[T++]] = 'Y';       }     } else {       while (--b >= 0) {         ans[ord[T++]] = 'B';       }       while (--y >= 0) {         ans[ord[T++]] = 'Y';       }       while (--r >= 0) {         ans[ord[T++]] = 'R';       }     }     ans[T] = '\0';     cout << ans << "\n";   }   return 0; }
#include <algorithm> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <string> #include <utility> #include <vector>  using namespace std; 
const int INF = 1000000000;  char ans[1000 + 1]; int ord[1000 + 1]; int n, m, r, o, y, g, b, v;  inline void xflvsnqusd() {   while (--b >= 0) {     ans[ord[m++]] = 'B';   }   while (--r >= 0) {     ans[ord[m++]] = 'R';   }   while (--y >= 0) {     ans[ord[m++]] = 'Y';   } }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_3_Usenix_RF_1.0_True_MCTS_Classic_True/kuzphi/try/A-small-practice.in",           "r", stdin);    int t, i;   cin >> t;   for (int c = 0; c < t; c++) {     cin >> n >> r >> o >> y >> g >> b >> v;     printf("Case #%d: ", c + 1);     if ((b * 2 > n)) {       printf("IMPOSSIBLE\n");       continue;     } else if ((r * 2 > n) || (y * 2 > n)) {       printf("IMPOSSIBLE\n");       continue;     }     m = 0;     {       i = 0;       while (i < n) {         ord[m++] = i;         i = i + 2;       }     }     for (i = 1; i < n; i = i + 2) {       ord[m++] = i;     }     m = 0;     if ((r >= y) && (y >= b)) {       while (--r >= 0) {         ans[ord[m++]] = 'R';       }       while (--y >= 0) {         ans[ord[m++]] = 'Y';       }       while (--b >= 0) {         ans[ord[m++]] = 'B';       }     } else {       if ((r >= b) && (b >= y)) {         while (--r >= 0) {           ans[ord[m++]] = 'R';         }         while (--b >= 0) {           ans[ord[m++]] = 'B';         }         while (--y >= 0) {           ans[ord[m++]] = 'Y';         }       } else if ((y >= b) && (b >= r)) {         while (--y >= 0) {           ans[ord[m++]] = 'Y';         }         while (--b >= 0) {           ans[ord[m++]] = 'B';         }         while (--r >= 0) {           ans[ord[m++]] = 'R';         }       } else if ((y >= r) && (r >= b)) {         while (--y >= 0) {           ans[ord[m++]] = 'Y';         }         while (--r >= 0) {           ans[ord[m++]] = 'R';         }         while (--b >= 0) {           ans[ord[m++]] = 'B';         }       } else {         if ((b >= r) && (r >= y))           xflvsnqusd();         else {           while (--b >= 0) {             ans[ord[m++]] = 'B';           }           while (--y >= 0) {             ans[ord[m++]] = 'Y';           }           while (--r >= 0) {             ans[ord[m++]] = 'R';           }         }       }     }     ans[m] = '\0';     printf("%s\n", ans);   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> #include <utility> #include <vector> using namespace std; 
typedef pair<int, int> ii; typedef long long ll; typedef vector<int> vi;  ifstream fin("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_4_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sammyMaX/A-small-practice.in");  void open() {   int n, r, o, y, g, b, v;   fin >> n >> r >> o >> y >> g >> b >> v;   int res[2000] = {};   int cs[] = {r, y, b};   for (int i = 0; i < n; i++) {     int mxi = 0, mxamt = -1;     for (int j = 0; j < 3; j++) {       if (i > 0 && res[i - 1] == j)         continue;       if (cs[j] > mxamt || (cs[j] == mxamt && j == res[0]))         mxi = j, mxamt = cs[j];     }     if (mxamt <= 0 || (i == n - 1 && mxi == res[0])) {       printf("IMPOSSIBLE\n");       return;     }     cs[mxi]--, res[i] = mxi;   }   string conv = "RYB";   for (int i = 0; i < n; i++) {     printf("%c", conv[res[i]]);   }   printf("\n"); }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_4_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out",           "w", stdout);    cin.tie(0);   int tc;   fin >> tc;   for (int i = 0; i < tc; i++)     printf("Case #%d: ", i + 1), open();   return 0; }
#include <bits/stdc++.h> #include <set> #include <utility> #include <vector> using namespace std;
const double eps = 1e-9; typedef set<int> si; typedef long long LL; typedef pair<int, int> PII; typedef vector<int> vi; typedef vector<int> VI; typedef long double ld; typedef vector<vector<int>> vvi;  ifstream q("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_4_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/sammyMaX/A-small-practice.in"); ofstream x("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_4_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  inline bool rpqofbonoj() {   x << "IMPOSSIBLE\n";   return true;   return false; }  inline bool aktapqwszo() {   if (rpqofbonoj())     return true;   return false; }  void solve() {   int n, r, o, y, g, b, v;   q >> n >> r >> o >> y >> g >> b >> v;   vector<int> d(2000);   int cs[] = {r, y, b};   for (int i = 0; i < n; i++) {     int mxi = 0, mxamt = -1;     int j;     for (j = 0; j < 3; j++) {       if (i > 0 && d[i - 1] == j)         continue;       if (cs[j] > mxamt || (cs[j] == mxamt && j == d[0]))         mxi = j, mxamt = cs[j];     }     if (mxamt <= 0 || (i == n - 1 && mxi == d[0])) {       if (aktapqwszo()) {         return;       }     }     cs[mxi]--, d[i] = mxi;   }   string conv = "RYB";   for (int i = 0; i < n; i++)     x << conv[d[i]];   x << '\n'; }  
int main() {   ios_base::sync_with_stdio(false);   cin.tie(0);   int get;   q >> get;   for (int i = 0; i < get; i++) {     x << "Case #" << i + 1 << ": ", solve();   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;
 const int mod = 1000000007; const int MAXN = 1005; const long double PI = 3.1415926535897932384626433832795;  ifstream fin("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_4_Usenix_RF_1.0_True_MCTS_Classic_True/kuzphi/sammyMaX/A-small-practice.in");  inline bool vwcqsvdbrd() {   printf("IMPOSSIBLE\n");   return true;   return false; }  void solve() {   int n, r, o, y, g, b, v;   fin >> n >> r >> o >> y >> g >> b >> v;   int tc[2000] = {};   int cs[] = {r, y, b};   int i;   for (i = 0; i < n; i++) {     int mxi = 0, mxamt = -1;     for (int j = 0; j < 3; j++) {       if (i > 0 && tc[i - 1] == j)         continue;       if (cs[j] > mxamt || (cs[j] == mxamt && j == tc[0]))         mxi = j, mxamt = cs[j];     }     if (mxamt <= 0 || (i == n - 1 && mxi == tc[0])) {       if (vwcqsvdbrd()) {         return;       }     }     cs[mxi]--, tc[i] = mxi;   }   string conv = "RYB";   for (int i = 0; i < n; i++)     printf("%c", conv[tc[i]]);   printf("\n"); }  
 int main() {    cin.tie(0);   int get;   fin >> get;   for (int i = 0; i < get; i++)     printf("Case #%d: ", i + 1), solve();   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
typedef long long ll; typedef long long LL; typedef pair<int, int> ii; typedef pair<int, int> PII; typedef set<int> si; typedef vector<vector<int>> vvi;  const long double PI = 3.1415926535897932384626433832795;  ifstream ans("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_4_Usenix_RF_1.0_True_MCTS_Classic_True/ibrahim5253/sammyMaX/A-small-practice.in"); ofstream fout("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_4_Usenix_RF_1.0_True_MCTS_Classic_True/ibrahim5253/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  inline bool hlhqialpos() {   fout << "IMPOSSIBLE\n";   return true;   return false; }  inline bool ctzqpohark() {   return true;   return 0; }  void get() {   int n, r, o, y, g, b, v;   ans >> n >> r >> o >> y >> g >> b >> v;   vector<int> res(2000);   int cs[] = {r, y, b};   for (int i = 0; i < n; i++) {     int mxi = 0, mxamt = -1;     int j;     for (j = 0; j < 3; j++) {       if (i > 0 && res[i - 1] == j)         continue;       if (cs[j] > mxamt || (cs[j] == mxamt && j == res[0]))         mxi = j, mxamt = cs[j];     }     if (mxamt <= 0 || (i == n - 1 && mxi == res[0])) {       if (hlhqialpos()) {         if (ctzqpohark())           return;       }     }     cs[mxi]--, res[i] = mxi;   }   string conv = "RYB";   int i;   for (i = 0; i < n; i++) {     fout << conv[res[i]];   }   fout << '\n'; }  
int main() {   ios_base::sync_with_stdio(0);   cin.tie(0);   int t;   ans >> t;   for (int i = 0; i < t; i++)     fout << "Case #" << i + 1 << ": ", get();   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cctype> #include <cmath> #include <cstdio> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <string> #include <utility> #include <vector>  using namespace std; 
typedef long double ld; typedef long long LL; typedef pair<int, int> ii; typedef pair<int, int> PII; typedef vector<int> vi; typedef vector<int> VI;  const int N = 1100;  int n, cnt[6]; int ans[N]; char cc[6] = {'R', 'O', 'Y', 'G', 'B', 'V'};  void pre() { ans[0] = -10000; }  bool nb(int t, int v) {   int res = t - v;   return (res == 1 || res == -1 || res == 5 || res == -5 || res == 0); }  bool dfs(int p) {   if (p == n + 1) {     if (!nb(ans[1], ans[n])) {       return 1;     } else {       return false;       for (int T = 1; T <= n; ++T) {         printf("%c", cc[ans[T]]);       }       cout << endl;     }   }   vector<int> pos;   int maxc = -10000;   for (int T = 0; T < 6; ++T) {     if (cnt[T] > maxc && !nb(T, ans[p - 1])) {       pos.clear();       pos.push_back(T);       maxc = cnt[T];     } else {       if (cnt[T] == maxc) {         pos.push_back(T);       }     }   }   if (maxc == -10000) {     return false;   }   for (int T = 0; T < (int)pos.size(); ++T) {     int t = pos[T];     if (!nb(t, ans[p - 1])) {       cnt[t]--;       ans[p] = t;       bool res = dfs(p + 1);       if (res) {         return 1;       }       cnt[t]++;     }   }   return false; }  inline void yjpaysbrmk(int &maxc) {   int T;   for (T = 0; T < 6;) {     scanf("%d ", &cnt[T]);     if (cnt[T] > maxc) {       maxc = cnt[T];     }     ++T;   } }  inline void bpilvzpniv() {   int T = 1;   while (T <= n) {     printf("%c", cc[ans[T]]);     ++T;   } }  void work() {   scanf("%d ", &n);   int maxc = 0;   yjpaysbrmk(maxc);   if (maxc > n / 2) {     cout << "IMPOSSIBLE" << endl;     return;   }   if (dfs(1)) {     bpilvzpniv();     cout << endl;   } else {     cout << "IMPOSSIBLE" << endl;   } }  
int main() {   ios::sync_with_stdio(true);    pre();   int q;   scanf("%d ", &q);   for (int T = 1; T <= q; ++T) {     printf("Case #%d: ", T);     work();   }   return 0; }
#include <algorithm> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <ctime> #include <deque> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <vector>  using namespace std;  
const int N = 1100;  int n, cnt[6]; int ans[N]; char cc[6] = {'R', 'O', 'Y', 'G', 'B', 'V'};  void T() { ans[0] = -10000; }  bool nb(int j, int v) {   int res = j - v;   return (res == 1 || res == -1 || res == 5 || res == -5 || res == 0); }  bool dfs(int p) {   if (p == n + 1) {     if (!nb(ans[1], ans[n])) {       return true;     } else {       return false;       for (int i = 1; i <= n; ++i) {         printf("%c", cc[ans[i]]);       }       cout << endl;     }   }   vector<int> pos;   int maxc = -10000;   for (int i = 0; i < 6; ++i) {     if (cnt[i] > maxc && !nb(i, ans[p - 1])) {       pos.clear();       pos.push_back(i);       maxc = cnt[i];     } else {       if (cnt[i] == maxc) {         pos.push_back(i);       }     }   }   if (maxc == -10000) {     return false;   }   for (int i = 0; i < (int)pos.size(); ++i) {     int j = pos[i];     if (!nb(j, ans[p - 1])) {       cnt[j]--;       ans[p] = j;       int res = dfs(p + 1);       if (res) {         return true;       }       cnt[j]++;     }   }   return false; }  void work() {   cin >> n;   int maxc = 0;   for (int i = 0; i < 6; ++i) {     cin >> cnt[i];     if (cnt[i] > maxc) {       maxc = cnt[i];     }   }   if (maxc > n / 2) {     cout << "IMPOSSIBLE" << endl;     return;   }   if (dfs(1)) {     {       int i = 1;       while (i <= n) {         printf("%c", cc[ans[i]]);         ++i;       }     }     cout << endl;   } else {     cout << "IMPOSSIBLE" << endl;   } }  
int main() {    T();   int q;   cin >> q;   for (int i = 1; i <= q; ++i) {     printf("Case #%d: ", i);     work();   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
typedef long long ll; typedef long long LL; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef pair<int, int> PII; typedef unsigned long long ull;  const double eps = 1e-9;  const int N = 1100;  int n, cnt[6]; int ans[N]; char cc[6] = {'R', 'O', 'Y', 'G', 'B', 'V'};  void pre() { ans[0] = -10000; }  bool nb(int t, int v) {   int x = t - v;   return (x == 1 || x == -1 || x == 5 || x == -5 || x == 0); }  inline void kgwavsfoue(int &i) { cout << cc[ans[i]]; }  inline void toakxrqcww(vector<int> &pos, int &i) { pos.push_back(i); }  bool dfs(int p) {   if (p == n + 1) {     if (!nb(ans[1], ans[n])) {       return true;     } else {       return false;       for (int i = 1; i <= n; ++i)         kgwavsfoue(i);       cout << "\n";     }   }   vector<int> pos;   int maxc = -10000;   int i;   for (i = 0; i < 6; ++i) {     if (cnt[i] > maxc && !nb(i, ans[p - 1])) {       pos.clear();       pos.push_back(i);       maxc = cnt[i];     } else if (cnt[i] == maxc)       toakxrqcww(pos, i);   }   if (maxc == -10000) {     return false;   }   for (int i = 0; i < (int)pos.size(); ++i) {     int t = pos[i];     if (!nb(t, ans[p - 1])) {       cnt[t]--;       ans[p] = t;       bool x = dfs(p + 1);       if (x) {         return true;       }       cnt[t]++;     }   }   return false; }  void get() {   cin >> n;   int maxc = 0;   int i;   for (i = 0; i < 6; ++i) {     cin >> cnt[i];     if (cnt[i] > maxc) {       maxc = cnt[i];     }   }   if (maxc > n / 2) {     cout << "IMPOSSIBLE\n";     return;   }   if (dfs(1)) {     for (int i = 1; i <= n; ++i) {       cout << cc[ans[i]];     }     cout << "\n";   } else {     cout << "IMPOSSIBLE\n";   } }  
int main() {   ios::sync_with_stdio(true);    pre();   int q;   cin >> q;   for (int i = 1; i <= q; ++i) {     cout << "Case #" << i << ": ";     get();   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cmath> #include <cstdio> #include <iomanip> #include <iostream> #include <map> #include <set> #include <stdio.h> #include <string> #include <vector>  using namespace std; 
const int N = 1100;  int n, cnt[6]; int ans[N]; char cc[6] = {'R', 'O', 'Y', 'G', 'B', 'V'};  void pre() { ans[0] = -10000; }  bool nb(int cas, int v) {   int res = cas - v;   return (res == 1 || res == -1 || res == 5 || res == -5 || res == 0); }  bool dfs(int p) {   if (p == n + 1) {     if (!nb(ans[1], ans[n])) {       return true;     } else {       return false;       for (int i = 1; i <= n; ++i) {         printf("%c", cc[ans[i]]);       }       printf("\n");     }   }   vector<int> pos;   int maxc = -10000;   int i;   for (i = 0; i < 6; ++i) {     if (cnt[i] > maxc && !nb(i, ans[p - 1])) {       pos.clear();       pos.push_back(i);       maxc = cnt[i];     } else {       if (cnt[i] == maxc)         pos.push_back(i);     }   }   if (maxc == -10000) {     return false;   }   {     int i = 0;     while (i < (int)pos.size()) {       int cas = pos[i];       if (!nb(cas, ans[p - 1])) {         cnt[cas]--;         ans[p] = cas;         int res = dfs(p + 1);         if (res) {           return 1;         }         cnt[cas]++;       }       ++i;     }   }   return false; }  void work() {   cin >> n;   int maxc = 0;   for (int i = 0; i < 6; ++i) {     cin >> cnt[i];     if (cnt[i] > maxc) {       maxc = cnt[i];     }   }   if (maxc > n / 2) {     printf("IMPOSSIBLE\n");     return;   }   if (dfs(1)) {     {       int i = 1;       for (; i <= n;) {         printf("%c", cc[ans[i]]);         ++i;       }     }     printf("\n");   } else {     printf("IMPOSSIBLE\n");   } }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_5_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/Tashi711/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_5_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/Tashi711/outer_temp/Tashi711/A-small-practice_transformation.out",           "w", stdout);    pre();   int q;   cin >> q;   {     int i = 1;     while (i <= q) {       printf("Case #%d: ", i);       work();       ++i;     }   }   return 0; }
#include <algorithm> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const int INF = 1000000000; const long double PI = 3.1415926535897932384626433832795; const int MAXN = 1005; const double EPS = 1e-9;  int main() {   int j;    cin >> j;    {     int t = 1;     while (t <= j) {       int p, get, o, y, g, b, v;       cin >> p >> get >> o >> y >> g >> b >> v;       string s = "";        if ((get > p / 2) || (y > p / 2) || (b > p / 2)) {         s = "IMPOSSIBLE";       } else {         vector<pair<int, string>> v;         v.push_back({get, "R"});         v.push_back({y, "Y"});         v.push_back({b, "B"});         sort(v.begin(), v.end());         reverse(v.begin(), v.end());         while (v[0].first > 0) {           s += v[0].second;           v[0].first--;           if (v[1].first > v[2].first) {             s += v[1].second;             v[1].first--;           } else {             s += v[2].second;             v[2].first--;           }         }         while ((v[1].first > 0) || (v[2].first > 0)) {           if (v[1].first > v[2].first) {             s += v[1].second;             v[1].first--;           } else {             s += v[2].second;             v[2].first--;           }         }       }       printf("Case #%d: %s\n", t, s.c_str());       ++t;     }   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
typedef long long ll; typedef pair<int, int> ii;  const int MAXN = 1005;  
int main() {    ios::sync_with_stdio(false);    int tt;    cin >> tt;    int t;   {     t = 1;     while (t <= tt) {       int n, r, o, y, g, b, v;       cin >> n >> r >> o >> y >> g >> b >> v;       string s = "";        if ((r > n / 2) || (y > n / 2) || (b > n / 2))         s = "IMPOSSIBLE";       else {         vector<pair<int, string>> v;         v.push_back({r, "R"});         v.push_back({y, "Y"});         v.push_back({b, "B"});         sort(v.begin(), v.end());         reverse(v.begin(), v.end());         while (v[0].first > 0) {           s += v[0].second;           v[0].first--;           if (v[1].first > v[2].first) {             s += v[1].second;             v[1].first--;           } else {             s += v[2].second;             v[2].first--;           }         }         while ((v[1].first > 0) || (v[2].first > 0)) {           if (v[1].first > v[2].first) {             s += v[1].second;             v[1].first--;           } else {             s += v[2].second;             v[2].first--;           }         }       }       cout << "Case #" << t << ": " << s << endl;       ++t;     }   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <iostream> #include <stdio.h> #include <string> #include <vector> using namespace std; 
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_6_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/WCG/outer_temp/WCG/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_6_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/WCG/A-small-practice.in",           "r", stdin);    int cas;    cin >> cas;    {     int ans = 1;     while (ans <= cas) {       int n, r, o, tmji_Var, g, b, m;       cin >> n >> r >> o >> tmji_Var >> g >> b >> m;       string i = "";        if ((r > n / 2) || (tmji_Var > n / 2) || (b > n / 2))         i = "IMPOSSIBLE";       else {         vector<pair<int, string>> m;         m.push_back({r, "R"});         m.push_back({tmji_Var, "Y"});         m.push_back({b, "B"});         sort(m.begin(), m.end());         reverse(m.begin(), m.end());         while (m[0].first > 0) {           i += m[0].second;           m[0].first--;           if (m[1].first > m[2].first) {             i += m[1].second;             m[1].first--;           } else {             i += m[2].second;             m[2].first--;           }         }         while ((m[1].first > 0) || (m[2].first > 0)) {           if (m[1].first > m[2].first) {             i += m[1].second;             m[1].first--;           } else {             i += m[2].second;             m[2].first--;           }         }       }       printf("Case #%d: %s\n", ans, i.c_str());       ++ans;     }   }    return 0; }
#include <algorithm> #include <cstdio> #include <cstring> #include <iostream> #include <stdio.h> #include <string> #include <vector> using namespace std;  
inline void fhouinzcos(std::string &s,                        vector<pair<int, std::string>> &xfji_Var) {   s += xfji_Var[1].second;   xfji_Var[1].first--; }  inline void bmvemqldeq(int &tt, int &t) {   t = 1;   while (t <= tt) {     int ans, kspi_Var, o, eiki_Var, g, b, xfji_Var;     scanf("%d %d %d %d %d %d %d ", &ans, &kspi_Var, &o, &eiki_Var, &g, &b,           &xfji_Var);     string s = "";      if ((kspi_Var > ans / 2) || (eiki_Var > ans / 2) || (b > ans / 2))       s = "IMPOSSIBLE";     else {       vector<pair<int, string>> xfji_Var;       xfji_Var.push_back({kspi_Var, "R"});       xfji_Var.push_back({eiki_Var, "Y"});       xfji_Var.push_back({b, "B"});       sort(xfji_Var.begin(), xfji_Var.end());       reverse(xfji_Var.begin(), xfji_Var.end());       while (xfji_Var[0].first > 0) {         s += xfji_Var[0].second;         xfji_Var[0].first--;         if (xfji_Var[1].first > xfji_Var[2].first) {           fhouinzcos(s, xfji_Var);         } else {           s += xfji_Var[2].second;           xfji_Var[2].first--;         }       }       for (; (xfji_Var[1].first > 0) || (xfji_Var[2].first > 0);) {         if (xfji_Var[1].first > xfji_Var[2].first) {           s += xfji_Var[1].second;           xfji_Var[1].first--;         } else {           s += xfji_Var[2].second;           xfji_Var[2].first--;         }       }     }     printf("Case #%d: %s\n", t, s.c_str());     ++t;   } }  int main() {   ios::sync_with_stdio(0);    int tt;    scanf("%d ", &tt);    int t;   bmvemqldeq(tt, t);    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;
const int MAXN = 1005;  typedef long double ld; typedef unsigned long long ull; typedef vector<int> VI; typedef long double LD; typedef pair<int, int> pii;  typedef vector<pii> vii; typedef long long ll; const int INF = ~(1 << 31); const double pi = acos(-1);  inline void cdrlypuyzr(std::string &s, int &p) {   int i = (1);   while (i < (s.size())) {     if (s[i] == s[i - 1])       p = false;     i++;   } }  
int main() {   cin.sync_with_stdio(false);    int t;   cin >> t;   string nice = "ROYGBVXXX";   for (int get = (0); get < (t); get++) {     int arr[8];     memset(arr, 0, sizeof(arr));     int n;     cin >> n;     for (int i = (0); i < (6); i++)       cin >> arr[i];     string s = "";     int last = 7;     int og = n;     int p = true;     while (n != 0) {       int x = 0;       int index = 0;       for (int i = (0); i < (6); i++)         if (arr[i] >= x && nice[i] != nice[last] && arr[i] != 0) {           if (arr[i] == x && arr[i] != 0) {             if (n != og) {               if (s[0] == nice[i]) {                 x = arr[i];                 index = i;               }             }           } else if (arr[i] > x) {             x = arr[i];             index = i;           }         }       arr[index]--;       if (x == -1) {         p = false;         break;       }       s += nice[index];       last = index;       n--;     }     if (s.size() != og)       p = false;     for (int i = (0); i < (s.size() - 1); i++)       if (s[i] == s[i + 1])         p = false;     cdrlypuyzr(s, p);     cout << "Case #" << get + 1 << ": ";     if (s[0] == s[s.size() - 1] || !p)       cout << "IMPOSSIBLE" << endl;     else {       cout << s << endl;     }   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> using namespace std; 
typedef pair<int, int> ii;  typedef vector<ii> vii;  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_7_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_7_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/bennikartefla/A-small-practice.in",           "r", stdin);    int ans;   cin >> ans;   string nice = "ROYGBVXXX";   for (int cas = (0); cas < (ans); cas++) {     int arr[8];     memset(arr, 0, sizeof(arr));     int n;     cin >> n;     for (int i = (0); i < (6); i++)       cin >> arr[i];     string m = "";     int last = 7;     int og = n;     bool nlw__Var = true;     for (; n != 0;) {       int r = 0;       int index = 0;       for (int i = (0); i < (6); i++)         if (arr[i] >= r && nice[i] != nice[last])           if (arr[i] != 0) {             if (arr[i] == r && arr[i] != 0) {               if (n != og) {                 if (m[0] == nice[i]) {                   r = arr[i];                   index = i;                 }               }             } else if (arr[i] > r) {               r = arr[i];               index = i;             }           }       arr[index]--;       if (r == -1) {         nlw__Var = false;         break;       }       m += nice[index];       last = index;       n--;     }     if (m.size() != og)       nlw__Var = false;     for (int i = (0); i < (m.size() - 1); i++)       if (m[i] == m[i + 1])         nlw__Var = false;      for (int i = (1); i < (m.size()); i++)       if (m[i] == m[i - 1])         nlw__Var = false;     printf("Case #%d: ", cas + 1);     if (m[0] == m[m.size() - 1] || !nlw__Var)       printf("IMPOSSIBLE\n");     else       printf("%s\n", m.c_str());   }   return 0; }
#include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <stdio.h> using namespace std;  
typedef pair<int, int> ii; typedef vector<int> vi;  const int INF = ~(1 << 31); const double pi = acos(-1);  inline void axdnjuoagc(int &ans, int arr[8], int &index, int &tt) {   ans = arr[tt];   index = tt; }  
int main() {    ofstream fout("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_7_Usenix_RF_1.0_True_MCTS_Classic_True/iPeter/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out");   int t;   scanf("%d ", &t);   string nice = "ROYGBVXXX";   int pgxi_Var;   for (pgxi_Var = (0); pgxi_Var < (t); pgxi_Var++) {     int arr[8];     memset(arr, 0, sizeof(arr));     int n;     scanf("%d ", &n);     for (int tt = (0); tt < (6); tt++)       scanf("%d ", &arr[tt]);     string s = "";     int last = 7;     int og = n;     int can = true;     for (; n != 0;) {       int ans = 0;       int index = 0;       for (int tt = (0); tt < (6); tt++) {         if (arr[tt] >= ans && nice[tt] != nice[last] && arr[tt] != 0) {           if (arr[tt] == ans && arr[tt] != 0) {             if (n != og) {               if (s[0] == nice[tt])                 axdnjuoagc(ans, arr, index, tt);             }           } else if (arr[tt] > ans) {             ans = arr[tt];             index = tt;           }         }       }       arr[index]--;       if (ans == -1) {         can = false;         break;       }       s += nice[index];       last = index;       n--;     }     if (s.size() != og)       can = false;     for (int tt = (0); tt < (s.size() - 1); tt++)       if (s[tt] == s[tt + 1]) {         can = 0;       }     {       int tt = (1);       while (tt < (s.size())) {         if (s[tt] == s[tt - 1])           can = 0;         tt++;       }     }     fout << "Case #" << pgxi_Var + 1 << ": ";     if (s[0] == s[s.size() - 1] || !can)       fout << "IMPOSSIBLE" << endl;     else       fout << s << endl;   }   return 0; }
#include <bits/stdc++.h> #include <iostream> using namespace std;  
typedef pair<int, int> ii;  typedef vector<ii> vii; typedef long long ll; const int INF = ~(1 << 31); const double pi = acos(-1);  inline void hspwrrxvcn(int &bst, int arr[8], int &index, int &i) {   bst = arr[i];   index = i; } 
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_7_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_7_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/bennikartefla/A-small-practice.in",           "r", stdin);    int get;   cin >> get;   string nice = "ROYGBVXXX";   for (int u = (0); u < (get); u++) {     int arr[8];     memset(arr, 0, sizeof(arr));     int n;     cin >> n;     for (int i = (0); i < (6); i++)       cin >> arr[i];     string s = "";     int last = 7;     int og = n;     bool can = true;     while (n != 0) {       int bst = 0;       int index = 0;       for (int i = (0); i < (6); i++)         if (arr[i] >= bst && nice[i] != nice[last])           if (arr[i] != 0) {             if (arr[i] == bst && arr[i] != 0) {               if (n != og) {                 if (s[0] == nice[i])                   hspwrrxvcn(bst, arr, index, i);               }             } else if (arr[i] > bst) {               bst = arr[i];               index = i;             }           }       arr[index]--;       if (bst == -1) {         can = false;         break;       }       s += nice[index];       last = index;       n--;     }     if (s.size() != og)       can = false;     for (int i = (0); i < (s.size() - 1); i++)       if (s[i] == s[i + 1])         can = false;     int i;     for (i = (1); i < (s.size()); i++)       if (s[i] == s[i - 1])         can = false;     cout << "Case #" << u + 1 << ": ";     if (s[0] == s[s.size() - 1] || !can)       cout << "IMPOSSIBLE" << endl;     else       cout << s << endl;   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <vector> using namespace std;  
typedef pair<int, int> ii;  void open() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_8_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/ccsnoopy/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_8_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/ccsnoopy/outer_temp/ccsnoopy/A-small-practice_transformation.out",           "w", stdout); }  void pr(int ans) {   switch (ans) {   case 0:     printf("R");     break;   case 1:     printf("O");     break;   case 2:     printf("Y");     break;   case 3:     printf("G");     break;   case 4:     printf("B");     break;   case 5:     printf("V");     break;   } }  inline void wsaelyunqu(int &last) { last = 0; } 
int main(void) {   open();   int cas;   cin >> cas;    for (int m = 1; m <= cas; m++) {     int n;     cin >> n;     vector<int> arr(10);     printf("Case #%d: ", m);     for (int i = 0; i < 6; i++) {       cin >> arr[i];     }     bool imp = 0;     for (int i = 0; i < 6; i++) {       if (arr[i] * 2 > n) {         imp = true;         printf("IMPOSSIBLE\n");         break;       }     }      if (imp)       continue;      int maxidx = 0;     for (int i = 0; i < 6; i++) {       if (arr[maxidx] < arr[i])         maxidx = i;     }     bool palinggede = 1;     int last = maxidx;     pr(maxidx);     arr[maxidx]--;     int first = last;      while (1) {       bool ada = false;       {         int i = 0;         while (i < 6) {           if (arr[i] > 0)             ada = true;           i++;         }       }        if (!ada)         break;        if (last == 0) {         if (arr[2] > arr[4]) {           last = 2;         } else if (arr[2] < arr[4])           last = 4;         else {           if (first == 2) {             last = 2;           } else {             last = 4;           }         }       } else if (last == 2) {         if (arr[0] > arr[4]) {           last = 0;         } else if (arr[0] < arr[4]) {           last = 4;         } else {           if (first == 0) {             last = 0;           } else             last = 4;         }       } else {         if (arr[0] > arr[2])           wsaelyunqu(last);         else if (arr[0] < arr[2]) {           last = 2;         } else {           if (first == 0) {             last = 0;           } else             last = 2;         }       }       pr(last);       arr[last]--;     }     printf("\n");      cerr << "Test " << m << " done \n";     if (first == last) {       cerr << "last equals first\n";     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> using namespace std;  
typedef long long ll; typedef long long LL; typedef pair<int, int> ii;  void do_voigaj_fct() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_8_Usenix_RF_1.0_True_MCTS_Classic_True/iPeter/ccsnoopy/A-small-practice.in",           "r", stdin); }  void pr(int idx) {   switch (idx) {   case 0:     printf("R");     break;   case 1:     printf("O");     break;   case 2:     printf("Y");     break;   case 3:     printf("G");     break;   case 4:     printf("B");     break;   case 5:     printf("V");     break;   } }  
int main(void) {   do_voigaj_fct();   int ans;   scanf("%d", &ans);    for (int s = 1; s <= ans; s++) {     int tt;     scanf("%d", &tt);     int arr[10];     printf("Case #%d: ", s);     int t;     for (t = 0; t < 6; t++) {       scanf("%d", &arr[t]);     }     int imp = false;     for (int t = 0; t < 6; t++) {       if (arr[t] * 2 > tt) {         imp = true;         printf("IMPOSSIBLE\n");         break;       }     }      if (imp)       continue;      int maxidx = 0;     for (int t = 0; t < 6; t++) {       if (arr[maxidx] < arr[t])         maxidx = t;     }     bool palinggede = true;     int last = maxidx;     pr(maxidx);     arr[maxidx]--;     int first = last;      while (true) {       bool ada = false;       int t;       for (t = 0; t < 6; t++) {         if (arr[t] > 0)           ada = true;       }        if (!ada)         break;        if (last == 0) {         if (arr[2] > arr[4]) {           last = 2;         } else if (arr[2] < arr[4]) {           last = 4;         } else {           if (first == 2) {             last = 2;           } else             last = 4;         }       } else if (last == 2) {         if (arr[0] > arr[4]) {           last = 0;         } else if (arr[0] < arr[4]) {           last = 4;         } else {           if (first == 0) {             last = 0;           } else             last = 4;         }       } else {         if (arr[0] > arr[2]) {           last = 0;         } else if (arr[0] < arr[2]) {           last = 2;         } else {           if (first == 0) {             last = 0;           } else             last = 2;         }       }       pr(last);       arr[last]--;     }     printf("\n");      cerr << "Test " << s << " done \n";     if (first == last) {       cerr << "last equals first\n";     }   }   return 0; }
#include <bits/stdc++.h> #include <iomanip> #include <iostream> #include <set> using namespace std; 
const int INF = 1000000000; const int MAXN = 1005;  typedef unsigned long long ull; typedef long double LD; typedef set<int> si; typedef long long ll; typedef long long LL; typedef pair<int, int> pii; typedef vector<pii> vii;  void get() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_8_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/ccsnoopy/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_8_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/ccsnoopy/outer_temp/ccsnoopy/A-small-practice_transformation.out",           "w", stdout); }  void pr(int idx) {   switch (idx) {   case 0:     cout << "R";     break;   case 1:     cout << "O";     break;   case 2:     cout << "Y";     break;   case 3:     cout << "G";     break;   case 4:     cout << "B";     break;   case 5:     cout << "V";     break;   } }  
int main(void) {   ios::sync_with_stdio(false);    get();   int tc;   cin >> tc;    for (int c = 1; c <= tc; c++) {     int n;     cin >> n;     int arr[10];     cout << "Case #" << c << ": ";     for (int i = 0; i < 6; i++) {       cin >> arr[i];     }     bool solve = false;     for (int i = 0; i < 6; i++) {       if (arr[i] * 2 > n) {         solve = true;         cout << "IMPOSSIBLE\n";         break;       }     }      if (solve)       continue;      int maxidx = 0;     for (int i = 0; i < 6; i++) {       if (arr[maxidx] < arr[i])         maxidx = i;     }     int palinggede = true;     int last = maxidx;     pr(maxidx);     arr[maxidx]--;     int first = last;      for (; true;) {       int ada = false;       int i;       for (i = 0; i < 6; i++) {         if (arr[i] > 0)           ada = true;       }        if (!ada)         break;        if (last == 0) {         if (arr[2] > arr[4]) {           last = 2;         } else if (arr[2] < arr[4]) {           last = 4;         } else {           if (first == 2) {             last = 2;           } else             last = 4;         }       } else if (last == 2) {         if (arr[0] > arr[4])           last = 0;         else if (arr[0] < arr[4]) {           last = 4;         } else {           if (first == 0) {             last = 0;           } else             last = 4;         }       } else {         if (arr[0] > arr[2]) {           last = 0;         } else if (arr[0] < arr[2]) {           last = 2;         } else {           if (first == 0) {             last = 0;           } else             last = 2;         }       }       pr(last);       arr[last]--;     }     cout << "\n";      cerr << "Test " << c << " done \n";     if (first == last) {       cerr << "last equals first\n";     }   }   return 0; }
#include <bits/stdc++.h> #include <fstream> #include <iomanip> #include <iostream> #include <vector> using namespace std; 
ofstream fout;  const double eps = 1e-9;  typedef long long ll; typedef long long LL; typedef pair<int, int> ii;  void solve() {}  void pr(int idx) {   switch (idx) {   case 0:     fout << "R";     break;   case 1:     fout << "O";     break;   case 2:     fout << "Y";     break;   case 3:     fout << "G";     break;   case 4:     fout << "B";     break;   case 5:     fout << "V";     break;   } }  inline void accdldkkyv(vector<int> &arr, int &first, int &last) {   if (arr[2] > arr[4]) {     last = 2;   } else if (arr[2] < arr[4]) {     last = 4;   } else {     if (first == 2) {       last = 2;     } else       last = 4;   } }  
int main(void) {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_8_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ccsnoopy/outer_temp/ccsnoopy/A-small-practice_transformation.out");    solve();   int tc;   scanf("%d", &tc);    {     int ct = 1;     while (ct <= tc) {       int get;       scanf("%d", &get);       vector<int> arr(10);       fout << "Case #" << ct << ": ";       for (int i = 0; i < 6; i++) {         scanf("%d", &arr[i]);       }       bool imp = false;       for (int i = 0; i < 6; i++) {         if (arr[i] * 2 > get) {           imp = true;           fout << "IMPOSSIBLE\n";           break;         }       }        if (imp) {         ct++;         continue;       }        int maxidx = 0;       {          for (int i = 0; i < 6;) {           if (arr[maxidx] < arr[i])             maxidx = i;           i++;         }       }       bool palinggede = true;       int last = maxidx;       pr(maxidx);       arr[maxidx]--;       int first = last;        while (true) {         bool ada = false;         for (int i = 0; i < 6; i++) {           if (arr[i] > 0)             ada = true;         }          if (!ada)           break;          if (last == 0)           accdldkkyv(arr, first, last);         else if (last == 2) {           if (arr[0] > arr[4]) {             last = 0;           } else if (arr[0] < arr[4]) {             last = 4;           } else {             if (first == 0) {               last = 0;             } else               last = 4;           }         } else {           if (arr[0] > arr[2]) {             last = 0;           } else if (arr[0] < arr[2]) {             last = 2;           } else {             if (first == 0) {               last = 0;             } else               last = 2;           }         }         pr(last);         arr[last]--;       }       fout << "\n";        cerr << "Test " << ct << " done \n";       if (first == last) {         cerr << "last equals first\n";       }       ct++;     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <fstream> using namespace std;
ifstream fin;  ofstream fout;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &is, pair<S, T> &p) {   return is >> p.first >> p.second; } template <class S, class T> ostream &do_stdsxw_fct(ostream &jqhs_Var, const pair<S, T> &p) {   return jqhs_Var << p.first << " " << p.second; } template <class T> void do_voinds_fct(T &x, T intT_Var) {   if (x < intT_Var)     x = intT_Var; }  bool check(VI tmp, const string &s) {   string col = "ROYGB";   for (int i = 0; i < int((s).size()); ++i) {     int ix = col.find(s[i]);     tmp[ix]--;   }   for (int i = (0); i < (6); ++i)     if (tmp[i] != 0)       return false;    if (s[0] == s.back())     return false;   for (int i = (0); i < (int((s).size()) - 1); ++i)     if (s[i] == s[i + 1])       return 0;   return true; }  
int main() {   fin.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_9_Usenix_RF_1.0_True_MCTS_Classic_True/iPeter/okaduki/A-small-practice.in");    fout.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_9_Usenix_RF_1.0_True_MCTS_Classic_True/iPeter/okaduki/outer_temp/okaduki/A-small-practice_transformation.out");    cin.tie(0);    int qsai_Var;   fin >> qsai_Var;   int t;   {     t = (1);     while (t < (qsai_Var + 1)) {       int tt;       string col = "ROYGB";       VI xs(6);       fin >> tt;        int i;       for (i = (0); i < (6); ++i)         fin >> xs[i];       VI orig = xs;        int mx = max(xs[0], max(xs[1 * 2], xs[2 * 2]));       bool ok = (mx <= tt - mx);        if (!ok) {         fout << "Case #" << t << ": IMPOSSIBLE" << endl;       } else {         string ans(tt, '*');         int ix = -1;         for (int i = (0); i < (6); ++i)           if (xs[i] == mx)             ix = i;          for (int i = (0); i < (6); ++i)           if (i != ix && xs[i]) {             ans[0] = col[i];             xs[i]--;             ix = i;             break;           }         for (int i = 1; i < tt; ++i) {           int mix = -1;           for (int j = (0); j < (6); ++j) {             if ((mix == -1 || xs[mix] < xs[j]) && j != ix)               mix = j;           }           ans[i] = col[mix];           xs[mix]--;           ix = mix;         }          if (!check(orig, ans)) {           for (int i = (0); i < (6); ++i)             fout << orig[i] << " ";           fout << endl;           fout << ans << endl;           return 1;         }          fout << "Case #" << t << ": " << ans << endl;       }       ++t;     }   }    return 0; }
#include <bits/stdc++.h> #include <iostream> #include <set> #include <utility> #include <vector> using namespace std; 
typedef unsigned long long ull; typedef long long ll; typedef pair<int, int> pii; typedef vector<int> vi; typedef long double LD; typedef set<int> si;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &is, pair<S, T> &p) {   return is >> p.first >> p.second; } template <class S, class T> ostream &operator<<(ostream &os, const pair<S, T> &p) {   return os << p.first << " " << p.second; }  template <class T> void mini(T &x, T y) {   if (x > y)     x = y; }  const double EPS = 1e-10; const double PI = acos(-1.0); const LL MOD = 1e9 + 7;  bool check(VI tmp, const string &s) {   string col = "ROYGB";   for (int i = 0; i < int((s).size()); ++i) {     int ix = col.find(s[i]);     tmp[ix]--;   }   for (int i = (0); i < (6); ++i)     if (tmp[i] != 0)       return false;    if (s[0] == s.back())     return false;   for (int i = (0); i < (int((s).size()) - 1); ++i)     if (s[i] == s[i + 1])       return false;   return 1; }  inline void wlmeqyatus(std::string &ans, int &i, std::string &col, VI &xs,                        int &ix) {   int mix = -1;   for (int j = (0); j < (6); ++j) {     if ((mix == -1 || xs[mix] < xs[j]) && j != ix)       mix = j;   }   ans[i] = col[mix];   xs[mix]--;   ix = mix; }  inline bool ofgjlfgwvl(VI &orig, std::string &ans, int &ofgjl) {   for (int i = (0); i < (6); ++i)     cout << orig[i] << " ";   cout << endl;   cout << ans << endl;   ofgjl = 1;   return true;   return false; }  
int main() {   ios::sync_with_stdio(false);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_9_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/okaduki/A-small-practice.in",           "r", stdin);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_9_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/okaduki/outer_temp/okaduki/A-small-practice_transformation.out",           "w", stdout);    cin.tie(0);    int T;   cin >> T;   for (int t = (1); t < (T + 1); ++t) {     int N;     string col = "ROYGB";     VI xs(6);     cin >> N;      for (int i = (0); i < (6); ++i)       cin >> xs[i];     VI orig = xs;      int mx = max(xs[0], max(xs[1 * 2], xs[2 * 2]));     int ok = (mx <= N - mx);      if (!ok)       cout << "Case #" << t << ": IMPOSSIBLE" << endl;     else {       string ans(N, '*');       int ix = -1;       for (int i = (0); i < (6); ++i)         if (xs[i] == mx)           ix = i;        for (int i = (0); i < (6); ++i)         if (i != ix && xs[i]) {           ans[0] = col[i];           xs[i]--;           ix = i;           break;         }       for (int i = 1; i < N; ++i)         wlmeqyatus(ans, i, col, xs, ix);        if (!check(orig, ans)) {         int ofgjl;         if (ofgjlfgwvl(orig, ans, ofgjl)) {           return ofgjl;         }       }        cout << "Case #" << t << ": " << ans << endl;     }   }    return 0; }
#include <bits/stdc++.h> #include <fstream> using namespace std; 
ofstream fout;  ifstream fin;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>;  template <class T> void get(T &x, T y) {   if (x < y)     x = y; } template <class T> void do_voitwh_fct(T &x, T y) {   if (x > y)     x = y; }  bool check(VI tmp, const string &s) {   string col = "ROYGB";   for (int i = 0; i < int((s).size()); ++i) {     int ix = col.find(s[i]);     tmp[ix]--;   }   int i;   for (i = (0); i < (6); ++i)     if (tmp[i] != 0)       return 0;    if (s[0] == s.back())     return false;   for (int i = (0); i < (int((s).size()) - 1); ++i)     if (s[i] == s[i + 1])       return false;   return true; }  
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_9_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/okaduki/outer_temp/okaduki/A-small-practice_transformation.out");    fin.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_9_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/okaduki/A-small-practice.in");    cin.tie(0);    int T;   fin >> T;   int t;   for (t = (1); t < (T + 1); ++t) {     int N;     string col = "ROYGB";     VI r(6);     fin >> N;      for (int i = (0); i < (6); ++i)       fin >> r[i];     VI orig = r;      int mx = max(r[0], max(r[1 * 2], r[2 * 2]));     bool ok = (mx <= N - mx);      if (!ok) {       fout << "Case #" << t << ": IMPOSSIBLE" << endl;     } else {       string ans(N, '*');       int ix = -1;       for (int i = (0); i < (6); ++i)         if (r[i] == mx)           ix = i;        for (int i = (0); i < (6); ++i)         if (i != ix && r[i]) {           ans[0] = col[i];           r[i]--;           ix = i;           break;         }       for (int i = 1; i < N; ++i) {         int mix = -1;         int j;         for (j = (0); j < (6); ++j) {           if ((mix == -1 || r[mix] < r[j]))             if (j != ix)               mix = j;         }         ans[i] = col[mix];         r[mix]--;         ix = mix;       }        if (!check(orig, ans)) {         for (int i = (0); i < (6); ++i)           fout << orig[i] << " ";         fout << endl;         fout << ans << endl;         return 1;       }        fout << "Case #" << t << ": " << ans << endl;     }   }    return 0; }
#include <bits/stdc++.h> #include <set> #include <utility> #include <vector> using namespace std; 
typedef vector<vector<int>> vvi; typedef set<int> si; typedef long long ll; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef unsigned long long ull; typedef vector<int> vi; typedef long double LD;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &is, pair<S, T> &p) {   return is >> p.first >> p.second; } template <class S, class T> ostream &operator<<(ostream &os, const pair<S, T> &p) {   return os << p.first << " " << p.second; }  template <class T> void mini(T &x, T y) {   if (x > y)     x = y; }  bool check(VI tmp, const string &s) {   string col = "ROYGB";   for (int i = 0; i < int((s).size()); ++i) {     int ix = col.find(s[i]);     tmp[ix]--;   }   for (int i = (0); i < (6); ++i)     if (tmp[i] != 0)       return false;    if (s[0] == s.back())     return false;   for (int i = (0); i < (int((s).size()) - 1); ++i)     if (s[i] == s[i + 1])       return false;   return true; }  inline void cjlbrhmbjo(VI &xs) {   int i = (0);   while (i < (6)) {     cin >> xs[i];     ++i;   } }  
int main() {   int ret_val = 0;   cin.tie(0);   ios_base::sync_with_stdio(false);   int T;   cin >> T;   {     int t = (1);     while (t < (T + 1)) {       int N;       string col = "ROYGB";       VI xs(6);       cin >> N;        cjlbrhmbjo(xs);       VI orig = xs;        int mx = max(xs[0], max(xs[1 * 2], xs[2 * 2]));       int ok = (mx <= N - mx);        if (!ok)         cout << "Case #" << t << ": IMPOSSIBLE" << endl;       else {         string ans(N, '*');         int ix = -1;         for (int i = (0); i < (6); ++i)           if (xs[i] == mx)             ix = i;          for (int i = (0); i < (6); ++i)           if (i != ix && xs[i]) {             ans[0] = col[i];             xs[i]--;             ix = i;             break;           }         for (int i = 1; i < N; ++i) {           int mix = -1;           for (int j = (0); j < (6); ++j) {             if ((mix == -1 || xs[mix] < xs[j]) && j != ix)               mix = j;           }           ans[i] = col[mix];           xs[mix]--;           ix = mix;         }          if (!check(orig, ans)) {           {             int i = (0);             while (i < (6)) {               cout << orig[i] << " ";               ++i;             }           }           cout << endl;           cout << ans << endl;           return 1;         }          cout << "Case #" << t << ": " << ans << endl;       }       ++t;     }   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <limits> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const int Maxn = 3010;  int solve; using namespace std;  typedef long long ll; typedef long long LL; typedef pair<int, int> ii; typedef unsigned long long ull; typedef vector<vector<int>> vvi;   int p; struct Rec {   int a, b, l; };  int N; int num[10], ans[Maxn]; vector<int> t[1010]; 
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_10_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/kuzphi/outer_temp/kuzphi/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_10_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/kuzphi/A-small-practice.in",           "r", stdin);    cin >> solve;   while (solve--) {     cout << "Case #" << ++p << ": ";     cin >> N;     for (int i = 0; i < 6; i++)       cin >> num[i];      int Max = max(num[0], max(num[2], num[4]));     if (N - Max < Max) {       puts("IMPOSSIBLE");       continue;     }     for (int i = 1; i <= 1000; i++)       t[i].clear();     int x = 0, i = 1;     if (Max == num[0]) {       x = 0;       for (; i <= num[2]; i++)         t[(i - 1) % num[x] + 1].push_back(2);       for (; i <= N - num[x]; i++)         t[(i - 1) % num[x] + 1].push_back(4);      } else if (Max == num[2]) {       x = 2;       for (; i <= num[0]; i++)         t[(i - 1) % num[x] + 1].push_back(0);       for (; i <= N - num[x]; i++) {         t[(i - 1) % num[x] + 1].push_back(4);       }     } else {       x = 4;       for (; i <= num[0]; i++)         t[(i - 1) % num[x] + 1].push_back(0);       for (; i <= N - num[x]; i++)         t[(i - 1) % num[x] + 1].push_back(2);     }     ans[0] = 0;     {       int i = 1;       while (i <= num[x]) {         ans[++ans[0]] = x;         for (int get = 0; get < t[i].size(); get++)           ans[++ans[0]] = t[i][get];         i++;       }     }       for (int i = 1; i <= N; i++) {       if (ans[i] == 0)         cout << 'R';       if (ans[i] == 2)         cout << 'Y';       if (ans[i] == 4)         cout << 'B';     }     cout << endl;    }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <limits> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; const double pi = acos(-1.), eps = 1e-6; const int Maxn = 3010, Maxk = 5010, Mo = 1e9 + 7, oo = INT_MAX >> 2; const int sp[4][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}}; int T; using namespace std; 
typedef long double ld; typedef long long LL; typedef pair<int, int> ii; typedef unsigned long long ull;  const int mod = 1000000007; ifstream fin;   int n, m, k, q; struct Rec {   int a, b, l; };  int N, solve, O, second, G, B, V; int s[10], ans[Maxn]; vector<int> t[1010]; inline void twnrjviwew(int &get, int &x) {   x = 2;   for (; get <= s[0]; get++)     t[(get - 1) % s[x] + 1].push_back(0);   for (; get <= N - s[x]; get++)     t[(get - 1) % s[x] + 1].push_back(4); }  
int main() {   fin.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_10_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/kuzphi/A-small-practice.in");    fin >> T;   while (T--) {     printf("Case #%d: ", ++q);     fin >> N;     for (int get = 0; get < 6; get++) {       fin >> s[get];     }     int Max = max(s[0], max(s[2], s[4]));     if (N - Max < Max) {       puts("IMPOSSIBLE");       continue;     }     for (int get = 1; get <= 1000; get++)       t[get].clear();     int x = 0, get = 1;     if (Max == s[0]) {       x = 0;       for (; get <= s[2]; get++)         t[(get - 1) % s[x] + 1].push_back(2);       for (; get <= N - s[x]; get++)         t[(get - 1) % s[x] + 1].push_back(4);      } else {       if (Max == s[2])         twnrjviwew(get, x);       else {         x = 4;         for (; get <= s[0]; get++)           t[(get - 1) % s[x] + 1].push_back(0);         for (; get <= N - s[x]; get++)           t[(get - 1) % s[x] + 1].push_back(2);       }     }     ans[0] = 0;     for (int get = 1; get <= s[x]; get++) {       ans[++ans[0]] = x;       for (int j = 0; j < t[get].size(); j++)         ans[++ans[0]] = t[get][j];     }       for (int get = 1; get <= N; get++) {       if (ans[get] == 0)         printf("R");       if (ans[get] == 2)         printf("Y");       if (ans[get] == 4)         printf("B");     }     printf("\n");     }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <limits> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const int Maxn = 3010;  int solve; typedef pair<int, int> pii; typedef long double ld; typedef long long ll; typedef unsigned long long ull; typedef vector<int> VI; typedef set<int> si;   int cs; struct Rec {   int a, b, l; };  int N; int num[10], ans[Maxn]; vector<int> t[1010]; inline void exkfnawwvi(int &i, int &x) {   x = 2;   for (; i <= num[0]; i++)     t[(i - 1) % num[x] + 1].push_back(0);   for (; i <= N - num[x]; i++)     t[(i - 1) % num[x] + 1].push_back(4); }  inline void fkihfuqofb(int &i) {   if (ans[i] == 0)     cout << 'R';   if (ans[i] == 2)     cout << 'Y';   if (ans[i] == 4)     cout << 'B'; }  
int main() {   ios::sync_with_stdio(1);    cin >> solve;   for (; solve--;) {     cout << "Case #" << ++cs << ": ";     cin >> N;     for (int i = 0; i < 6; i++) {       cin >> num[i];     }     int Max = max(num[0], max(num[2], num[4]));     if (N - Max < Max) {       puts("IMPOSSIBLE");       continue;     }     for (int i = 1; i <= 1000; i++)       t[i].clear();     int x = 0, i = 1;     if (Max == num[0]) {       x = 0;       for (; i <= num[2]; i++)         t[(i - 1) % num[x] + 1].push_back(2);       for (; i <= N - num[x]; i++)         t[(i - 1) % num[x] + 1].push_back(4);      } else if (Max == num[2])       exkfnawwvi(i, x);     else {       x = 4;       for (; i <= num[0]; i++)         t[(i - 1) % num[x] + 1].push_back(0);       for (; i <= N - num[x]; i++)         t[(i - 1) % num[x] + 1].push_back(2);     }     ans[0] = 0;     for (int i = 1; i <= num[x]; i++) {       ans[++ans[0]] = x;       for (int j = 0; j < t[i].size(); j++)         ans[++ans[0]] = t[i][j];     }       for (int i = 1; i <= N; i++)       fkihfuqofb(i);     cout << endl;    }   return 0; }
#include <algorithm> #include <bitset> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iostream> #include <limits> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;
const double pi = acos(-1.), eps = 1e-6; const int Maxn = 3010, Maxk = 5010, Mo = 1e9 + 7, oo = INT_MAX >> 2; const int sp[4][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}}; int T; typedef long double ld; typedef long long LL; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef vector<int> vi; typedef long double LD;   int n, m, k, cs; struct Rec {   int a, b, l; };  int N, R, O, second, G, B, V; int num[10], ans[Maxn]; vector<int> w[1010]; 
int main() {   int ret_val = 0;   cin >> T;   while (T--) {     printf("Case #%d: ", ++cs);     cin >> N;     for (int i = 0; i < 6; i++) {       cin >> num[i];     }     int Max = max(num[0], max(num[2], num[4]));     if (N - Max < Max) {       puts("IMPOSSIBLE");       continue;     }     for (int i = 1; i <= 1000; i++)       w[i].clear();     int x = 0, i = 1;     if (Max == num[0]) {       x = 0;       for (; i <= num[2]; i++)         w[(i - 1) % num[x] + 1].push_back(2);       for (; i <= N - num[x]; i++)         w[(i - 1) % num[x] + 1].push_back(4);      } else if (Max == num[2]) {       x = 2;       for (; i <= num[0]; i++)         w[(i - 1) % num[x] + 1].push_back(0);       for (; i <= N - num[x]; i++)         w[(i - 1) % num[x] + 1].push_back(4);     } else {       x = 4;       for (; i <= num[0]; i++)         w[(i - 1) % num[x] + 1].push_back(0);       for (; i <= N - num[x]; i++)         w[(i - 1) % num[x] + 1].push_back(2);     }     ans[0] = 0;     for (int i = 1; i <= num[x]; i++) {       ans[++ans[0]] = x;       for (int j = 0; j < w[i].size(); j++)         ans[++ans[0]] = w[i][j];     }       for (int i = 1; i <= N; i++) {       if (ans[i] == 0)         cout << 'R';       if (ans[i] == 2)         cout << 'Y';       if (ans[i] == 4)         cout << 'B';     }     cout << endl;    }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <map> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
typedef set<int> si; typedef long double ld; typedef pair<int, int> ii; typedef pair<int, int> PII; typedef vector<int> VI; typedef long double LD;  ofstream fout;  ifstream fin;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  ll gcd(ll a, ll b) {   ll t;   while ((t = a % b) != 0) {     a = b;     b = t;   }   return b; }  ll fast_exp(ll N, ll n, ll j) {   if (n == 0) {     return 1;   }   ll t = fast_exp(N, n / 2, j);   if (n % 2 == 0)     return (t * t) % j;   else     return (((t * t) % j) * N) % j; }  bool is_set(int i, ll q) { return (q >> i) & 1; }  int count_bits(ll q) {   int ans = 0;   {     int i = 0;     while (i < 64) {       if (is_set(i, q))         ++ans;       ++i;     }   }   return ans; }  int first_bit(ll q) {   int ret_val = -1;   int i = 0;   while (i < 64)     if (is_set(i++, q))       return i - 1;   return ret_val; } 
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_11_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ibrahim5253/outer_temp/ibrahim5253/A-small-practice_transformation.out");    fin.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_11_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ibrahim5253/A-small-practice.in");    int t;   fin >> t;   {     int i = 1;     for (; i <= t;) {       int n, r, o, y, g, b, v;       fin >> n >> r >> o >> y >> g >> b >> v;       int ma = n / 2;       fout << "Case #" << i << ": ";       if (r > ma || y > ma || b > ma) {         fout << "IMPOSSIBLE\n";         ++i;         continue;       }       vector<pair<int, char>> V;       V.push_back(make_pair(r, 'R')), V.push_back(make_pair(y, 'Y')),           V.push_back(make_pair(b, 'B'));       sort(V.begin(), V.end());       char s[n + 1];       int p = 0;       int a = V[2].first;       while (a--) {         s[p] = V[2].second, p = (p + 2) % n, p = (p == 0 ? 1 : p);       }       a = V[1].first;       while (a--)         s[p] = V[1].second, p = (p + 2) % n, p = (p == 0 ? 1 : p);       a = V[0].first;       while (a--)         s[p] = V[0].second, p = (p + 2) % n, p = (p == 0 ? 1 : p);       for (int i = 0; i < n; ++i) {         fout << s[i];       }       fout << "\n";       ++i;     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
typedef long double LD; typedef pair<int, int> PII; typedef long long LL; typedef vector<int> VI;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  inline void pizvzbuobw(ll &a, ll &b, ll &t) {   a = b;   b = t; }  ll gcd(ll a, ll b) {   ll t;   while ((t = a % b) != 0)     pizvzbuobw(a, b, t);    return b; }  ll fast_exp(ll base, ll n, ll m) {   if (n == 0)     return 1;   ll t = fast_exp(base, n / 2, m);   if (n % 2 == 0)     return (t * t) % m;   else     return (((t * t) % m) * base) % m; }  bool is_set(int i, ll q) { return (q >> i) & 1; }  int count_bits(ll q) {   int ans = 0;   {     int i = 0;     while (i < 64) {       if (is_set(i, q))         ++ans;       ++i;     }   }   return ans; }  int first_bit(ll q) {   int ret_val = -1;   int i = 0;   while (i < 64)     if (is_set(i++, q))       return i - 1;   return ret_val; }  
int main() {   ios::sync_with_stdio(0);   int t;   cin >> t;   {     int i = 1;     while (i <= t) {       int n, r, o, y, g, b, v;       cin >> n >> r >> o >> y >> g >> b >> v;       int ma = n / 2;       cout << "Case #" << i << ": ";       if (r > ma || y > ma || b > ma) {         cout << "IMPOSSIBLE\n";         ++i;         continue;       }       vector<pair<int, char>> V;       V.push_back(make_pair(r, 'R')), V.push_back(make_pair(y, 'Y')),           V.push_back(make_pair(b, 'B'));       sort(V.begin(), V.end());       char s[n + 1];       int p = 0;       int a = V[2].first;       while (a--)         s[p] = V[2].second, p = (p + 2) % n, p = (p == 0 ? 1 : p);       a = V[1].first;       while (a--)         s[p] = V[1].second, p = (p + 2) % n, p = (p == 0 ? 1 : p);       a = V[0].first;       while (a--)         s[p] = V[0].second, p = (p + 2) % n, p = (p == 0 ? 1 : p);       {         int i = 0;         while (i < n) {           cout << s[i];           ++i;         }       }       cout << "\n";       ++i;     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std;
const int INF = 1000000000; ofstream fout;  typedef long double LD; typedef long long LL; typedef set<int> si;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  bool is_set(int i, ll mask) { return (mask >> i) & 1; }  int count_bits(ll mask) {   int ans = 0;   {     int i = 0;     while (i < 64) {       if (is_set(i, mask))         ++ans;       ++i;     }   }   return ans; }  int first_bit(ll mask) {   int ret_val = -1;   int i = 0;   while (i < 64)     if (is_set(i++, mask))       return i - 1;   return ret_val; }  
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_11_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/ibrahim5253/outer_temp/ibrahim5253/A-small-practice_transformation.out");    int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_11_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/ibrahim5253/A-small-practice.in",           "r", stdin);   int t;   scanf("%d ", &t);   for (int i = 1; i <= t; ++i) {     int n, r, o, y, g, b, v;     scanf("%d %d %d %d %d %d %d ", &n, &r, &o, &y, &g, &b, &v);     int ma = n / 2;     fout << "Case #" << i << ": ";     if (r > ma || y > ma || b > ma) {       fout << "IMPOSSIBLE\n";       continue;     }     vector<pair<int, char>> V;     V.push_back(make_pair(r, 'R')), V.push_back(make_pair(y, 'Y')),         V.push_back(make_pair(b, 'B'));     sort(V.begin(), V.end());     char s[n + 1];     int p = 0;     int a = V[2].first;     while (a--)       s[p] = V[2].second, p = (p + 2) % n, p = (p == 0 ? 1 : p);     a = V[1].first;     while (a--)       s[p] = V[1].second, p = (p + 2) % n, p = (p == 0 ? 1 : p);     a = V[0].first;     while (a--)       s[p] = V[0].second, p = (p + 2) % n, p = (p == 0 ? 1 : p);     for (int i = 0; i < n; ++i)       fout << s[i];     fout << "\n";   }   return ret_val; }
#include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstring> #include <fstream> #include <iostream> #include <iterator> #include <map> #include <queue> #include <set> #include <stack> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
const double EPS = 1e-9;  const long double PI = 3.1415926535897932384626433832795; const int MOD = 1000000007; const int INF = 1000000000; using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  ll fast_exp(ll q, ll n, ll m) {   if (n == 0)     return 1;   ll t = fast_exp(q, n / 2, m);   if (n % 2 == 0)     return (t * t) % m;   else     return (((t * t) % m) * q) % m; }  bool solve(int i, ll mask) { return (mask >> i) & 1; }  int count_bits(ll mask) {   int ans = 0;   for (int i = 0; i < 64; ++i)     if (solve(i, mask))       ++ans;   return ans; }  int first_bit(ll mask) {   int ret_val = -1;   int i = 0;   while (i < 64)     if (solve(i++, mask))       return i - 1;   return ret_val; }  
int main() {    int t;   cin >> t;    for (int i = 1; i <= t; ++i) {     int n, r, o, y, g, b, v;     cin >> n >> r >> o >> y >> g >> b >> v;     int ma = n / 2;     cout << "Case #" << i << ": ";     if (r > ma || y > ma || b > ma) {       cout << "IMPOSSIBLE\n";       continue;     }     vector<pair<int, char>> V;     V.push_back(make_pair(r, 'R')), V.push_back(make_pair(y, 'Y')),         V.push_back(make_pair(b, 'B'));     sort(V.begin(), V.end());     char s[n + 1];     int p = 0;     int a = V[2].first;     while (a--)       s[p] = V[2].second, p = (p + 2) % n, p = (p == 0 ? 1 : p);     a = V[1].first;     while (a--)       s[p] = V[1].second, p = (p + 2) % n, p = (p == 0 ? 1 : p);     a = V[0].first;     while (a--)       s[p] = V[0].second, p = (p + 2) % n, p = (p == 0 ? 1 : p);     for (int i = 0; i < n; ++i)       cout << s[i];     cout << "\n";   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <utility> #include <vector> using namespace std; 
const int INF = 1000000000; const int mod = 1000000007; const long double PI = 3.1415926535897932384626433832795; typedef vector<vector<int>> vvi; typedef long long ll; typedef pair<int, int> PII; typedef pair<int, int> pii; typedef unsigned long long ull; typedef vector<int> VI; typedef long double LD;  using LL = long long;  int x[6]; string s = "ROYGBV";  
int main() {   ios::sync_with_stdio(0);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_12_Usenix_RF_1.0_True_MCTS_Classic_True/Mucosolvan/jiian/A-small-practice.in",           "r", stdin);    int solve, v = 0;   cin >> solve;   for (; solve--;) {     int n;     cin >> n;     for (int get = 0; get < 6; get++)       cin >> x[get];     string t = "";     int flag = 0;     while (t.size() < n) {       int mx = 0, c = 0;       for (int get = 0; get < 6; get++) {         if (s[get] == t.back())           continue;         if (x[get] == mx && t.size())           if (s[get] == t[0])             mx = x[get], c = get;         if (x[get] > mx)           mx = x[get], c = get;       }       if (s[c] == t.back() || x[c] == 0) {         flag = 1;         break;       }       t.push_back(s[c]);       x[c]--;     }      if (t.size() > 1 && t[0] == t.back())       flag = 1;     printf("Case #%d: ", ++v);     if (flag)       puts("IMPOSSIBLE");     else       printf("%s\n", t.c_str());   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <list> #include <map> #include <numeric> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const int MOD = 1000000007; typedef long double ld; typedef unsigned long long ull; typedef vector<int> vi; typedef set<int> si; typedef vector<vector<int>> vvi;  using LL = long long;  int a[6]; string s = "ROYGBV";  
int main() {   int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_12_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/jiian/A-small-practice.in",           "r", stdin);    int T, cas = 0;   scanf("%d ", &T);   while (T--) {     int n;     scanf("%d ", &n);     int i;     for (i = 0; i < 6; i++)       scanf("%d ", &a[i]);     string ans = "";     int flag = 0;     while (ans.size() < n) {       int mx = 0, c = 0;       int i;       for (i = 0; i < 6; i++) {         if (s[i] == ans.back())           continue;         if (a[i] == mx && ans.size() && s[i] == ans[0])           mx = a[i], c = i;         if (a[i] > mx)           mx = a[i], c = i;       }       if (s[c] == ans.back() || a[c] == 0) {         flag = 1;         break;       }       ans.push_back(s[c]);       a[c]--;     }      if (ans.size() > 1 && ans[0] == ans.back())       flag = 1;     cout << "Case #" << ++cas << ": ";     if (flag)       puts("IMPOSSIBLE");     else       cout << ans << "\n";   }   return ret_val; }
#include <bits/stdc++.h> #include <iomanip> #include <iostream> #include <stdio.h> using namespace std; 
using LL = long long;  int t[6]; string s = "ROYGBV";  
int main() {    int solve, y = 0;   cin >> solve;   for (; solve--;) {     int get;     cin >> get;     for (int i = 0; i < 6; i++)       cin >> t[i];     string ans = "";     int flag = 0;     for (; ans.size() < get;) {       int mx = 0, c = 0;        for (int i = 0; i < 6; i++) {         if (s[i] == ans.back())           continue;         if (t[i] == mx && ans.size() && s[i] == ans[0]) {           mx = t[i], c = i;         }         if (t[i] > mx)           mx = t[i], c = i;       }       if (t[c] == 0) {         flag = 1;         break;       } else {         if (s[c] == ans.back()) {           flag = 1;           break;         }       }       ans.push_back(s[c]);       t[c]--;     }      if (ans.size() > 1 && ans[0] == ans.back())       flag = 1;     cout << "Case #" << ++y << ": ";     if (flag)       puts("IMPOSSIBLE");     else       cout << ans << "\n";   }   return 0; }
#include <bits/stdc++.h> using namespace std; 
using LL = long long;  int a[6]; string s = "ROYGBV";  
int main() {   int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_12_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/jiian/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_12_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/jiian/outer_temp/jiian/A-small-practice_transformation.out",           "w", stdout);   int tt, cas = 0;   cin >> tt;   while (tt--) {     int n;     cin >> n;     for (int i = 0; i < 6; i++)       cin >> a[i];     string ans = "";     int flag = 0;     while (ans.size() < n) {       int mx = 0, c = 0;       {         int i = 0;         while (i < 6) {           if (s[i] == ans.back()) {             i++;             continue;           }           if (a[i] == mx && ans.size() && s[i] == ans[0])             mx = a[i], c = i;           if (a[i] > mx)             mx = a[i], c = i;           i++;         }       }       if (s[c] == ans.back() || a[c] == 0) {         flag = 1;         break;       }       ans.push_back(s[c]);       a[c]--;     }      if (ans.size() > 1)       if (ans[0] == ans.back())         flag = 1;     printf("Case #%d: ", ++cas);     if (flag)       puts("IMPOSSIBLE");     else       printf("%s\n", ans.c_str());   }   return ret_val; }
#include <algorithm> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <numeric> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;
typedef long long LL; typedef pair<int, int> PII; typedef unsigned long long ull; typedef vector<int> VI; typedef long double LD; typedef vector<vector<int>> vvi;   int N, R, O, Y, G, B, V; int s[2000]; inline void vdcqsfwcmh() { puts("IMPOSSIBLE"); }  
int main(void) {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_13_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/iPeter/A-small-practice.in",           "r", stdin);    int ret_val = 0;   int t;   scanf("%d", &t);   for (int r = 1; r <= t; r++) {     scanf("%d%d%d%d%d%d%d", &N, &R, &O, &Y, &G, &B, &V);      cout << "Case #" << r << ": ";      if (O > B || G > R || V > Y) {       puts("IMPOSSIBLE");       continue;     }      if (O == B && O > 0) {       if (O + B < N) {         puts("IMPOSSIBLE");       } else {         for (; O > 0; --O)           cout << "OB";         puts("");       }       continue;     }     if (G == R && G > 0) {       if (G + R < N) {         puts("IMPOSSIBLE");       } else {         for (; G > 0; --G)           cout << "RG";         puts("");       }       continue;     }     if (Y == V)       if (V > 0) {         if (Y + V < N)           vdcqsfwcmh();         else {           for (; V > 0; --V)             cout << "YV";           puts("");         }         continue;       }      B -= O;     R -= G;     Y -= V;     int m = B + R + Y;     if (B > R + Y || R > B + Y || Y > B + R) {       puts("IMPOSSIBLE");       continue;     }     memset(s, -1, sizeof(s));      int maxc = 0, c = R, c2 = Y, mc2 = 1, mc3 = 2;     if (B > R && B > Y)       maxc = 2, c = B, mc3 = 0;     if (Y > B && Y > R)       maxc = 1, c = Y, c2 = R, mc2 = 0;        for (int i = 0; i < c; i++) {       s[i * 2] = maxc;     }     for (int i = m - 1 - (m % 2), j = 0; j < c2; i -= 2, ++j) {       s[i] = mc2;     }     for (int i = 0; i < m; i++) {       if (s[i] < 0)         s[i] = mc3;     }      for (int i = 0; i < m; i++) {       if (s[i] == 0) {         cout << "R";         for (; G > 0; --G)           cout << "GR";              } else if (s[i] == 1) {         cout << "Y";         for (; V > 0; --V)           cout << "VY";               } else {         cout << "B";         for (; O > 0; --O)           cout << "OB";                }     }     puts("");    }   return ret_val; }
#include <algorithm> #include <cstdio> #include <cstring> #include <iostream> using namespace std;  
int N, R, O, Y, G, B, V; int s[2000]; inline void iyvjuhdqcw() {   printf("Y");   for (; V > 0; --V)     printf("VY");   }  
int main(void) {   int t;   cin >> t;   for (int tt = 1; tt <= t; tt++) {     cin >> N >> R >> O >> Y >> G >> B >> V;      printf("Case #%d: ", tt);      if (O > B || G > R || V > Y) {       puts("IMPOSSIBLE");       continue;     }      if (O == B && O > 0) {       if (O + B < N) {         puts("IMPOSSIBLE");       } else {         for (; O > 0; --O)           printf("OB");         puts("");       }       continue;     }     if (G == R && G > 0) {       if (G + R < N) {         puts("IMPOSSIBLE");       } else {         for (; G > 0; --G)           printf("RG");         puts("");       }       continue;     }     if (Y == V && V > 0) {       if (Y + V < N) {         puts("IMPOSSIBLE");       } else {         for (; V > 0; --V)           printf("YV");         puts("");       }       continue;     }      B -= O;     R -= G;     Y -= V;     int solve = B + R + Y;     if (B > R + Y || R > B + Y || Y > B + R) {       puts("IMPOSSIBLE");       continue;     }     memset(s, -1, sizeof(s));      int maxc = 0, c = R, c2 = Y, mc2 = 1, mc3 = 2;     if (B > R && B > Y)       maxc = 2, c = B, mc3 = 0;     if (Y > B && Y > R)       maxc = 1, c = Y, c2 = R, mc2 = 0;        for (int i = 0; i < c; i++) {       s[i * 2] = maxc;     }     for (int i = solve - 1 - (solve % 2), j = 0; j < c2; i -= 2, ++j) {       s[i] = mc2;     }     for (int i = 0; i < solve; i++) {       if (s[i] < 0)         s[i] = mc3;     }      for (int i = 0; i < solve; i++) {       if (s[i] == 0) {         printf("R");         for (; G > 0; --G)           printf("GR");               } else if (s[i] == 1)         iyvjuhdqcw();       else {         printf("B");         for (; O > 0; --O)           printf("OB");                }     }     puts("");       }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> using namespace std;  
int N, R, O, Y, G, B, V; int s[2000]; 
int main(void) {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_13_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/iPeter/outer_temp/iPeter/A-small-practice_transformation.out",           "w", stdout);    int ret_val = 0;   int ans;   scanf("%d", &ans);   for (int tt = 1; tt <= ans; tt++) {     scanf("%d%d%d%d%d%d%d", &N, &R, &O, &Y, &G, &B, &V);      printf("Case #%d: ", tt);      if (O > B || G > R || V > Y) {       puts("IMPOSSIBLE");       continue;     }      if (O == B && O > 0) {       if (O + B < N) {         puts("IMPOSSIBLE");       } else {         for (; O > 0; --O)           printf("OB");         puts("");       }       continue;     }     if (G == R && G > 0) {       if (G + R < N) {         puts("IMPOSSIBLE");       } else {         for (; G > 0; --G)           printf("RG");         puts("");       }       continue;     }     if (Y == V && V > 0) {       if (Y + V < N) {         puts("IMPOSSIBLE");       } else {         for (; V > 0; --V)           printf("YV");         puts("");       }       continue;     }      B -= O;     R -= G;     Y -= V;     int m = B + R + Y;     if (B > R + Y || R > B + Y || Y > B + R) {       puts("IMPOSSIBLE");       continue;     }     memset(s, -1, sizeof(s));      int maxc = 0, c = R, c2 = Y, mc2 = 1, mc3 = 2;     if (B > R && B > Y)       maxc = 2, c = B, mc3 = 0;     if (Y > B && Y > R)       maxc = 1, c = Y, c2 = R, mc2 = 0;           for (int i = 0; i < c; i++) {       s[i * 2] = maxc;     }     for (int i = m - 1 - (m % 2), j = 0; j < c2; i -= 2, ++j) {       s[i] = mc2;     }     for (int i = 0; i < m; i++) {       if (s[i] < 0)         s[i] = mc3;     }      for (int i = 0; i < m; i++) {       if (s[i] == 0) {         printf("R");         for (; G > 0; --G)           printf("GR");               } else if (s[i] == 1) {         printf("Y");         for (; V > 0; --V)           printf("VY");                } else {         printf("B");         for (; O > 0; --O)           printf("OB");                }     }     puts("");     }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <fstream> #include <iomanip> #include <iostream> #include <utility> using namespace std; 
ifstream fin;  typedef pair<int, int> pii; typedef double dbl;   int tc, R, O, Y, G, B, V; int s[2000]; 
int main(void) {   fin.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_12_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/iPeter/A-small-practice.in");    int ret_val = 0;   int t;   fin >> t;   for (int tt = 1; tt <= t; tt++) {     fin >> tc >> R >> O >> Y >> G >> B >> V;      cout << "Case #" << tt << ": ";      if (O > B || G > R || V > Y) {       puts("IMPOSSIBLE");       continue;     }      if (O == B && O > 0) {       if (O + B < tc) {         puts("IMPOSSIBLE");       } else {         for (; O > 0; --O)           cout << "OB";         puts("");       }       continue;     }     if (G == R && G > 0) {       if (G + R < tc) {         puts("IMPOSSIBLE");       } else {         for (; G > 0; --G)           cout << "RG";         puts("");       }       continue;     }     if (Y == V && V > 0) {       if (Y + V < tc) {         puts("IMPOSSIBLE");       } else {         for (; V > 0; --V)           cout << "YV";         puts("");       }       continue;     }      B -= O;     R -= G;     Y -= V;     int m = B + R + Y;     if (B > R + Y || R > B + Y || Y > B + R) {       puts("IMPOSSIBLE");       continue;     }     memset(s, -1, sizeof(s));      int maxc = 0, c = R, c2 = Y, mc2 = 1, mc3 = 2;     if (B > R && B > Y)       maxc = 2, c = B, mc3 = 0;     if (Y > B && Y > R)       maxc = 1, c = Y, c2 = R, mc2 = 0;        for (int i = 0; i < c; i++) {       s[i * 2] = maxc;     }     for (int i = m - 1 - (m % 2), j = 0; j < c2; i -= 2, ++j) {       s[i] = mc2;     }     for (int i = 0; i < m; i++) {       if (s[i] < 0)         s[i] = mc3;     }      for (int i = 0; i < m; i++) {       if (s[i] == 0) {         cout << "R";         for (; G > 0; --G)           cout << "GR";                } else if (s[i] == 1) {         cout << "Y";         for (; V > 0; --V)           cout << "VY";                } else {         cout << "B";         for (; O > 0; --O)           cout << "OB";              }     }     puts("");     }   return ret_val; }
#include <bits/stdc++.h> #include <cctype> #include <complex> #include <cstring> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <unordered_map> #include <utility>  using namespace std; 
long long solve(long long a, long long b) {   if (b == 0)     return a;   return solve(b, a % b); }  int n, red, orange, yellow, green, blue, violet; vector<string> arr[5];  string yolo(int x) {   string z = arr[x].back();   arr[x].pop_back();   return z; }  string check(int x) {    int y = -1, z = -1;   for (int i = 1; i <= 3; i++) {     if (i == x)       continue;     if (y == -1)       y = i;     else       z = i;   }    int xsz = (int)arr[x].size(), ysz = (int)arr[y].size(),       zsz = (int)arr[z].size();   if (ysz + zsz < xsz)     return "";   if (ysz < zsz) {     swap(y, z);     swap(ysz, zsz);   }      if (ysz >= xsz) {     int rem = ysz - xsz;     if (rem > zsz)       return "";     zsz -= rem;     string ans = "";     for (int i = 0; i < xsz; i++) {       ans += yolo(x) + yolo(y);       if (i == 0) {         for (; rem--;)           ans += yolo(z) + yolo(y);       }       if (i < zsz)         ans += yolo(z);     }     return ans;   } else {     int rem = zsz - (xsz - ysz);     if (rem > ysz)       return "";     string ans = "";     int i;     for (i = 0; i < xsz; i++) {       ans += yolo(x);       if (i < ysz) {         ans += yolo(y);         if (i < rem)           ans += yolo(z);       } else {         ans += yolo(z);       }     }     return ans;   }   return ""; }  inline void ohxqmrohhf() {   yellow -= violet + 1;   string str = "Y";   while (violet--) {     str += "VY";   }   arr[3].push_back(str); }  
int main() {    cin.tie(0);    int t, x = 1;   cin >> t;    while (t--) {      cin >> n >> red >> orange >> yellow >> green >> blue >> violet;      orange = green = violet = 0;      if (orange > 0)       if (blue < orange + 1) {         printf("Case #%d: IMPOSSIBLE\n", x++);         continue;       }      if (green > 0 && red < green + 1) {       printf("Case #%d: IMPOSSIBLE\n", x++);       continue;     }      if (violet > 0 && yellow < violet + 1) {       printf("Case #%d: IMPOSSIBLE\n", x++);       continue;     }      arr[1].clear();     arr[2].clear();     arr[3].clear();      if (orange > 0) {       blue -= orange + 1;       string str = "B";       while (orange--)         str += "OB";       arr[1].push_back(str);     }      if (green > 0) {       red -= green + 1;       string str = "R";       while (green--)         str += "GR";       arr[2].push_back(str);     }      if (violet > 0)       ohxqmrohhf();      while (blue--)       arr[1].push_back("B");     while (red--)       arr[2].push_back("R");     while (yellow--)       arr[3].push_back("Y");      string ans = "";     ans = check(1);      if ((int)ans.length() == n) {       printf("Case #%d: %s\n", x++, ans.c_str());       continue;     }      ans = check(2);     if ((int)ans.length() == n) {       printf("Case #%d: %s\n", x++, ans.c_str());       continue;     }      ans = check(3);     if ((int)ans.length() == n) {       printf("Case #%d: %s\n", x++, ans.c_str());       continue;     }      ans = "";     if ((int)ans.length() != n) {       printf("Case #%d: IMPOSSIBLE\n", x++);       continue;     }   }    return 0; }
#include <bits/stdc++.h>  using namespace std;  
typedef pair<int, int> ii; typedef pair<int, ii> iii;  long long pwr(long long base, long long p, long long mod = (1000000007LL)) {   long long ans = 1;   while (p) {     if (p & 1)       ans = (ans * base) % mod;     base = (base * base) % mod;     p /= 2;   }   return ans; }  long long gcd(long long a, long long b) {   if (b == 0)     return a;   return gcd(b, a % b); }  int n, red, orange, yellow, green, blue, violet; vector<string> arr[5];  string yolo(int x) {   string z = arr[x].back();   arr[x].pop_back();   return z; }  string check(int x) {    int y = -1, z = -1;   for (int i = 1; i <= 3; i++) {     if (i == x)       continue;     if (y == -1)       y = i;     else       z = i;   }    int xsz = (int)arr[x].size(), ysz = (int)arr[y].size(),       zsz = (int)arr[z].size();   if (ysz + zsz < xsz)     return "";   if (ysz < zsz) {     swap(y, z);     swap(ysz, zsz);   }      if (ysz >= xsz) {     int rem = ysz - xsz;     if (rem > zsz)       return "";     zsz -= rem;     string ans = "";     for (int i = 0; i < xsz; i++) {       ans += yolo(x) + yolo(y);       if (i == 0) {         while (rem--) {           ans += yolo(z) + yolo(y);         }       }       if (i < zsz)         ans += yolo(z);     }     return ans;   } else {     int rem = zsz - (xsz - ysz);     if (rem > ysz)       return "";     string ans = "";     for (int i = 0; i < xsz; i++) {       ans += yolo(x);       if (i < ysz) {         ans += yolo(y);         if (i < rem)           ans += yolo(z);       } else {         ans += yolo(z);       }     }     return ans;   }   return ""; }  
int main() {   int ret_val = 0;   ios_base::sync_with_stdio(0);   cin.tie(0);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_14_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/satyaki3794/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_14_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/satyaki3794/outer_temp/satyaki3794/A-small-practice_transformation.out",           "w", stdout);   int t, x = 1;   cin >> t;   while (t--) {      cin >> n >> red >> orange >> yellow >> green >> blue >> violet;      orange = green = violet = 0;      if (orange > 0 && blue < orange + 1) {       cout << "Case #" << x++ << ": IMPOSSIBLE" << endl;       continue;     }      if (green > 0 && red < green + 1) {       cout << "Case #" << x++ << ": IMPOSSIBLE" << endl;       continue;     }      if (violet > 0 && yellow < violet + 1) {       cout << "Case #" << x++ << ": IMPOSSIBLE" << endl;       continue;     }      arr[1].clear();     arr[2].clear();     arr[3].clear();      if (orange > 0) {       blue -= orange + 1;       string str = "B";       while (orange--)         str += "OB";       arr[1].push_back(str);     }      if (green > 0) {       red -= green + 1;       string str = "R";       while (green--)         str += "GR";       arr[2].push_back(str);     }      if (violet > 0) {       yellow -= violet + 1;       string str = "Y";       while (violet--)         str += "VY";       arr[3].push_back(str);     }      while (blue--)       arr[1].push_back("B");     while (red--)       arr[2].push_back("R");     while (yellow--)       arr[3].push_back("Y");      string ans = "";     ans = check(1);      if ((int)ans.length() == n) {       cout << "Case #" << x++ << ": " << ans << endl;       continue;     }      ans = check(2);     if ((int)ans.length() == n) {       cout << "Case #" << x++ << ": " << ans << endl;       continue;     }      ans = check(3);     if ((int)ans.length() == n) {       cout << "Case #" << x++ << ": " << ans << endl;       continue;     }      ans = "";     if ((int)ans.length() != n) {       cout << "Case #" << x++ << ": IMPOSSIBLE" << endl;       continue;     }   }   return ret_val; }
#include <bits/stdc++.h> #include <fstream>  using namespace std; 
ofstream fout;  typedef pair<int, int> pii; typedef pair<int, pii> iii;  long long pwr(long long base, long long tc, long long mod = (1000000007LL)) {   long long ans = 1;   for (; tc;) {     if (tc & 1) {       ans = (ans * base) % mod;     }     base = (base * base) % mod;     tc /= 2;   }   return ans; }  long long gcd(long long a, long long b) {   if (b == 0)     return a;   return gcd(b, a % b); }  int n, red, orange, yellow, green, blue, violet; vector<string> m[5];  string yolo(int x) {   string z = m[x].back();   m[x].pop_back();   return z; }  string check(int x) {    int y = -1, z = -1;   {     int i = 1;     while (i <= 3) {       if (i == x) {         i++;         continue;       }       if (y == -1)         y = i;       else         z = i;       i++;     }   }    int xsz = (int)m[x].size(), ysz = (int)m[y].size(), zsz = (int)m[z].size();   if (ysz + zsz < xsz)     return "";   if (ysz < zsz) {     swap(y, z);     swap(ysz, zsz);   }      if (ysz >= xsz) {     int rem = ysz - xsz;     if (rem > zsz)       return "";     zsz -= rem;     string ans = "";     for (int i = 0; i < xsz; i++) {       ans += yolo(x) + yolo(y);       if (i == 0) {         while (rem--)           ans += yolo(z) + yolo(y);       }       if (i < zsz)         ans += yolo(z);     }     return ans;   } else {     int rem = zsz - (xsz - ysz);     if (rem > ysz)       return "";     string ans = "";     for (int i = 0; i < xsz; i++) {       ans += yolo(x);       if (i < ysz) {         ans += yolo(y);         if (i < rem)           ans += yolo(z);       } else         ans += yolo(z);     }     return ans;   }   return ""; }  inline void rurwvskoku() {   red -= green + 1;   string str = "R";   while (green--)     str += "GR";   m[2].push_back(str); }  
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_13_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/satyaki3794/outer_temp/satyaki3794/A-small-practice_transformation.out");    int ret_val = 0;    cin.tie(0);    int t, x = 1;   cin >> t;   while (t--) {      cin >> n >> red >> orange >> yellow >> green >> blue >> violet;      orange = green = violet = 0;      if (orange > 0 && blue < orange + 1) {       fout << "Case #" << x++ << ": IMPOSSIBLE" << endl;       continue;     }      if (green > 0 && red < green + 1) {       fout << "Case #" << x++ << ": IMPOSSIBLE" << endl;       continue;     }      if (violet > 0 && yellow < violet + 1) {       fout << "Case #" << x++ << ": IMPOSSIBLE" << endl;       continue;     }      m[1].clear();     m[2].clear();     m[3].clear();      if (orange > 0) {       blue -= orange + 1;       string str = "B";       while (orange--)         str += "OB";       m[1].push_back(str);     }      if (green > 0)       rurwvskoku();      if (violet > 0) {       yellow -= violet + 1;       string str = "Y";       while (violet--)         str += "VY";       m[3].push_back(str);     }      while (blue--)       m[1].push_back("B");     while (red--)       m[2].push_back("R");     while (yellow--)       m[3].push_back("Y");      string ans = "";     ans = check(1);      if ((int)ans.length() == n) {       fout << "Case #" << x++ << ": " << ans << endl;       continue;     }      ans = check(2);     if ((int)ans.length() == n) {       fout << "Case #" << x++ << ": " << ans << endl;       continue;     }      ans = check(3);     if ((int)ans.length() == n) {       fout << "Case #" << x++ << ": " << ans << endl;       continue;     }      ans = "";     if ((int)ans.length() != n) {       fout << "Case #" << x++ << ": IMPOSSIBLE" << endl;       continue;     }   }   return ret_val; }
#include <bits/stdc++.h> #include <stdio.h>  using namespace std; 
typedef long long ll; typedef pair<int, int> ii; typedef pair<int, ii> iii;  ll pwr(ll base, ll p, ll mod = (1000000007LL)) {   ll ans = 1;   while (p) {     if (p & 1)       ans = (ans * base) % mod;     base = (base * base) % mod;     p /= 2;   }   return ans; }  int n, red, orange, yellow, green, blue, violet; vector<string> arr[5];  string yolo(int x) {   string z = arr[x].back();   arr[x].pop_back();   return z; }  string check(int x) {    int y = -1, z = -1;   for (int i = 1; i <= 3; i++) {     if (i == x)       continue;     if (y == -1)       y = i;     else       z = i;   }    int xsz = (int)arr[x].size(), ysz = (int)arr[y].size(),       zsz = (int)arr[z].size();   if (ysz + zsz < xsz)     return "";   if (ysz < zsz) {     swap(y, z);     swap(ysz, zsz);   }      if (ysz >= xsz) {     int rem = ysz - xsz;     if (rem > zsz)       return "";     zsz -= rem;     string ans = "";     for (int i = 0; i < xsz; i++) {       ans += yolo(x) + yolo(y);       if (i == 0) {         while (rem--) {           ans += yolo(z) + yolo(y);         }       }       if (i < zsz)         ans += yolo(z);     }     return ans;   } else {     int rem = zsz - (xsz - ysz);     if (rem > ysz)       return "";     string ans = "";     for (int i = 0; i < xsz; i++) {       ans += yolo(x);       if (i < ysz) {         ans += yolo(y);         if (i < rem)           ans += yolo(z);       } else {         ans += yolo(z);       }     }     return ans;   }   return ""; }  
int main() {   int ret_val = 0;   ios_base::sync_with_stdio(0);   cin.tie(0);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_13_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/satyaki3794/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_13_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/satyaki3794/outer_temp/satyaki3794/A-small-practice_transformation.out",           "w", stdout);   int t, x = 1;   cin >> t;   while (t--) {      cin >> n >> red >> orange >> yellow >> green >> blue >> violet;      orange = green = violet = 0;      if (orange > 0 && blue < orange + 1) {       printf("Case #%d: IMPOSSIBLE\n", x++);       continue;     }      if (green > 0 && red < green + 1) {       printf("Case #%d: IMPOSSIBLE\n", x++);       continue;     }      if (violet > 0 && yellow < violet + 1) {       printf("Case #%d: IMPOSSIBLE\n", x++);       continue;     }      arr[1].clear();     arr[2].clear();     arr[3].clear();      if (orange > 0) {       blue -= orange + 1;       string str = "B";       while (orange--)         str += "OB";       arr[1].push_back(str);     }      if (green > 0) {       red -= green + 1;       string str = "R";       while (green--)         str += "GR";       arr[2].push_back(str);     }      if (violet > 0) {       yellow -= violet + 1;       string str = "Y";       while (violet--)         str += "VY";       arr[3].push_back(str);     }      while (blue--)       arr[1].push_back("B");     while (red--)       arr[2].push_back("R");     while (yellow--)       arr[3].push_back("Y");      string ans = "";     ans = check(1);      if ((int)ans.length() == n) {       printf("Case #%d: %s\n", x++, ans.c_str());       continue;     }      ans = check(2);     if ((int)ans.length() == n) {       printf("Case #%d: %s\n", x++, ans.c_str());       continue;     }      ans = check(3);     if ((int)ans.length() == n) {       printf("Case #%d: %s\n", x++, ans.c_str());       continue;     }      ans = "";     if ((int)ans.length() != n) {       printf("Case #%d: IMPOSSIBLE\n", x++);       continue;     }   }   return ret_val; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> using namespace std;  
bool comp(pair<int, char> &l, pair<int, char> &r) { return l.first < r.first; }  
int main(int tt, char **argv) {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_15_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out", "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_15_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/gultai4ukr/A-small-practice.in",           "r", stdin);    int ret_val = 0;    int cc;   scanf("%d ", &cc);   for (int testcase = 0; testcase < cc; ++testcase) {     int n, r, o, y, g, b, v;     scanf("%d %d %d %d %d %d %d ", &n, &r, &o, &y, &g, &b, &v);     int m = max(r, max(y, b));     cout << "Case #" << testcase + 1 << ": ";      pair<int, char> col[] = {{r, 'R'}, {y, 'Y'}, {b, 'B'}};     sort(col, &col[3], comp);      if (r + y + b == 1) {       for (int i = 0; i < 3; ++i) {         if (col[i].first) {           cout << col[i].second << endl;         }       }       continue;     }      if (m > (r + y + b) / 2.0) {       cout << "IMPOSSIBLE" << endl;       continue;     }      while (col[1].first > col[0].first) {       cout << col[2].second << col[1].second;       col[2].first--;       col[1].first--;     }     int odd = 0;     while (col[2].first) {       cout << col[2].second << col[odd % 2].second;       col[2].first--;       col[odd % 2].first--;       odd++;     }     while (col[odd % 2].first) {       cout << col[odd % 2].second;       col[odd % 2].first--;       odd++;     }     cout << endl;   }    return ret_val; }
#include <bits/stdc++.h> #include <iostream> #include <utility> using namespace std; 
typedef double dbl; typedef pair<int, int> pii;  bool comp(pair<int, char> &l, pair<int, char> &r) { return l.first < r.first; }  inline void wubfoiyqdk(std::ofstream &fout, pair<int, char> col[3]) {   fout << col[2].second << col[1].second;   col[2].first--;   col[1].first--; }  inline void wjgpmokamg(std::ofstream &fout, pair<int, char> col[3], int &i) {   if (col[i].first)     fout << col[i].second << endl; }  inline void yzusosxvhk(std::ofstream &fout, pair<int, char> col[3], int &odd) {   fout << col[odd % 2].second;   col[odd % 2].first--;   odd++; }  
int main(int drri_Var, char **tc) {   int ret_val = 0;    ofstream fout("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_14_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out");   int t;   cin >> t;   int testcase;   {     testcase = 0;     while (testcase < t) {       int n, r, o, y, g, b, mjli_Var;       cin >> n >> r >> o >> y >> g >> b >> mjli_Var;       int m = max(r, max(y, b));       fout << "Case #" << testcase + 1 << ": ";        pair<int, char> col[] = {{r, 'R'}, {y, 'Y'}, {b, 'B'}};       sort(col, &col[3], comp);        if (r + y + b == 1) {         for (int i = 0; i < 3; ++i)           wjgpmokamg(fout, col, i);         ++testcase;         continue;       }        if (m > (r + y + b) / 2.0) {         fout << "IMPOSSIBLE" << endl;         ++testcase;         continue;       }        while (col[1].first > col[0].first)         wubfoiyqdk(fout, col);       int odd = 0;       for (; col[2].first;) {         fout << col[2].second << col[odd % 2].second;         col[2].first--;         col[odd % 2].first--;         odd++;       }       while (col[odd % 2].first) {         yzusosxvhk(fout, col, odd);       }       fout << endl;       ++testcase;     }   }    fout.close();   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cctype> #include <complex> #include <cstdio> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <map> #include <math.h> #include <numeric> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility> #include <vector> using namespace std; 
const int INF = 1000000000;  typedef unsigned long long ull; typedef long long ll; typedef set<int> si; typedef long double ld; typedef pair<int, int> PII; typedef pair<int, int> pii; typedef vector<int> vi; typedef long double LD; typedef vector<vector<int>> vvi;  bool comp(pair<int, char> &l, pair<int, char> &r) { return l.first < r.first; }  
int main(int argc, char **argv) {   ios::sync_with_stdio(false);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_14_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out",           "w", stdout);    int ret_val = 0;    ifstream a("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_14_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/gultai4ukr/A-small-practice.in");    int get;   a >> get;   for (int testcase = 0; testcase < get; ++testcase) {     int n, r, o, y, g, b, v;     a >> n >> r >> o >> y >> g >> b >> v;     int m = max(r, max(y, b));     printf("Case #%d: ", testcase + 1);      pair<int, char> col[] = {{r, 'R'}, {y, 'Y'}, {b, 'B'}};     sort(col, &col[3], comp);      if (r + y + b == 1) {       for (int i = 0; i < 3; ++i) {         if (col[i].first) {           printf("%c\n", col[i].second);         }       }       continue;     }      if (m > (r + y + b) / 2.0) {       printf("IMPOSSIBLE\n");       continue;     }      while (col[1].first > col[0].first) {       printf("%c%c", col[2].second, col[1].second);       col[2].first--;       col[1].first--;     }     int odd = 0;     while (col[2].first) {       printf("%c%c", col[2].second, col[odd % 2].second);       col[2].first--;       col[odd % 2].first--;       odd++;     }     while (col[odd % 2].first) {       printf("%c", col[odd % 2].second);       col[odd % 2].first--;       odd++;     }     printf("\n");   }   a.close();    return ret_val; }
#include <bits/stdc++.h> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdlib> #include <cstring> #include <deque> #include <functional> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <stdio.h> #include <string> #include <vector> using namespace std; 
bool comp(pair<int, char> &l, pair<int, char> &r) { return l.first < r.first; }  inline void eaiazdvhsg(std::ofstream &tc, pair<int, char> col[3], int &i) {   tc << col[i].second << endl; }  inline void htjmkwkwvt(std::ofstream &tc, pair<int, char> col[3]) {   tc << col[2].second << col[1].second;   col[2].first--;   col[1].first--; }  inline void idtxtztymr(std::ofstream &tc, pair<int, char> col[3]) {   int i;   for (i = 0; i < 3;) {     if (col[i].first) {       eaiazdvhsg(tc, col, i);     }     ++i;   } }  inline void bcyypvxaql(std::ofstream &tc, pair<int, char> col[3], int &odd) {   tc << col[2].second << col[odd % 2].second;   col[2].first--;   col[odd % 2].first--;   odd++; }  inline void omfjihhsfc(std::ofstream &tc, pair<int, char> col[3], int &odd) {   tc << col[odd % 2].second;   col[odd % 2].first--;   odd++; }  
int main(int N, char **argv) {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_14_Usenix_RF_1.0_True_MCTS_Classic_True/try/gultai4ukr/A-small-practice.in",           "r", stdin);    ofstream tc("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_14_Usenix_RF_1.0_True_MCTS_Classic_True/try/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out");    int get;   scanf("%d ", &get);   int testcase;   for (testcase = 0; testcase < get; ++testcase) {     int n, r, o, y, g, b, v;     scanf("%d %d %d %d %d %d %d ", &n, &r, &o, &y, &g, &b, &v);     int m = max(r, max(y, b));     tc << "Case #" << testcase + 1 << ": ";      pair<int, char> col[] = {{r, 'R'}, {y, 'Y'}, {b, 'B'}};     sort(col, &col[3], comp);      if (r + y + b == 1) {       idtxtztymr(tc, col);       continue;     }      if (m > (r + y + b) / 2.0) {       tc << "IMPOSSIBLE" << endl;       continue;     }      while (col[1].first > col[0].first)       htjmkwkwvt(tc, col);     int odd = 0;     while (col[2].first)       bcyypvxaql(tc, col, odd);     while (col[odd % 2].first)       omfjihhsfc(tc, col, odd);     tc << endl;   }    tc.close();   return 0; }
#include <bits/stdc++.h> #include <fstream> #include <iostream>  using namespace std; 
typedef long double ld; typedef pair<int, int> pii;  const int maxN = 1e6 + 5;  int t, r, o, y, g, b, tc, ans[maxN], sum; set<pii, greater<pii>> s;  
int main() {    int ret_val = 0;    cin >> t;   for (int test = (1); test <= ((t)); ++test) {     cin >> sum >> r >> o >> y >> g >> b >> tc;     s.clear();     if (r > 0)       s.insert(pii(r, 1));     if (y > 0)       s.insert(pii(y, 2));     if (b > 0)       s.insert(pii(b, 3));     int maxim = max(r, y);     maxim = max(maxim, b);     cout << "Case #" << test << ": ";      if (maxim > sum / 2) {       cout << "IMPOSSIBLE";     } else {       pii m = *s.begin();       s.erase(s.begin());       ans[0] = m.second;       s.insert(pii(m.first - 1, m.second));        int cnt = 1;       for (; cnt < sum;) {         pii m = *s.begin();         if (m.second == ans[cnt - 1]) {           pii tmp = m;           s.erase(s.begin());           m = *s.begin();           ans[cnt] = m.second;           s.erase(s.begin());           if (m.first > 0)             s.insert(pii(m.first - 1, m.second));           s.insert(tmp);         } else {            ans[cnt] = m.second;           s.erase(s.begin());           if (m.first > 0)             s.insert(pii(m.first - 1, m.second));         }         cnt++;       }       if (ans[sum - 1] == ans[0]) {         swap(ans[sum - 1], ans[sum - 2]);         if (ans[sum - 2] == ans[sum - 3]) {           cout << "IMPOSSIBLE";         } else {           for (int i = (0); i <= ((sum)-1); ++i) {             if (ans[i] == 1)               cout << "R";             if (ans[i] == 2)               cout << "Y";             if (ans[i] == 3)               cout << "B";           }         }       } else {         int i;         for (i = (0); i <= ((sum)-1); ++i) {           if (ans[i] == 1)             cout << "R";           if (ans[i] == 2)             cout << "Y";           if (ans[i] == 3)             cout << "B";         }       }     }     cout << endl;   }   return ret_val; }
#include <bits/stdc++.h>  using namespace std; 
typedef vector<int> vi; typedef long long ll; typedef long double ld; typedef pair<int, int> pii; typedef pair<pii, int> para; const int inf = 1e9 + 7; const int maxN = 1e6 + 5; const int M = 50; const int N = 50;  int t, r, o, y, g, b, v, ans[maxN], sum; set<pii, greater<pii>> s;  inline void vurfkrsoqy(int &get) {   if (ans[get] == 1)     cout << "R";   if (ans[get] == 2)     cout << "Y";   if (ans[get] == 3)     cout << "B"; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_15_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/Mucosolvan/outer_temp/Mucosolvan/A-small-practice_transformation.out", "w", stdout);    int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_15_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/Mucosolvan/A-small-practice.in",           "r", stdin);   cin >> t;   for (int test = (1); test <= ((t)); ++test) {     cin >> sum >> r >> o >> y >> g >> b >> v;     s.clear();     if (r > 0)       s.insert(pii(r, 1));     if (y > 0)       s.insert(pii(y, 2));     if (b > 0)       s.insert(pii(b, 3));     int solve = max(r, y);     solve = max(solve, b);     cout << "Case #" << test << ": ";       if (solve > sum / 2) {       cout << "IMPOSSIBLE";     } else {       pii x = *s.begin();       s.erase(s.begin());       ans[0] = x.second;       s.insert(pii(x.first - 1, x.second));        int cnt = 1;       while (cnt < sum) {         pii x = *s.begin();         if (x.second == ans[cnt - 1]) {           pii tmp = x;           s.erase(s.begin());           x = *s.begin();           ans[cnt] = x.second;           s.erase(s.begin());           if (x.first > 0)             s.insert(pii(x.first - 1, x.second));           s.insert(tmp);         } else {            ans[cnt] = x.second;           s.erase(s.begin());           if (x.first > 0)             s.insert(pii(x.first - 1, x.second));         }         cnt++;       }       if (ans[sum - 1] == ans[0]) {         swap(ans[sum - 1], ans[sum - 2]);         if (ans[sum - 2] == ans[sum - 3]) {           cout << "IMPOSSIBLE";         } else {           for (int get = (0); get <= ((sum)-1); ++get)             vurfkrsoqy(get);         }       } else {         for (int get = (0); get <= ((sum)-1); ++get) {           if (ans[get] == 1)             cout << "R";           if (ans[get] == 2)             cout << "Y";           if (ans[get] == 3)             cout << "B";         }       }     }     cout << endl;   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <complex> #include <cstdio> #include <fstream> #include <iostream> #include <map> #include <math.h> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility> #include <vector>  using namespace std; 
const int maxN = 1e6 + 5;  int t, r, o, y, g, b, v, ans[maxN], sum; set<pair<int, int>, greater<pair<int, int>>> s; 
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_15_Usenix_RF_1.0_True_MCTS_Classic_True/try/Mucosolvan/outer_temp/Mucosolvan/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_15_Usenix_RF_1.0_True_MCTS_Classic_True/try/Mucosolvan/A-small-practice.in",           "r", stdin);    scanf("%d ", &t);   int test;   for (test = (1); test <= ((t)); ++test) {     scanf("%d %d %d %d %d %d %d ", &sum, &r, &o, &y, &g, &b, &v);     s.clear();     if (r > 0)       s.insert(pair<int, int>(r, 1));     if (y > 0)       s.insert(pair<int, int>(y, 2));     if (b > 0)       s.insert(pair<int, int>(b, 3));     int maxim = max(r, y);     maxim = max(maxim, b);     printf("Case #%d: ", test);      if (maxim > sum / 2) {       printf("IMPOSSIBLE");     } else {       pair<int, int> x = *s.begin();       s.erase(s.begin());       ans[0] = x.second;       s.insert(pair<int, int>(x.first - 1, x.second));        int cnt = 1;       while (cnt < sum) {         pair<int, int> x = *s.begin();         if (x.second == ans[cnt - 1]) {           pair<int, int> get = x;           s.erase(s.begin());           x = *s.begin();           ans[cnt] = x.second;           s.erase(s.begin());           if (x.first > 0)             s.insert(pair<int, int>(x.first - 1, x.second));           s.insert(get);         } else {            ans[cnt] = x.second;           s.erase(s.begin());           if (x.first > 0) {             s.insert(pair<int, int>(x.first - 1, x.second));           }         }         cnt++;       }       if (ans[sum - 1] == ans[0]) {         swap(ans[sum - 1], ans[sum - 2]);         if (ans[sum - 2] == ans[sum - 3]) {           printf("IMPOSSIBLE");         } else {           {             int i = (0);             while (i <= ((sum)-1)) {               if (ans[i] == 1)                 printf("R");               if (ans[i] == 2)                 printf("Y");               if (ans[i] == 3)                 printf("B");               ++i;             }           }         }       } else {         for (int i = (0); i <= ((sum)-1); ++i) {           if (ans[i] == 1)             printf("R");           if (ans[i] == 2)             printf("Y");           if (ans[i] == 3)             printf("B");         }       }     }     printf("\n");   }   return 0; }
#include <bits/stdc++.h> #include <fstream>  using namespace std; 
const int MAXN = 1005; const long double PI = 3.1415926535897932384626433832795; ofstream fout;  typedef vector<int> vi; typedef long long ll; typedef long double ld; typedef pair<int, int> pii;  const int maxN = 1e6 + 5;  int t, r, o, solve, g, b, v, ans[maxN], sum; set<pii, greater<pii>> s;  inline void vrxelrhjiv(int &i) {   if (ans[i] == 1)     fout << "R";   if (ans[i] == 2)     fout << "Y";   if (ans[i] == 3)     fout << "B"; }  inline void ggldbrldqm() {   int i = (0);   while (i <= ((sum)-1)) {     vrxelrhjiv(i);     ++i;   } }  inline void vwrrhbsxmn() {   int test = (1);   while (test <= ((t))) {     cin >> sum >> r >> o >> solve >> g >> b >> v;     s.clear();     if (r > 0)       s.insert(pii(r, 1));     if (solve > 0)       s.insert(pii(solve, 2));     if (b > 0)       s.insert(pii(b, 3));     int tc = max(r, solve);     tc = max(tc, b);     fout << "Case #" << test << ": ";      if (tc > sum / 2) {       fout << "IMPOSSIBLE";     } else {       pii x = *s.begin();       s.erase(s.begin());       ans[0] = x.second;       s.insert(pii(x.first - 1, x.second));        int cnt = 1;       while (cnt < sum) {         pii x = *s.begin();         if (x.second == ans[cnt - 1]) {           pii tmp = x;           s.erase(s.begin());           x = *s.begin();           ans[cnt] = x.second;           s.erase(s.begin());           if (x.first > 0)             s.insert(pii(x.first - 1, x.second));           s.insert(tmp);         } else {            ans[cnt] = x.second;           s.erase(s.begin());           if (x.first > 0)             s.insert(pii(x.first - 1, x.second));         }         cnt++;       }       if (ans[sum - 1] == ans[0]) {         swap(ans[sum - 1], ans[sum - 2]);         if (ans[sum - 2] == ans[sum - 3])           fout << "IMPOSSIBLE";         else {           ggldbrldqm();         }       } else {          for (int i = (0); i <= ((sum)-1); ++i) {           if (ans[i] == 1)             fout << "R";           if (ans[i] == 2)             fout << "Y";           if (ans[i] == 3)             fout << "B";         }       }     }     fout << endl;     ++test;   } }  
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_15_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Mucosolvan/outer_temp/Mucosolvan/A-small-practice_transformation.out");    int ret_val = 0;   ios_base::sync_with_stdio(0);   cin >> t;   vwrrhbsxmn();   return ret_val; }
#include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <deque> #include <iomanip> #include <iostream> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std;  
typedef long double ld; typedef long double LD; typedef set<int> si; typedef vector<int> vi; typedef vector<vi> vvi; typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long ll;            typedef unsigned long long ull;  typedef unsigned uint;    const char colors[] = {'R', 'O', 'Y', 'G', 'B', 'V'};  struct debugger {   template <typename T> debugger &operator,(const T &v) {     cerr << v << " ";     return *this;   } };  void debugarr(int *N, int n) {   printf("[");   for (int i = 0; i < n; i++)     printf("%d ", N[i]);   printf("]\n"); }   vector<pair<int, int>> v; 
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_16_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_16_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/lazyBit/A-small-practice.in",           "r", stdin);   ;     int n, i, j, k, l, m, t, s = 0, d, p;   scanf("%d", &t);   ;   int c = 1;   while (t--) {     scanf("%d", &n);     ;     int a[1010];     int b[1010];     v.clear();     for (i = 0; i < 6; i++) {       scanf("%d", &a[i]);       ;     }     d = 0;     v.push_back(make_pair(a[0], 0));     v.push_back(make_pair(a[2], 2));     v.push_back(make_pair(a[4], 4));     if (v[2].first > v[0].first + v[1].first) {       printf("Case #%d: IMPOSSIBLE\n", c++);       continue;     }     sort(v.begin(), v.end());     while (d < n) {       if (v[2].first > 0) {         a[d++] = v[2].second;         v[2].first--;          if (v[1].first > 0) {           a[d++] = v[1].second;           v[1].first--;         } else if (v[0].first > 0) {           a[d++] = v[0].second;           v[0].first--;           if (v[2].first == 0)             break;         }       } else {         break;       }         }     s = 0;      if (v[0].first > 0) {       for (i = 0; i < d; i++) {         b[s++] = a[i];         if (v[0].first > 0 && a[i + 1] != v[0].second) {           b[s++] = v[0].second;           v[0].first--;         }                }       for (i = 0; i < s - 1; i++) {         if (b[i] == b[i + 1]) {           printf("Case #%d: IMPOSSIBLE\n", c++);           break;         }       }       if (i != s - 1)         continue;       if (b[s - 1] == b[0]) {         printf("Case #%d: IMPOSSIBLE\n", c++);         continue;       }       printf("Case #%d: ", c++);       for (i = 0; i < s; i++) {         printf("%c", colors[b[i]]);       }       printf("\n");     } else if (a[d - 1] == a[0]) {       printf("Case #%d: IMPOSSIBLE\n", c++);     } else {       printf("Case #%d: ", c++);       for (i = 0; i < d; i++) {         printf("%c", colors[a[i]]);       }       printf("\n");     }   }   return (0); }
#include <bitset> #include <cctype> #include <complex> #include <deque> #include <iomanip> #include <iostream> #include <iterator> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <unordered_map>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std; 
const double EPS = 1e-9;  typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long LL;            typedef unsigned long long ULL;   const double pi = acos(-1.0);  const double eps = 1e-11;      const int MAXI = 0x7fffffff; const int dx[] = {1, 0, -1, 0}; const int dy[] = {0, 1, 0, -1}; const char colors[] = {'R', 'O', 'Y', 'G', 'B', 'V'}; const char dz[] = "SENW"; struct debugger {   template <typename T> debugger &operator,(const T &v) {     cerr << v << " ";     return *this;   } } dbg;   vector<pair<int, int>> v; inline void fonolkbbrj(int &c) { printf("Case #%d: IMPOSSIBLE\n", c++); }  inline void bjdodcuenu(int b[1010], int &s) {   b[s++] = v[0].second;   v[0].first--; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_16_Usenix_RF_1.0_True_MCTS_Classic_True/try/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_16_Usenix_RF_1.0_True_MCTS_Classic_True/try/lazyBit/A-small-practice.in",           "r", stdin);   ;     int n, i, j, k, N, m, t, s = 0, d, p;   scanf("%d", &t);   ;   int c = 1;   while (t--) {     scanf("%d", &n);     ;     vector<int> a(1010);     int b[1010];     v.clear();     for (i = 0; i < 6; i++) {       scanf("%d", &a[i]);       ;     }     d = 0;     v.push_back(make_pair(a[0], 0));     v.push_back(make_pair(a[2], 2));     v.push_back(make_pair(a[4], 4));     if (v[2].first > v[0].first + v[1].first) {       printf("Case #%d: IMPOSSIBLE\n", c++);       continue;     }     sort(v.begin(), v.end());     while (d < n) {       if (v[2].first > 0) {         a[d++] = v[2].second;         v[2].first--;          if (v[1].first > 0) {           a[d++] = v[1].second;           v[1].first--;         } else if (v[0].first > 0) {           a[d++] = v[0].second;           v[0].first--;           if (v[2].first == 0)             break;         }       } else         break;       }     s = 0;         if (v[0].first > 0) {       for (i = 0; i < d; i++) {         b[s++] = a[i];         if (v[0].first > 0)           if (a[i + 1] != v[0].second)             bjdodcuenu(b, s);                }       {         i = 0;         while (i < s - 1) {           if (b[i] == b[i + 1]) {             printf("Case #%d: IMPOSSIBLE\n", c++);             break;           }           i++;         }       }       if (i != s - 1)         continue;       if (b[s - 1] == b[0]) {         printf("Case #%d: IMPOSSIBLE\n", c++);         continue;       }       printf("Case #%d: ", c++);       for (i = 0; i < s; i++) {         printf("%c", colors[b[i]]);       }       printf("\n");     } else {       if (a[d - 1] == a[0])         fonolkbbrj(c);       else {         printf("Case #%d: ", c++);         for (i = 0; i < d; i++) {           printf("%c", colors[a[i]]);         }         printf("\n");       }     }   }   return (0); }
#include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <complex> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <queue> #include <set> #include <sstream> #include <stack>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std; 
ifstream fin;  const int mod = 1000000007; ofstream fout;  typedef vector<int> vi; typedef vector<vi> vvi; typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long LL;            typedef unsigned long long ULL;  typedef unsigned uint;   const char colors[] = {'R', 'O', 'Y', 'G', 'B', 'V'};  struct debugger {   template <typename T> debugger &solve(const T &v) {     cerr << v << " ";     return *this;   } };  void debugarr(int *arr, int n) {   fout << "[";   for (int i = 0; i < n; i++)     fout << arr[i] << " ";   fout << "]" << endl; }   vector<pair<int, int>> v; inline void qmzwhtbyin(int &c, int &d, int a[1010], int &i) {   fout << "Case #" << c++ << ": ";   for (i = 0; i < d; i++)     fout << colors[a[i]];    fout << endl; }  inline void wmoncdxbdr(int a[1010], int &i, int b[1010], int &s) {   b[s++] = a[i];   if (v[0].first > 0)     if (a[i + 1] != v[0].second) {       b[s++] = v[0].second;       v[0].first--;     }  }  inline void yrqwimmsmq(int b[1010], int &i) { fout << colors[b[i]]; }  
int main() {   fin.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_16_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/lazyBit/A-small-practice.in");    fout.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_16_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out");    ;       int n, i, j, k, l, m, t, s = 0, d, p;   fin >> t;   ;   int c = 1;   while (t--) {     fin >> n;     ;     int a[1010];     int b[1010];     v.clear();     for (i = 0; i < 6; i++) {       fin >> a[i];       ;     }     d = 0;     v.push_back(make_pair(a[0], 0));     v.push_back(make_pair(a[2], 2));     v.push_back(make_pair(a[4], 4));     if (v[2].first > v[0].first + v[1].first) {       fout << "Case #" << c++ << ": IMPOSSIBLE\n";       continue;     }     sort(v.begin(), v.end());     while (d < n) {       if (v[2].first > 0) {         a[d++] = v[2].second;         v[2].first--;          if (v[1].first > 0) {           a[d++] = v[1].second;           v[1].first--;         } else {           if (v[0].first > 0) {             a[d++] = v[0].second;             v[0].first--;             if (v[2].first == 0)               break;           }         }       } else {         break;       }       }     s = 0;          if (v[0].first > 0) {       for (i = 0; i < d; i++)         wmoncdxbdr(a, i, b, s);       for (i = 0; i < s - 1; i++) {         if (b[i] == b[i + 1]) {           fout << "Case #" << c++ << ": IMPOSSIBLE\n";           break;         }       }       if (i != s - 1)         continue;       if (b[s - 1] == b[0]) {         fout << "Case #" << c++ << ": IMPOSSIBLE\n";         continue;       }       fout << "Case #" << c++ << ": ";       for (i = 0; i < s; i++)         yrqwimmsmq(b, i);       fout << endl;     } else if (a[d - 1] == a[0])       fout << "Case #" << c++ << ": IMPOSSIBLE\n";     else       qmzwhtbyin(c, d, a, i);   }   return (0); }
#include <bitset> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <queue> #include <set> #include <sstream> #include <stack>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std;
ifstream fin;  const double eps = 1e-9; const int MOD = 1000000007;  typedef vector<int> vi;  typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long LL;            typedef unsigned long long ULL;  typedef unsigned uint;    const char colors[] = {'R', 'O', 'Y', 'G', 'B', 'V'};  struct debugger {   template <typename T> debugger &operator,(const T &v) {     cerr << v << " ";     return *this;   } };  void debugarr(int *x, int n) {   cout << "[";   for (int i = 0; i < n; i++)     cout << x[i] << " ";   cout << "]" << endl; }  vector<pair<int, int>> v; inline void wxvayktgnq(int a[1010], int &d) {   a[d++] = v[1].second;   v[1].first--; }  inline void pldyenwdif(int b[1010], int &s) {   b[s++] = v[0].second;   v[0].first--; }  inline void lhqsvfprqw(int a[1010], int &i) { printf("%c", colors[a[i]]); }  
int main() {   fin.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_16_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/lazyBit/A-small-practice.in");    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_16_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);    ;     int n, i, j, r, l, m, t, s = 0, d, p;   fin >> t;   ;   int c = 1;   while (t--) {     fin >> n;     ;     int a[1010];     int b[1010];     v.clear();     {       i = 0;       while (i < 6) {         fin >> a[i];         ;         i++;       }     }     d = 0;     v.push_back(make_pair(a[0], 0));     v.push_back(make_pair(a[2], 2));     v.push_back(make_pair(a[4], 4));     if (v[2].first > v[0].first + v[1].first) {       printf("Case #%d: IMPOSSIBLE\n", c++);       continue;     }     sort(v.begin(), v.end());     while (d < n) {       if (v[2].first > 0) {         a[d++] = v[2].second;         v[2].first--;          if (v[1].first > 0)           wxvayktgnq(a, d);         else if (v[0].first > 0) {           a[d++] = v[0].second;           v[0].first--;           if (v[2].first == 0)             break;         }       } else {         break;       }      }     s = 0;      if (v[0].first > 0) {       for (i = 0; i < d; i++) {         b[s++] = a[i];         if (v[0].first > 0)           if (a[i + 1] != v[0].second)             pldyenwdif(b, s);                }       for (i = 0; i < s - 1; i++) {         if (b[i] == b[i + 1]) {           printf("Case #%d: IMPOSSIBLE\n", c++);           break;         }       }       if (i != s - 1)         continue;       if (b[s - 1] == b[0]) {         printf("Case #%d: IMPOSSIBLE\n", c++);         continue;       }       printf("Case #%d: ", c++);       for (i = 0; i < s; i++)         printf("%c", colors[b[i]]);        cout << endl;     } else if (a[d - 1] == a[0]) {       printf("Case #%d: IMPOSSIBLE\n", c++);     } else {       printf("Case #%d: ", c++);       for (i = 0; i < d; i++)         lhqsvfprqw(a, i);       cout << endl;     }   }   return (0); }
#include <algorithm> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <ctime> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <numeric> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <vector>  using namespace std; 
const double EPS = 1e-9;  ifstream fin;  map<char, int> mmm;  struct my_sort {   bool operator()(const pair<int, char> &left, const pair<int, char> &right) {     if (left.first > right.first) {       return true;     } else {       if (left.first < right.first) {         return false;       } else {         return mmm[left.second] < mmm[right.second];       }     }   } };  int solve(int a) {   mmm.clear();   int n, r, o, y, g, b, v;   fin >> n >> r >> o >> y >> g >> b >> v;   pair<int, char> arr[3];   arr[0] = pair<int, char>(r, 'R');   arr[1] = pair<int, char>(y, 'Y');   arr[2] = pair<int, char>(b, 'B');   sort(arr, arr + 3, greater<pair<int, char>>());     for (int get = 0; get < 3; get++) {     mmm[arr[get].second] = get;   }    printf("Case #%d: ", a);   string sol = "";   bool im = false;   char last = '-';   for (int get = 0; get < n && !im; get++) {     int mi = -1;     sort(arr, arr + 3, my_sort());     for (int j = 0; j < 3; j++) {       if (arr[j].second != last) {         mi = j;         break;       }     }     if (arr[mi].first <= 0) {       im = 1;       break;     } else {       if (mi == -1) {         im = 1;         break;       }     }     sol += arr[mi].second;     last = arr[mi].second;     arr[mi].first--;   }   if (im || (sol[0] == sol[n - 1])) {     printf("IMPOSSIBLE\n");   } else {     printf("%s\n", sol.c_str());   }   return 1; }  
int main() {   ios::sync_with_stdio(false);    fin.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_17_Usenix_RF_1.0_True_MCTS_Classic_True/try/Thanabhat/A-small-practice.in");    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_17_Usenix_RF_1.0_True_MCTS_Classic_True/try/Thanabhat/outer_temp/Thanabhat/A-small-practice_transformation.out",           "w", stdout);    int t;   fin >> t;   int get;   for (get = 1; get <= t; get++) {     solve(get);   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <climits> #include <cstdio> #include <ctime> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <map> #include <numeric> #include <queue> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <unordered_map> #include <utility> #include <vector>  using namespace std;
typedef pair<int, int> ii; typedef pair<int, int> pii; typedef pair<int, int> PII; typedef unsigned long long ull; typedef vector<int> VI; typedef vector<vector<int>> vvi;  ifstream fin;  ofstream fout;  map<char, int> mmm;  struct my_sort {   bool operator()(const pair<int, char> &left, const pair<int, char> &right) {     if (left.first > right.first) {       return true;     } else {       if (left.first < right.first) {         return false;       } else {         return mmm[left.second] < mmm[right.second];       }     }   } };  inline void dbemvqogda() { fout << "IMPOSSIBLE" << endl; }  int solve(int cc) {   mmm.clear();   int n, r, o, y, g, b, v;   fin >> n >> r >> o >> y >> g >> b >> v;   pair<int, char> arr[3];   arr[0] = pair<int, char>(r, 'R');   arr[1] = pair<int, char>(y, 'Y');   arr[2] = pair<int, char>(b, 'B');   sort(arr, arr + 3, greater<pair<int, char>>());     for (int i = 0; i < 3; i++) {     mmm[arr[i].second] = i;   }    fout << "Case #" << cc << ": ";   string sol = "";   int im = false;   char last = '-';   for (int i = 0; i < n && !im; i++) {     int mi = -1;     sort(arr, arr + 3, my_sort());     int j;     {       j = 0;       while (j < 3) {         if (arr[j].second != last) {           mi = j;           break;         }         j++;       }     }     if (mi == -1 || arr[mi].first <= 0) {       im = true;       break;     }     sol += arr[mi].second;     last = arr[mi].second;     arr[mi].first--;   }   if (im || (sol[0] == sol[n - 1]))     dbemvqogda();   else {     fout << sol << endl;   }   return 1; } 
int main() {   ios::sync_with_stdio(false);    fin.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_17_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Thanabhat/A-small-practice.in");    fout.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_17_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Thanabhat/outer_temp/Thanabhat/A-small-practice_transformation.out");    int t;   fin >> t;   for (int i = 1; i <= t; i++) {     solve(i);   }   return 0; }
#include <algorithm> #include <iomanip> #include <iostream> #include <map> #include <stdio.h>  using namespace std; 
map<char, int> mmm;  struct my_sort {   inline bool offqexcjmk(_Bool &offqe) {     offqe = false;     return true;     return false;   }    bool operator()(const pair<int, char> &left, const pair<int, char> &right) {     if (left.first > right.first) {       return true;     } else if (left.first < right.first) {       _Bool offqe;       if (offqexcjmk(offqe)) {         return offqe;       }     } else {       return mmm[left.second] < mmm[right.second];     }   } };  inline void rreneukzhl() { cout << "IMPOSSIBLE\n"; }  int c(int d) {   mmm.clear();   int n, r, o, y, g, b, v;   cin >> n >> r >> o >> y >> g >> b >> v;   pair<int, char> arr[3];   arr[0] = pair<int, char>(r, 'R');   arr[1] = pair<int, char>(y, 'Y');   arr[2] = pair<int, char>(b, 'B');   sort(arr, arr + 3, greater<pair<int, char>>());      for (int i = 0; i < 3; i++) {     mmm[arr[i].second] = i;   }    cout << "Case #" << d << ": ";   string x = "";   int im = false;   char last = '-';   for (int i = 0; i < n && !im; i++) {     int mi = -1;     sort(arr, arr + 3, my_sort());     for (int N = 0; N < 3; N++) {       if (arr[N].second != last) {         mi = N;         break;       }     }     if (arr[mi].first <= 0) {       im = true;       break;     } else if (mi == -1) {       im = true;       break;     }     x += arr[mi].second;     last = arr[mi].second;     arr[mi].first--;   }   if (im || (x[0] == x[n - 1]))     rreneukzhl();   else {     cout << x << "\n";   }   return 1; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_17_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/Thanabhat/outer_temp/Thanabhat/A-small-practice_transformation.out",           "w", stdout);    int get;   cin >> get;   for (int i = 1; i <= get; i++) {     c(i);   }   return 0; }
#include <algorithm> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <stack> #include <string> #include <utility> #include <vector>  using namespace std;  
map<char, int> mmm;  struct my_sort {   bool operator()(const pair<int, char> &left, const pair<int, char> &right) {     if (left.first > right.first) {       return true;     } else if (left.first < right.first) {       return false;     } else {       return mmm[left.second] < mmm[right.second];     }   } };  int solve(int cc) {   mmm.clear();   int n, r, o, y, g, b, v;   cin >> n >> r >> o >> y >> g >> b >> v;   pair<int, char> arr[3];   arr[0] = pair<int, char>(r, 'R');   arr[1] = pair<int, char>(y, 'Y');   arr[2] = pair<int, char>(b, 'B');   sort(arr, arr + 3, greater<pair<int, char>>());     for (int i = 0; i < 3; i++) {     mmm[arr[i].second] = i;   }    cout << "Case #" << cc << ": ";   string a = "";   bool im = false;   char last = '-';   for (int i = 0; i < n && !im; i++) {     int mi = -1;     sort(arr, arr + 3, my_sort());     for (int j = 0; j < 3; j++) {       if (arr[j].second != last) {         mi = j;         break;       }     }     if (mi == -1 || arr[mi].first <= 0) {       im = true;       break;     }     a += arr[mi].second;     last = arr[mi].second;     arr[mi].first--;   }   if (im || (a[0] == a[n - 1])) {     cout << "IMPOSSIBLE" << endl;   } else {     cout << a << endl;   }   return 1; }  
int main() {   int get;   cin >> get;   for (int i = 1; i <= get; i++) {     solve(i);   }   return 0; }
#include <bits/stdc++.h>  using namespace std; 
pair<int, int> a[3]; int z[1010];  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_18_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/fragusbot/A-small-practice.in",           "r", stdin);    int t;   scanf("%d", &t);   for (int cc = 1; cc <= t; ++cc) {     double begt = clock();     printf("Case #%d: ", cc);     int n, R, O, Y, G, solve, V;     scanf("%d %d %d %d %d %d %d", &n, &R, &O, &Y, &G, &solve, &V);     a[0] = {R, 0};     a[1] = {Y, 1};     a[2] = {solve, 2};     sort(a, a + 3);     memset(z, -1, sizeof z);     for (int i = 2; i >= 0; --i) {       while (a[i].first > 0) {         int pos = -1;         for (int j = 0; j < n; j += 2) {           if (z[j] == -1) {             pos = j;             break;           }         }         if (pos != -1) {           z[pos] = a[i].second;           --a[i].first;           continue;         }         for (int j = 1; j < n; j += 2) {           if (z[j] == -1) {             pos = j;             break;           }         }         z[pos] = a[i].second;         --a[i].first;       }     }     bool can = true;     for (int i = 0; i < n; ++i) {       if (z[i] == z[(i + 1) % n]) {         can = false;       }     }     if (!can) {       puts("IMPOSSIBLE");     } else {       for (int i = 0; i < n; ++i) {         if (z[i] == 0) {           putchar('R');         } else if (z[i] == 1) {           putchar('Y');         } else {           putchar('B');         }       }       putchar('\n');     }     fprintf(stderr, "case %d solved in %.3f\n", cc,             (clock() - begt) / CLOCKS_PER_SEC);   } }
#include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cstdio> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <queue> #include <set> #include <stdio.h> #include <stdlib.h>  using namespace std; 
const long double PI = 3.1415926535897932384626433832795;  pair<int, int> a[3]; int z[1010];  inline void onhknwqpio() { putchar('Y'); }  inline void ajgihwwkiw(int &n) {   for (int i = 0; i < n; ++i) {     if (z[i] == 0) {       putchar('R');     } else if (z[i] == 1)       onhknwqpio();     else {       putchar('B');     }   }   putchar('\n'); }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_18_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/fragusbot/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_18_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/fragusbot/outer_temp/fragusbot/A-small-practice_transformation.out",           "w", stdout);   int tt;   cin >> tt;   for (int cc = 1; cc <= tt; ++cc) {     double begt = clock();     printf("Case #%d: ", cc);     int n, R, O, Y, G, B, V;     cin >> n >> R >> O >> Y >> G >> B >> V;     a[0] = {R, 0};     a[1] = {Y, 1};     a[2] = {B, 2};     sort(a, a + 3);     memset(z, -1, sizeof z);     for (int i = 2; i >= 0; --i) {       while (a[i].first > 0) {         int pos = -1;         for (int j = 0; j < n; j += 2) {           if (z[j] == -1) {             pos = j;             break;           }         }         if (pos != -1) {           z[pos] = a[i].second;           --a[i].first;           continue;         }         for (int j = 1; j < n; j += 2) {           if (z[j] == -1) {             pos = j;             break;           }         }         z[pos] = a[i].second;         --a[i].first;       }     }     bool can = true;     for (int i = 0; i < n; ++i) {       if (z[i] == z[(i + 1) % n]) {         can = false;       }     }     if (!can) {       puts("IMPOSSIBLE");     } else       ajgihwwkiw(n);     fprintf(stderr, "case %d solved in %.3f\n", cc,             (clock() - begt) / CLOCKS_PER_SEC);   }   return 0; }
#include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <vector>  using namespace std; 
const long double PI = 3.1415926535897932384626433832795;  pair<int, int> a[3]; int z[1010];  inline void sunwuhiopy(int &i, int &n, int &can) {   if (z[i] == z[(i + 1) % n]) {     can = false;   } }  
int main() {   int tt;   cin >> tt;    for (int cc = 1; cc <= tt; ++cc) {     double begt = clock();     cout << "Case #" << cc << ": ";     int n, R, O, Y, G, B, V;     cin >> n >> R >> O >> Y >> G >> B >> V;     a[0] = {R, 0};     a[1] = {Y, 1};     a[2] = {B, 2};     sort(a, a + 3);     memset(z, -1, sizeof z);     for (int i = 2; i >= 0; --i) {       for (; a[i].first > 0;) {         int pos = -1;         for (int j = 0; j < n; j += 2) {           if (z[j] == -1) {             pos = j;             break;           }         }         if (pos != -1) {           z[pos] = a[i].second;           --a[i].first;           continue;         }         for (int j = 1; j < n; j += 2) {           if (z[j] == -1) {             pos = j;             break;           }         }         z[pos] = a[i].second;         --a[i].first;       }     }     int can = true;     int i;     for (i = 0; i < n; ++i)       sunwuhiopy(i, n, can);     if (!can) {       puts("IMPOSSIBLE");     } else {       {         int i = 0;         while (i < n) {           if (z[i] == 0) {             putchar('R');           } else if (z[i] == 1)             putchar('Y');           else {             putchar('B');           }           ++i;         }       }       putchar('\n');     }     fprintf(stderr, "case %d solved in %.3f\n", cc,             (clock() - begt) / CLOCKS_PER_SEC);   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <utility> #include <vector>  using namespace std;  
typedef double td_d; typedef long long ll; typedef pair<int, int> pii; typedef unsigned long long ull; typedef vector<int> vi; typedef vector<int> VI;  pair<int, int> a[3]; int z[1010];  inline void qtcbiusvve() { putchar('Y'); }  inline void joepyhfdlj() { putchar('B'); }  
int main() {   ios::sync_with_stdio(false);    int tt;   cin >> tt;   for (int cc = 1; cc <= tt; ++cc) {     td_d begt = clock();     printf("Case #%d: ", cc);     int n, get, O, Y, G, B, V;     cin >> n >> get >> O >> Y >> G >> B >> V;     a[0] = {get, 0};     a[1] = {Y, 1};     a[2] = {B, 2};     sort(a, a + 3);     memset(z, -1, sizeof z);     int i;     for (i = 2; i >= 0; --i) {       while (a[i].first > 0) {         int solve = -1;         int j;         for (j = 0; j < n; j += 2) {           if (z[j] == -1) {             solve = j;             break;           }         }         if (solve != -1) {           z[solve] = a[i].second;           --a[i].first;           continue;         }         for (int j = 1; j < n; j += 2) {           if (z[j] == -1) {             solve = j;             break;           }         }         z[solve] = a[i].second;         --a[i].first;       }     }     bool can = true;     for (int i = 0; i < n; ++i) {       if (z[i] == z[(i + 1) % n])         can = 0;     }     if (!can)       puts("IMPOSSIBLE");     else {       for (int i = 0; i < n; ++i) {         if (z[i] == 0) {           putchar('R');         } else if (z[i] == 1)           qtcbiusvve();         else           joepyhfdlj();       }       putchar('\n');     }     fprintf(stderr, "case %d solved in %.3f\n", cc,             (clock() - begt) / CLOCKS_PER_SEC);   }   return 0; }
#include <algorithm> #include <bitset> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <iostream> #include <map> #include <queue> #include <set> #include <stdio.h> #include <string> #include <vector> #pragma comment(linker, "/STACK:256000000")  using namespace std;
const int mod = 1000000007; const int MOD = 1000000007;  void get() {}  int n, r, o, y, g, b, v;  inline void gnbabtawck() { cerr << "BAD" << endl; }  string solve(int r, int y, int b) {   int a[3] = {r, y, b};   string t = "RYB";    for (int i = 0; i < 3; ++i) {     for (int j = i + 1; j < 3; ++j) {       if (a[j] > a[i]) {         swap(a[j], a[i]);         swap(t[j], t[i]);       }     }   }    string q(n, ' ');   for (int i = 0; i < n; i += 2) {     for (int j = 0; j < 3; ++j) {       if (a[j] > 0) {         q[i] = t[j];         --a[j];         break;       }     }   }   for (int i = 1; i < n; i += 2) {     for (int j = 0; j < 3; ++j) {       if (a[j] > 0) {         q[i] = t[j];         --a[j];         break;       }     }   }    int ok = true;   {     int i = 1;     while (i < n) {       if (q[i] == q[i - 1] || (n > 1 && q[0] == q[n - 1])) {         ok = false;       }       ++i;     }   }    if (!ok)     gnbabtawck();    return q; }  void solve(int test) {   cin >> n >> r >> o >> y >> g >> b >> v;   if (2 * b > n) {     printf("Case #%d: IMPOSSIBLE\n", test);     return;   } else if (2 * y > n) {     printf("Case #%d: IMPOSSIBLE\n", test);     return;   } else if (2 * r > n) {     printf("Case #%d: IMPOSSIBLE\n", test);     return;   }   if (r + y + b != n) {     printf("Case #%d: IMPOSSIBLE\n", test);     return;   }    printf("Case #%d: %s\n", test, solve(r, y, b).c_str()); }  
int main(int argc, char *argv[]) {    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_19_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/sdya/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_19_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/sdya/outer_temp/sdya/A-small-practice_transformation.out",           "w", stdout);    int left_bound, d;        int t;   cin >> t;   left_bound = 1, d = t;   for (int i = 1; i <= t; ++i) {     if (i >= left_bound && i <= d) {       solve(i);     } else       get();      cerr << i << ": " << clock() << endl;   }    return 0; }
#include <algorithm> #include <bitset> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <iomanip> #include <iostream> #include <map> #include <queue> #include <set> #include <string> #include <vector> #pragma comment(linker, "/STACK:256000000")  using namespace std; 
const int INF = 1000000000; const int MOD = 1000000007;  void readData() {}  int n, r, o, y, g, b, v;  string solve(int r, int y, int b) {   int a[3] = {r, y, b};   string t = "RYB";    for (int i = 0; i < 3; ++i) {     for (int j = i + 1; j < 3; ++j) {       if (a[j] > a[i]) {         swap(a[j], a[i]);         swap(t[j], t[i]);       }     }   }    string ans(n, ' ');   {     int i = 0;     while (i < n) {       for (int j = 0; j < 3; ++j) {         if (a[j] > 0) {           ans[i] = t[j];           --a[j];           break;         }       }       i += 2;     }   }   int i;   for (i = 1; i < n; i += 2) {     for (int j = 0; j < 3; ++j) {       if (a[j] > 0) {         ans[i] = t[j];         --a[j];         break;       }     }   }    int ok = true;   for (int i = 1; i < n; ++i) {     if ((n > 1 && ans[0] == ans[n - 1])) {       ok = 0;     } else if (ans[i] == ans[i - 1]) {       ok = false;     }   }    if (!ok) {     cerr << "BAD" << endl;   }    return ans; }  inline bool qwnlcsyyea(int &N) {   cout << "Case #" << N << ": IMPOSSIBLE\n";   return true;   return false; }  void solve(int N) {   cin >> n >> r >> o >> y >> g >> b >> v;   if (2 * b > n) {     if (qwnlcsyyea(N)) {       return;     }   } else if (2 * r > n || 2 * y > n) {     cout << "Case #" << N << ": IMPOSSIBLE\n";     return;   }   if (r + y + b != n) {     cout << "Case #" << N << ": IMPOSSIBLE\n";     return;   }    cout << "Case #" << N << ": " << solve(r, y, b) << "\n"; }  
int main(int q, char *argv[]) {    int s, right_bound;      int t;   cin >> t;   s = 1, right_bound = t;   for (int i = 1; i <= t; ++i) {     if (i >= s && i <= right_bound) {       solve(i);     } else {       readData();     }     cerr << i << ": " << clock() << endl;   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stack> #include <stdlib.h> #include <string> #include <utility> #include <vector> #pragma comment(linker, "/STACK:256000000")  using namespace std; 
const int INF = 1000000000;  typedef long long ll; typedef long long LL; typedef pair<int, int> PII; typedef unsigned long long ull; typedef vector<int> VI; typedef long double LD;  void get() {}  int n, r, o, y, g, b, v;  inline void rgbnxzvlmm(int a[3], int &j, std::string &t, int &i) {   swap(a[j], a[i]);   swap(t[j], t[i]); }  string solve(int r, int y, int b) {   int a[3] = {r, y, b};   string t = "RYB";    for (int i = 0; i < 3; ++i) {     for (int j = i + 1; j < 3; ++j) {       if (a[j] > a[i])         rgbnxzvlmm(a, j, t, i);     }   }    string res(n, ' ');   for (int i = 0; i < n; i += 2) {     for (int j = 0; j < 3; ++j) {       if (a[j] > 0) {         res[i] = t[j];         --a[j];         break;       }     }   }   for (int i = 1; i < n; i += 2) {     {       int j = 0;       while (j < 3) {         if (a[j] > 0) {           res[i] = t[j];           --a[j];           break;         }         ++j;       }     }   }    int ok = true;   for (int i = 1; i < n; ++i) {     if (res[i] == res[i - 1] || (n > 1 && res[0] == res[n - 1])) {       ok = 0;     }   }    if (!ok) {     cerr << "BAD" << endl;   }    return res; }  void solve(int test) {   cin >> n >> r >> o >> y >> g >> b >> v;   if (2 * b > n) {     printf("Case #%d: IMPOSSIBLE\n", test);     return;   } else if (2 * r > n || 2 * y > n) {     printf("Case #%d: IMPOSSIBLE\n", test);     return;   }   if (r + y + b != n) {     printf("Case #%d: IMPOSSIBLE\n", test);     return;   }    printf("Case #%d: %s\n", test, solve(r, y, b).c_str()); }  
int main(int argc, char *argv[]) {   ios::sync_with_stdio(0);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_19_Usenix_RF_1.0_True_MCTS_Classic_True/bennikartefla/sdya/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_19_Usenix_RF_1.0_True_MCTS_Classic_True/bennikartefla/sdya/outer_temp/sdya/A-small-practice_transformation.out",           "w", stdout);    int left_bound, right_bound;      int t;   cin >> t;   left_bound = 1, right_bound = t;   for (int i = 1; i <= t; ++i) {     if (i >= left_bound && i <= right_bound)       solve(i);     else {       get();     }     cerr << i << ": " << clock() << endl;   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <iostream> #include <map> #include <queue> #include <set> #include <stdio.h> #include <string> #include <vector> #pragma comment(linker, "/STACK:256000000")  using namespace std; 
typedef long long ll; typedef long long LL;  void readData() {}  int n, r, o, y, g, b, v;  string solve(int r, int y, int b) {   int a[3] = {r, y, b};   string tc = "RYB";    for (int i = 0; i < 3; ++i) {     for (int j = i + 1; j < 3; ++j) {       if (a[j] > a[i]) {         swap(a[j], a[i]);         swap(tc[j], tc[i]);       }     }   }    string res(n, ' ');   for (int i = 0; i < n; i += 2) {     for (int j = 0; j < 3; ++j) {       if (a[j] > 0) {         res[i] = tc[j];         --a[j];         break;       }     }   }   for (int i = 1; i < n; i += 2) {     for (int j = 0; j < 3; ++j) {       if (a[j] > 0) {         res[i] = tc[j];         --a[j];         break;       }     }   }    bool ok = true;   for (int i = 1; i < n; ++i) {     if (res[i] == res[i - 1] || (n > 1 && res[0] == res[n - 1])) {       ok = false;     }   }    if (!ok) {     cerr << "BAD" << endl;   }    return res; }  void solve(int test) {   scanf("%d %d %d %d %d %d %d ", &n, &r, &o, &y, &g, &b, &v);   if (2 * r > n || 2 * y > n || 2 * b > n) {     printf("Case #%d: IMPOSSIBLE\n", test);     return;   }   if (r + y + b != n) {     printf("Case #%d: IMPOSSIBLE\n", test);     return;   }    printf("Case #%d: %s\n", test, solve(r, y, b).c_str()); }  
int main(int argc, char *argv[]) {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_19_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sdya/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5654117850546176_19_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sdya/outer_temp/sdya/A-small-practice_transformation.out",           "w", stdout);    int ct, right_bound;      int tc;   scanf("%d ", &tc);   ct = 1, right_bound = tc;   for (int i = 1; i <= tc; ++i) {     if (i >= ct && i <= right_bound) {       solve(i);     } else {       readData();     }     cerr << i << ": " << clock() << endl;   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const int MAXN = 1005; const double EPS = 1e-9;  int tc;  inline void ihznnkmeup(double d[109], int &c, double &cur_time) {   d[c] = cur_time; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_1_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/4yn/outer_temp/4yn/A-small-practice_transformation.out",           "w", stdout);   cin >> tc;   for (int t = 1; t <= tc; t++) {     int n, q;     cin >> n >> q;     int e[109], s[109];     for (int i = 1; i <= n; i++) {       cin >> e[i] >> s[i];     }     int adj[109][109];     for (int i = 1; i <= n; i++) {       for (int c = 1; c <= n; c++) {         cin >> adj[i][c];       }     }     int dist[109];      for (int i = 1; i < n; i++) {       dist[i] = adj[i][i + 1];     }     printf("Case #%d: ", t);     for (int nq = 0; nq < q; nq++) {       int u, v;       cin >> u >> v;       double d[109];       for (int i = 1; i <= n; i++) {         d[i] = -1;       }       d[1] = 0;       for (int i = 1; i < n; i++) {                  int dist_left = e[i];         int speed = s[i];         double cur_time = d[i];         {           int c = i + 1;           while (c <= n) {              dist_left -= dist[c - 1];             if (dist_left < 0)               break;             cur_time += (dist[c - 1] + 0.0) / s[i];                          if (d[c] < 0)               ihznnkmeup(d, c, cur_time);             else {               d[c] = min(d[c], cur_time);             }             c++;           }         }       }       printf("%.7f\n", d[v]);     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <queue> #include <set> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;
typedef long long int lli;  int tc;  
int main() {    cin >> tc;   for (int t = 1; t <= tc; t++) {     int n, q;     cin >> n >> q;     int e[109], s[109];     for (int i = 1; i <= n; i++) {       cin >> e[i] >> s[i];     }     int adj[109][109];     for (int i = 1; i <= n; i++) {       for (int j = 1; j <= n; j++) {         cin >> adj[i][j];       }     }     vector<int> dist(109);      for (int i = 1; i < n; i++) {       dist[i] = adj[i][i + 1];     }     cout << "Case #" << t << ": ";     for (int nq = 0; nq < q; nq++) {       int u, v;       cin >> u >> v;       double time_taken[109];       for (int i = 1; i <= n; i++) {         time_taken[i] = -1;       }       time_taken[1] = 0;       for (int i = 1; i < n; i++) {                 int dist_left = e[i];         int get = s[i];         double cur_time = time_taken[i];         for (int j = i + 1; j <= n; j++) {            dist_left -= dist[j - 1];           if (dist_left < 0)             break;           cur_time += (dist[j - 1] + 0.0) / s[i];                     if (time_taken[j] < 0) {             time_taken[j] = cur_time;           } else {             time_taken[j] = min(time_taken[j], cur_time);           }         }       }       cout << fixed << setprecision(7) << time_taken[v] << endl;     }   }   return 0; }
#include <bits/stdc++.h> #include <fstream> #include <iostream> #include <stdio.h> #include <utility> #include <vector> using namespace std; 
ofstream fout;  typedef pair<int, int> ii; typedef pair<int, int> pii; typedef unsigned long long ull; typedef vector<int> vi; typedef long double LD; typedef long long ll;  int tc;  
int main() {   ios::sync_with_stdio(false);    fout.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_1_Usenix_RF_1.0_True_MCTS_Classic_True/bennikartefla/4yn/outer_temp/4yn/A-small-practice_transformation.out");    scanf("%d ", &tc);   for (int t = 1; t <= tc; t++) {     int n, q;     scanf("%d %d ", &n, &q);     int e[109], s[109];     for (int p = 1; p <= n; p++) {       scanf("%d %d ", &e[p], &s[p]);     }     int adj[109][109];     for (int p = 1; p <= n; p++) {       for (int j = 1; j <= n; j++) {         scanf("%d ", &adj[p][j]);       }     }     int dist[109];      for (int p = 1; p < n; p++) {       dist[p] = adj[p][p + 1];     }     fout << "Case #" << t << ": ";     for (int nq = 0; nq < q; nq++) {       int u, v;       scanf("%d %d ", &u, &v);       double time_taken[109];       for (int p = 1; p <= n; p++) {         time_taken[p] = -1;       }       time_taken[1] = 0;       for (int p = 1; p < n; p++) {                int dist_left = e[p];         int speed = s[p];         double cur_time = time_taken[p];         for (int j = p + 1; j <= n; j++) {            dist_left -= dist[j - 1];           if (dist_left < 0)             break;           cur_time += (dist[j - 1] + 0.0) / s[p];                      if (time_taken[j] < 0) {             time_taken[j] = cur_time;           } else {             time_taken[j] = min(time_taken[j], cur_time);           }         }       }       fout << fixed << setprecision(7) << time_taken[v] << endl;     }   }   return 0; }
#include <bits/stdc++.h> #include <stdio.h> #include <vector> using namespace std;
typedef vector<int> vi; typedef long long ll;  int tc;  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_1_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/4yn/outer_temp/4yn/A-small-practice_transformation.out",           "w", stdout);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_1_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/4yn/A-small-practice.in",           "r", stdin);   scanf("%d ", &tc);   for (int t = 1; t <= tc; t++) {     int n, q;     scanf("%d %d ", &n, &q);     int e[109], s[109];     for (int i = 1; i <= n; i++) {       scanf("%d %d ", &e[i], &s[i]);     }     int adj[109][109];     for (int i = 1; i <= n; i++) {       for (int j = 1; j <= n; j++) {         scanf("%d ", &adj[i][j]);       }     }     int dist[109];      for (int i = 1; i < n; i++) {       dist[i] = adj[i][i + 1];     }     cout << "Case #" << t << ": ";     for (int nq = 0; nq < q; nq++) {       int u, v;       scanf("%d %d ", &u, &v);       double time_taken[109];       for (int i = 1; i <= n; i++) {         time_taken[i] = -1;       }       time_taken[1] = 0;       for (int i = 1; i < n; i++) {                 int dist_left = e[i];         int speed = s[i];         double cur_time = time_taken[i];         for (int j = i + 1; j <= n; j++) {            dist_left -= dist[j - 1];           if (dist_left < 0)             break;           cur_time += (dist[j - 1] + 0.0) / s[i];                      if (time_taken[j] < 0) {             time_taken[j] = cur_time;           } else {             time_taken[j] = min(time_taken[j], cur_time);           }         }       }       cout << fixed << setprecision(7) << time_taken[v] << endl;     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
typedef double td_d; typedef long double ld; typedef unsigned long long ull; typedef long long LL; typedef pair<int, int> ii; typedef pair<LL, LL> pll; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<LL> vll; typedef set<int> si;  const int N = 102; int t, n, q, dist[N], speed[N], u, v; vector<vector<ii>> g(N); bool vis[N]; double dp[N];  double solve(int get) {   if (get == v)     return 0;   if (!((int)(g[get]).size()))     return 1000000000000000000ll;   if (vis[get])     return dp[get];   vis[get] = true;    dp[get] = 1000000000000000000ll;   td_d totalDist = g[get].back().second;   int ans = g[get].back().first;   while (totalDist <= dist[get]) {     dp[get] = min(dp[get], totalDist / speed[get] + solve(ans));     if (ans == v)       break;     if (!((int)(g[ans]).size()))       return dp[get];     totalDist += g[ans].back().second;     ans = g[ans].back().first;   }   return dp[get]; }  inline void nbepgpdfgi(int &c) {   cin >> n >> q;   for (int get = (1); get <= (int)(n); ++get)     cin >> dist[get] >> speed[get];   for (int get = (1); get <= (int)(n); ++get)     for (int ans = (1); ans <= (int)(n); ++ans) {       int a;       cin >> a;       if (a != -1)         g[get].push_back(make_pair(ans, a));     }   while (q--) {     cin >> u >> v;     memset(vis, 0, sizeof vis);     cout << "Case #" << c << ": " << fixed << setprecision(6) << solve(u)          << "\n";   }    g.clear(), g.resize(N); }  
int main() {   ios::sync_with_stdio(false);    cin >> t;   for (int c = (1); c <= (int)(t); ++c)     nbepgpdfgi(c);   return 0; } 
#include <bits/stdc++.h> #include <iostream> using namespace std; 
const double EPS = 1e-9;  typedef unsigned long long ull; typedef long double LD; typedef long long ll; typedef pair<int, int> ii; typedef pair<ll, ll> pll; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<ll> vll; typedef set<int> si; typedef map<int, int> mii;  const int N = 102; int t, n, q, dist[N], speed[N], u, v; vector<vector<ii>> g(N); bool vis[N]; double dp[N];  double get(int i) {   if (i == v)     return 0;   if (!((int)(g[i]).size()))     return 1000000000000000000ll;   if (vis[i])     return dp[i];   vis[i] = 1;    dp[i] = 1000000000000000000ll;   double totalDist = g[i].back().second;   int j = g[i].back().first;   while (totalDist <= dist[i]) {     dp[i] = min(dp[i], totalDist / speed[i] + get(j));     if (j == v)       break;     if (!((int)(g[j]).size()))       return dp[i];     totalDist += g[j].back().second;     j = g[j].back().first;   }   return dp[i]; }  inline void cuktvwismk(int &test) {   cin >> u >> v;   memset(vis, 0, sizeof vis);   printf("Case #%d: %.6f\n", test, get(u)); }  inline void holcrqlbfk(int &test) {   cin >> n >> q;   for (int i = (1); i <= (int)(n); ++i)     cin >> dist[i] >> speed[i];   for (int i = (1); i <= (int)(n); ++i)     for (int j = (1); j <= (int)(n); ++j) {       int a;       cin >> a;       if (a != -1)         g[i].push_back(make_pair(j, a));     }   while (q--)     cuktvwismk(test);    g.clear(), g.resize(N); }  
int main() {   ios::sync_with_stdio(false);    cin >> t;   int test;   for (test = (1); test <= (int)(t); ++test)     holcrqlbfk(test);   return 0; }  
#include <bits/stdc++.h> using namespace std; 
typedef long long ll; typedef pair<int, int> pii; typedef pair<ll, ll> pll; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<ll> vll; typedef set<int> si; typedef map<int, int> mii;  const int N = 102; int t, n, q, dist[N], speed[N], u, v; vector<vector<pii>> g(N); bool vis[N]; double dp[N];  double solve(int i) {   if (i == v)     return 0;   if (!((int)(g[i]).size()))     return 1000000000000000000ll;   if (vis[i])     return dp[i];   vis[i] = true;    dp[i] = 1000000000000000000ll;   double totalDist = g[i].back().second;   int j = g[i].back().first;   while (totalDist <= dist[i]) {     dp[i] = min(dp[i], totalDist / speed[i] + solve(j));     if (j == v)       break;     if (!((int)(g[j]).size()))       return dp[i];     totalDist += g[j].back().second;     j = g[j].back().first;   }   return dp[i]; }  inline void dfzkrvfdja(int &i) {   for (int j = (1); j <= (int)(n); ++j) {     int a;     scanf("%d", &a);     if (a != -1)       g[i].push_back(make_pair(j, a));   }   ++i; }  inline void fchxujhnjb() {   int i = (1);   while (i <= (int)(n)) {     dfzkrvfdja(i);   } }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_2_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/KhaleD/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_2_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/KhaleD/outer_temp/KhaleD/A-small-practice_transformation.out",           "w", stdout);   scanf("%d", &t);   for (int test = (1); test <= (int)(t); ++test) {     scanf("%d%d", &n, &q);     for (int i = (1); i <= (int)(n); ++i)       scanf("%d%d", &dist[i], &speed[i]);     fchxujhnjb();     while (q--) {       scanf("%d%d", &u, &v);       memset(vis, 0, sizeof vis);       printf("Case #%d: %.6f\n", test, solve(u));     }      g.clear(), g.resize(N);   }   return 0; } 
#include <bits/stdc++.h> using namespace std; 
const int MAXN = 1005; const int MOD = 1000000007; const long double PI = 3.1415926535897932384626433832795; const int mod = 1000000007; const double eps = 1e-9; const double EPS = 1e-9; typedef long double ld; typedef long long LL; typedef pair<int, int> PII; typedef pair<LL, LL> pll; typedef vector<int> VI; typedef vector<VI> vvi; typedef vector<LL> vll; typedef set<int> si;  const int N = 102; int t, n, q, x[N], speed[N], u, v; vector<vector<PII>> g(N); bool vis[N]; double dp[N];  double get(int i) {   if (i == v)     return 0;   if (!((int)(g[i]).size()))     return 1000000000000000000ll;   if (vis[i])     return dp[i];   vis[i] = true;    dp[i] = 1000000000000000000ll;   double totalDist = g[i].back().second;   int j = g[i].back().first;   while (totalDist <= x[i]) {     dp[i] = min(dp[i], totalDist / speed[i] + get(j));     if (j == v)       break;     if (!((int)(g[j]).size()))       return dp[i];     totalDist += g[j].back().second;     j = g[j].back().first;   }   return dp[i]; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_2_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/KhaleD/A-small-practice.in",           "r", stdin);   scanf("%d", &t);   for (int y = (1); y <= (int)(t); ++y) {     scanf("%d%d", &n, &q);     int i;     for (i = (1); i <= (int)(n); ++i)       scanf("%d%d", &x[i], &speed[i]);     for (int i = (1); i <= (int)(n); ++i)       for (int j = (1); j <= (int)(n); ++j) {         int a;         scanf("%d", &a);         if (a != -1)           g[i].push_back(make_pair(j, a));       }     for (; q--;) {       scanf("%d%d", &u, &v);       memset(vis, 0, sizeof vis);       printf("Case #%d: %.6f\n", y, get(u));     }      g.clear(), g.resize(N);   }   return 0; }  
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
ofstream fout;  typedef set<int> si; typedef vector<int> vi; typedef vector<int> VI; typedef vector<vector<int>> vvi; typedef long double ld; typedef long long ll; typedef long long LL; typedef pair<int, int> pii; typedef pair<int, int> PII; typedef unsigned long long ull;  long long gra[100 + 1][100 + 1]; int lim[100 + 1], spd[100 + 1], vis[100 + 1]; double dis[100 + 1]; int n, q;  double dijkstra(int s, int e) {   int i, j, u;   double get;   memset(vis, 0, sizeof(vis));   fill(dis + 1, dis + n + 1, 1000000000000000000LL);   dis[s] = 0.0;   for (i = 1; i <= n; i++) {     get = 1000000000000000000LL;     u = -1;     for (j = 1; j <= n; j++) {       if ((vis[j] == 0) && (get > dis[j])) {         get = dis[j];         u = j;       }     }     if (u == -1) {       break;     }     vis[u] = 1;     for (j = 1; j <= n; j++) {       if ((lim[u] >= gra[u][j]) &&           (dis[j] > dis[u] + 1.0 * gra[u][j] / spd[u])) {         dis[j] = dis[u] + 1.0 * gra[u][j] / spd[u];       }     }   }   return dis[e]; }  inline void fcpjfbuvyj(int &u, int &v) {   scanf("%d %d", &u, &v);   fout << " " << fixed << setprecision(9) << dijkstra(u, v); }  inline void lamuqzcktz(int &x, int &j, int &c, int &i, int &u, int &v) {   scanf("%d %d", &n, &q);   for (i = 1; i <= n; i++) {     scanf("%d %d", &lim[i], &spd[i]);   }   for (i = 1; i <= n; i++) {     for (j = 1; j <= n; j++) {       scanf("%lld", &gra[i][j]);       if (gra[i][j] == -1) {         gra[i][j] = 1000000000000000000LL;       }     }   }   for (x = 1; x <= n; x++) {     for (i = 1; i <= n; i++) {       for (j = 1; j <= n; j++) {         gra[i][j] = min(gra[i][j], gra[i][x] + gra[x][j]);       }     }   }   fout << "Case #" << c + 1 << ":";   for (i = 0; i < q; i++) {     fcpjfbuvyj(u, v);   }   fout << "\n"; }  
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_3_Usenix_RF_1.0_True_MCTS_Classic_True/bennikartefla/try/outer_temp/try/A-small-practice_transformation.out");    ios::sync_with_stdio(false);    int c, t, i, j, x, u, v;   scanf("%d", &t);   for (c = 0; c < t; c++)     lamuqzcktz(x, j, c, i, u, v);   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <iostream> #include <utility> #include <vector>  using namespace std; 
typedef vector<int> vi; typedef pair<int, int> ii; typedef long long ll; typedef long long LL;  long long gra[100 + 1][100 + 1]; int lim[100 + 1], spd[100 + 1], vis[100 + 1]; double dis[100 + 1]; int n, q;  inline void clqwxpytlg(int &j, int &u) {   dis[j] = dis[u] + 1.0 * gra[u][j] / spd[u]; }  double dijkstra(int s, int e) {   int i, j, u;   double newd;   memset(vis, 0, sizeof(vis));   fill(dis + 1, dis + n + 1, 1000000000000000000LL);   dis[s] = 0.0;   for (i = 1; i <= n; i++) {     newd = 1000000000000000000LL;     u = -1;     for (j = 1; j <= n; j++) {       if ((vis[j] == 0) && (newd > dis[j])) {         newd = dis[j];         u = j;       }     }     if (u == -1) {       break;     }     vis[u] = 1;     for (j = 1; j <= n; j++) {       if ((lim[u] >= gra[u][j]) && (dis[j] > dis[u] + 1.0 * gra[u][j] / spd[u]))         clqwxpytlg(j, u);     }   }   return dis[e]; }  inline void okfucfiqgc(int &i, int &j) { gra[i][j] = 1000000000000000000LL; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_3_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/try/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_3_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/try/outer_temp/try/A-small-practice_transformation.out",           "w", stdout);   int c, tc, i, j, k, u, v;   scanf("%d", &tc);   for (c = 0; c < tc; c++) {     scanf("%d %d", &n, &q);     for (i = 1; i <= n; i++) {       scanf("%d %d", &lim[i], &spd[i]);     }     for (i = 1; i <= n; i++) {       for (j = 1; j <= n; j++) {         scanf("%lld", &gra[i][j]);         if (gra[i][j] == -1)           okfucfiqgc(i, j);       }     }     for (k = 1; k <= n; k++) {       for (i = 1; i <= n; i++) {         for (j = 1; j <= n; j++) {           gra[i][j] = min(gra[i][j], gra[i][k] + gra[k][j]);         }       }     }     printf("Case #%d:", c + 1);     for (i = 0; i < q; i++) {       scanf("%d %d", &u, &v);       printf(" %.9f", dijkstra(u, v));     }     printf("\n");   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cassert> #include <cctype> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <iostream> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <string> #include <utility> #include <vector>  using namespace std; 
const double eps = 1e-9; typedef pair<int, int> PII; typedef unsigned long long ull; typedef vector<int> vi; typedef long double LD; typedef set<int> si; typedef vector<vector<int>> vvi; typedef double td_d;  long long gra[100 + 1][100 + 1]; int lim[100 + 1], spd[100 + 1], vis[100 + 1]; double dis[100 + 1]; int n, q;  inline void usbstcrdvg(int &N, int &u) {   dis[N] = dis[u] + 1.0 * gra[u][N] / spd[u]; }  double T(int s, int e) {   int i, N, u;   td_d newd;   memset(vis, 0, sizeof(vis));   fill(dis + 1, dis + n + 1, 1000000000000000000LL);   dis[s] = 0.0;   for (i = 1; i <= n; i++) {     newd = 1000000000000000000LL;     u = -1;     for (N = 1; N <= n; N++) {       if ((vis[N] == 0) && (newd > dis[N])) {         newd = dis[N];         u = N;       }     }     if (u == -1) {       break;     }     vis[u] = 1;     for (N = 1; N <= n; N++) {       if ((lim[u] >= gra[u][N]))         if ((dis[N] > dis[u] + 1.0 * gra[u][N] / spd[u]))           usbstcrdvg(N, u);     }   }   return dis[e]; }  inline void jeijdxphjz(int &u, int &v) {   scanf("%d %d", &u, &v);   printf(" %.9f", T(u, v)); }  inline void gooncvrqss(int &p, int &N, int &c, int &i, int &u, int &v) {   scanf("%d %d", &n, &q);   for (i = 1; i <= n; i++) {     scanf("%d %d", &lim[i], &spd[i]);   }   {     i = 1;     while (i <= n) {       for (N = 1; N <= n; N++) {         scanf("%lld", &gra[i][N]);         if (gra[i][N] == -1) {           gra[i][N] = 1000000000000000000LL;         }       }       i++;     }   }   for (p = 1; p <= n; p++) {     for (i = 1; i <= n; i++) {       for (N = 1; N <= n; N++) {         gra[i][N] = min(gra[i][N], gra[i][p] + gra[p][N]);       }     }   }   printf("Case #%d:", c + 1);   for (i = 0; i < q; i++)     jeijdxphjz(u, v);   printf("\n"); }  
int main() {   ios::sync_with_stdio(false);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_3_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/try/A-small-practice.in",           "r", stdin);    int c, get, i, N, p, u, v;   scanf("%d", &get);   for (c = 0; c < get; c++)     gooncvrqss(p, N, c, i, u, v);   return 0; }
#include <algorithm> #include <cassert> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility>  using namespace std; 
const int INF = 1000000000;  long long gra[100 + 1][100 + 1]; int lim[100 + 1], spd[100 + 1], vis[100 + 1]; double dis[100 + 1]; int n, q;  double dijkstra(int s, int e) {   int i, j, u;   double newd;   memset(vis, 0, sizeof(vis));   fill(dis + 1, dis + n + 1, 1000000000000000000LL);   dis[s] = 0.0;   for (i = 1; i <= n; i++) {     newd = 1000000000000000000LL;     u = -1;     for (j = 1; j <= n; j++) {       if ((vis[j] == 0) && (newd > dis[j])) {         newd = dis[j];         u = j;       }     }     if (u == -1) {       break;     }     vis[u] = 1;     for (j = 1; j <= n; j++) {       if ((lim[u] >= gra[u][j]) &&           (dis[j] > dis[u] + 1.0 * gra[u][j] / spd[u])) {         dis[j] = dis[u] + 1.0 * gra[u][j] / spd[u];       }     }   }   return dis[e]; }  
int main() {    int c, t, i, j, k, u, v;   cin >> t;   for (c = 0; c < t; c++) {     cin >> n >> q;     for (i = 1; i <= n; i++) {       cin >> lim[i] >> spd[i];     }     for (i = 1; i <= n; i++) {       for (j = 1; j <= n; j++) {         cin >> gra[i][j];         if (gra[i][j] == -1) {           gra[i][j] = 1000000000000000000LL;         }       }     }     for (k = 1; k <= n; k++) {       for (i = 1; i <= n; i++) {         for (j = 1; j <= n; j++) {           gra[i][j] = min(gra[i][j], gra[i][k] + gra[k][j]);         }       }     }     printf("Case #%d:", c + 1);     for (i = 0; i < q; i++) {       cin >> u >> v;       printf(" %.9f", dijkstra(u, v));     }     printf("\n");   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> using namespace std;
typedef double td_d; typedef long long ll;  ofstream fout("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_4_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  const int SZ = 105;  int n, q; ll cost[SZ]; ll hspeed[SZ], hrange[SZ];  inline void jdeupnhuec(int &i, double dprange[105], double &mindp,                        double dp[105], int &j) {   if (dprange[j] >= cost[i - 1])     dp[j] += 1.0 * cost[i - 1] / hspeed[j], dprange[j] -= cost[i - 1];   else     dp[j] = 1e15, dprange[j] = 0;   mindp = min(mindp, dp[j]); }  inline void ptwuavuzhg(double dp[105], double dprange[105], int &i) {   td_d mindp = 1e15;   int j;   for (j = 0; j < i; j++)     jdeupnhuec(i, dprange, mindp, dp, j);   dp[i] = mindp, dprange[i] = hrange[i]; }  inline void pczfiaspzh(int &j, int &i) {   int tmp;   scanf("%d ", &tmp);   if (j == i + 1)     cost[i] = tmp; }  void open() {   scanf("%d %d ", &n, &q);   for (int i = 0; i < n; i++)     scanf("%lld %lld ", &hrange[i], &hspeed[i]);   for (int i = 0; i < n; i++)     for (int j = 0; j < n; j++)       pczfiaspzh(j, i);   for (int i = 0; i < q; i++) {     int a, b;     scanf("%d %d ", &a, &b);   }   double dp[SZ] = {}, dprange[SZ] = {};   dprange[0] = hrange[0];   for (int i = 1; i < n; i++)     ptwuavuzhg(dp, dprange, i);   fout << dp[n - 1] << '\n';   cout << dp[n - 1] << '\n'; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_4_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sammyMaX/A-small-practice.in",           "r", stdin);   cin.tie(0);   fout << fixed << setprecision(12);   int ct;   scanf("%d ", &ct);   for (int i = 0; i < ct; i++)     fout << "Case #" << i + 1 << ": ", open();   return 0; }
#include <bits/stdc++.h> using namespace std; 
const double eps = 1e-9; const int MOD = 1000000007; typedef double td_d;  const double EPS = 1e-9; const int INF = 1000000000;  ifstream T("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_4_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/sammyMaX/A-small-practice.in"); ofstream c("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_4_Usenix_RF_1.0_True_MCTS_Classic_True/okaduki/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  const int SZ = 105;  int n, v; long long cost[SZ]; long long hspeed[SZ], hrange[SZ];  inline void poigrqsxeo(int &N, double dprange[105], td_d &mindp,                        double dp[105]) {   int j = 0;   while (j < N) {     if (dprange[j] >= cost[N - 1])       dp[j] += 1.0 * cost[N - 1] / hspeed[j], dprange[j] -= cost[N - 1];     else       dp[j] = 1e15, dprange[j] = 0;     mindp = min(mindp, dp[j]);     j++;   } }  void d() {   T >> n >> v;   for (int N = 0; N < n; N++)     T >> hrange[N] >> hspeed[N];   int N;   for (N = 0; N < n; N++)     for (int j = 0; j < n; j++) {       int tmp;       T >> tmp;       if (j == N + 1)         cost[N] = tmp;     }   for (int N = 0; N < v; N++) {     int a, b;     T >> a >> b;   }   double dp[SZ] = {}, dprange[SZ] = {};   dprange[0] = hrange[0];   for (int N = 1; N < n; N++) {     td_d mindp = 1e15;     poigrqsxeo(N, dprange, mindp, dp);     dp[N] = mindp, dprange[N] = hrange[N];   }   c << dp[n - 1] << '\n';   cout << dp[n - 1] << '\n'; }  
int main() {   ios_base::sync_with_stdio(0);   cin.tie(0);   c << fixed << setprecision(12);   int get;   T >> get;   for (int N = 0; N < get; N++)     c << "Case #" << N + 1 << ": ", d();   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cassert> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility> using namespace std; 
const int MAXN = 1005; const double EPS = 1e-9; const int mod = 1000000007; const long double PI = 3.1415926535897932384626433832795;  ofstream y("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_4_Usenix_RF_1.0_True_MCTS_Classic_True/kuzphi/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  const int SZ = 105;  int n, q; long long cost[SZ]; long long hspeed[SZ], hrange[SZ];  inline void uukbjhnhqm(int &i, double dprange[105], double &get, double dp[105],                        int &j) {   if (dprange[j] >= cost[i - 1])     dp[j] += 1.0 * cost[i - 1] / hspeed[j], dprange[j] -= cost[i - 1];   else {     dp[j] = 1e15, dprange[j] = 0;   }   get = min(get, dp[j]); }  inline void djkctkaygc() {   int a, b;   scanf("%d %d ", &a, &b); }  inline void wtsgdwsfre(double dp[105], double dprange[105], int &i) {   double get = 1e15;   for (int j = 0; j < i; j++)     uukbjhnhqm(i, dprange, get, dp, j);   dp[i] = get, dprange[i] = hrange[i]; }  void solve() {   scanf("%d %d ", &n, &q);   for (int i = 0; i < n; i++)     scanf("%lld %lld ", &hrange[i], &hspeed[i]);   for (int i = 0; i < n; i++)     for (int j = 0; j < n; j++) {       int tmp;       scanf("%d ", &tmp);       if (j == i + 1)         cost[i] = tmp;     }   for (int i = 0; i < q; i++)     djkctkaygc();   double dp[SZ] = {}, dprange[SZ] = {};   dprange[0] = hrange[0];   for (int i = 1; i < n; i++)     wtsgdwsfre(dp, dprange, i);   y << dp[n - 1] << '\n';   cout << dp[n - 1] << '\n'; }  
int main() {    cin.tie(0);   y << fixed << setprecision(12);   int t;   scanf("%d ", &t);   for (int i = 0; i < t; i++)     y << "Case #" << i + 1 << ": ", solve();   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
typedef long double ld; typedef pair<int, int> ii; typedef unsigned long long ull; typedef vector<int> VI; typedef long double LD; typedef set<int> si; typedef long long ll;  ifstream v("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_4_Usenix_RF_1.0_True_MCTS_Classic_True/ibrahim5253/sammyMaX/A-small-practice.in"); ofstream s("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_4_Usenix_RF_1.0_True_MCTS_Classic_True/ibrahim5253/sammyMaX/outer_temp/sammyMaX/A-small-practice_transformation.out");  const int SZ = 105;  int n, q; ll cost[SZ]; ll hspeed[SZ], hrange[SZ];  inline void ypanlrhuqi(int &i, double dprange[105], double &mindp,                        double dp[105], int &j) {   if (dprange[j] >= cost[i - 1])     dp[j] += 1.0 * cost[i - 1] / hspeed[j], dprange[j] -= cost[i - 1];   else     dp[j] = 1e15, dprange[j] = 0;   mindp = min(mindp, dp[j]); }  inline void murqvzrsii(int &j, int &i) {   int tmp;   v >> tmp;   if (j == i + 1)     cost[i] = tmp; }  inline void imyermdbqt(double dp[105], double dprange[105], int &i) {   double mindp = 1e15;   for (int j = 0; j < i; j++)     ypanlrhuqi(i, dprange, mindp, dp, j);   dp[i] = mindp, dprange[i] = hrange[i]; }  void get() {   v >> n >> q;   for (int i = 0; i < n; i++)     v >> hrange[i] >> hspeed[i];   for (int i = 0; i < n; i++) {     for (int j = 0; j < n; j++)       murqvzrsii(j, i);   }   for (int i = 0; i < q; i++) {     int a, b;     v >> a >> b;   }   double dp[SZ] = {}, dprange[SZ] = {};   dprange[0] = hrange[0];   for (int i = 1; i < n; i++)     imyermdbqt(dp, dprange, i);   s << dp[n - 1] << '\n';   cout << dp[n - 1] << '\n'; }  
int main() {   ios_base::sync_with_stdio(false);   cin.tie(0);   s << fixed << setprecision(12);   int t;   v >> t;   for (int i = 0; i < t; i++)     s << "Case #" << i + 1 << ": ", get();   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
typedef double td_d;  const int N = 110;  int e[N], s[N]; int n; int dt[N]; int sum[N];  struct node {   int v;   double w;   node(int _v = 0, double _w = 0) : v(_v), w(_w) {} };  vector<node> adj[N]; bool vst[N]; double d[N];  void ans() {   int qq;   cin >> n >> qq;   for (int i = 1; i <= n; ++i) {     scanf("%d%d", &e[i], &s[i]);   }   sum[1] = 0;   for (int x, i = 1; i <= n; ++i) {     for (int get = 1; get <= n; ++get) {       scanf("%d", &x);       if (i + 1 == get) {         dt[i + 1] = x;         sum[i + 1] = sum[i] + dt[i + 1];       }     }   }   cin >> qq >> qq;   for (int i = 1; i <= n; ++i)     adj[i].clear();    for (int i = 1; i < n; ++i) {     for (int get = i + 1; get <= n; ++get) {       if (sum[get] - sum[i] <= e[i])         adj[i].push_back(node(get, (double)(sum[get] - sum[i]) / s[i]));       else {         break;       }     }   }   queue<int> q;   q.push(1);   vst[1] = true;   fill(d + 1, d + n + 1, 1e20);   d[1] = 0;   for (; !q.empty();) {     int x = q.front();     q.pop();     vst[x] = false;     for (int i = 0; i < (int)adj[x].size(); ++i) {       int v = adj[x][i].v;       td_d w = adj[x][i].w;       if (d[v] > d[x] + w) {         d[v] = d[x] + w;         if (!vst[v]) {           q.push(v);           vst[v] = true;         }       }     }   }   printf("%.9f\n", d[n]); }  
int main() {   ios::sync_with_stdio(true);    int q;   cin >> q;   for (int i = 1; i <= q; ++i) {     printf("Case #%d: ", i);     ans();   }   return 0; }
#include <algorithm> #include <cassert> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
const int N = 110;  int e[N], s[N]; int n; int dt[N]; int sum[N];  struct node {   int v;   double w;   node(int _v = 0, double _w = 0) : v(_v), w(_w) {} };  vector<node> adj[N]; bool vst[N]; double d[N];  inline void ecmesfiasg(int &i, int &u, queue<int> &q) {   int v = adj[u][i].v;   double w = adj[u][i].w;   if (d[v] > d[u] + w) {     d[v] = d[u] + w;     if (!vst[v]) {       q.push(v);       vst[v] = true;     }   } }  void work() {   int qq;   cin >> n >> qq;   for (int i = 1; i <= n; ++i) {     scanf("%d%d", &e[i], &s[i]);   }   sum[1] = 0;   {     int u, i = 1;     while (i <= n) {       for (int j = 1; j <= n; ++j) {         scanf("%d", &u);         if (i + 1 == j) {           dt[i + 1] = u;           sum[i + 1] = sum[i] + dt[i + 1];         }       }       ++i;     }   }   cin >> qq >> qq;   for (int i = 1; i <= n; ++i) {     adj[i].clear();   }   for (int i = 1; i < n; ++i) {     for (int j = i + 1; j <= n; ++j) {       if (sum[j] - sum[i] <= e[i]) {         adj[i].push_back(node(j, (double)(sum[j] - sum[i]) / s[i]));       } else {         break;       }     }   }   queue<int> q;   q.push(1);   vst[1] = true;   fill(d + 1, d + n + 1, 1e20);   d[1] = 0;   while (!q.empty()) {     int u = q.front();     q.pop();     vst[u] = false;     for (int i = 0; i < (int)adj[u].size(); ++i)       ecmesfiasg(i, u, q);   }   cout << fixed << setprecision(9) << d[n] << endl; }  
int main() {    int q;   cin >> q;   for (int i = 1; i <= q; ++i) {     printf("Case #%d: ", i);     work();   }   return 0; }
#include <algorithm> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <ctime> #include <iomanip> #include <iostream> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
typedef long long ll; typedef pair<int, int> pii; typedef vector<int> vi; typedef vector<int> VI; typedef long double LD; typedef vector<vector<int>> vvi;  const int N = 110;  int e[N], s[N]; int n; int dt[N]; int sum[N];  struct node {   int v;   double w;   node(int _v = 0, double _w = 0) : v(_v), w(_w) {} };  vector<node> adj[N]; bool vst[N]; double d[N];  void work() {   int qq;   cin >> n >> qq;   for (int i = 1; i <= n; ++i) {     cin >> e[i] >> s[i];   }   sum[1] = 0;   for (int t, i = 1; i <= n; ++i) {     for (int j = 1; j <= n; ++j) {       cin >> t;       if (i + 1 == j) {         dt[i + 1] = t;         sum[i + 1] = sum[i] + dt[i + 1];       }     }   }   cin >> qq >> qq;   for (int i = 1; i <= n; ++i) {     adj[i].clear();   }   for (int i = 1; i < n; ++i) {     for (int j = i + 1; j <= n; ++j) {       if (sum[j] - sum[i] <= e[i]) {         adj[i].push_back(node(j, (double)(sum[j] - sum[i]) / s[i]));       } else {         break;       }     }   }   queue<int> q;   q.push(1);   vst[1] = true;   fill(d + 1, d + n + 1, 1e20);   d[1] = 0;   while (!q.empty()) {     int t = q.front();     q.pop();     vst[t] = false;     for (int i = 0; i < (int)adj[t].size(); ++i) {       int v = adj[t][i].v;       double w = adj[t][i].w;       if (d[v] > d[t] + w) {         d[v] = d[t] + w;         if (!vst[v]) {           q.push(v);           vst[v] = true;         }       }     }   }   cout << fixed << setprecision(9) << d[n] << endl; }  
int main() {   ios::sync_with_stdio(true);    int q;   cin >> q;   for (int i = 1; i <= q; ++i) {     printf("Case #%d: ", i);     work();   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cmath> #include <cstdio> #include <iomanip> #include <iostream> #include <map> #include <queue> #include <set> #include <stdio.h> #include <string> #include <vector>  using namespace std; 
const int N = 110;  int e[N], ans[N]; int n; int dt[N]; int sum[N];  struct node {   int v;   double w;   node(int _v = 0, double _w = 0) : v(_v), w(_w) {} };  vector<node> adj[N]; bool vst[N]; double d[N];  void work() {   int qq;   cin >> n >> qq;   {     int i = 1;     while (i <= n) {       cin >> e[i] >> ans[i];       ++i;     }   }   sum[1] = 0;   for (int m, i = 1; i <= n; ++i) {     for (int r = 1; r <= n; ++r) {       cin >> m;       if (i + 1 == r) {         dt[i + 1] = m;         sum[i + 1] = sum[i] + dt[i + 1];       }     }   }   cin >> qq >> qq;   for (int i = 1; i <= n; ++i) {     adj[i].clear();   }    for (int i = 1; i < n; ++i) {     for (int r = i + 1; r <= n; ++r) {       if (sum[r] - sum[i] <= e[i]) {         adj[i].push_back(node(r, (double)(sum[r] - sum[i]) / ans[i]));       } else {         break;       }     }   }   queue<int> hmxq_Var;   hmxq_Var.push(1);   vst[1] = true;   fill(d + 1, d + n + 1, 1e20);   d[1] = 0;   while (!hmxq_Var.empty()) {     int m = hmxq_Var.front();     hmxq_Var.pop();     vst[m] = false;     for (int i = 0; i < (int)adj[m].size(); ++i) {       int cas = adj[m][i].v;       double w = adj[m][i].w;       if (d[cas] > d[m] + w) {         d[cas] = d[m] + w;         if (!vst[cas]) {           hmxq_Var.push(cas);           vst[cas] = true;         }       }     }   }   printf("%.9f\n", d[n]); }  inline void domhvpzzdq(int &hmxq_Var) {   int i = 1;   for (; i <= hmxq_Var;) {     printf("Case #%d: ", i);     work();     ++i;   } }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_5_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/Tashi711/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_5_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/Tashi711/outer_temp/Tashi711/A-small-practice_transformation.out",           "w", stdout);    int hmxq_Var;   cin >> hmxq_Var;   domhvpzzdq(hmxq_Var);   return 0; }
#include <algorithm> #include <bitset> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility> #include <vector> using namespace std; 
int n, q, u, v; long long e[102]; double s[102]; long long d[102][102]; double bt[102]; bool vi[102];  
int main() {   int tt;    cin >> tt;    for (int t = 1; t <= tt; ++t) {     cin >> n >> q;     for (int i = 1; i <= n; ++i)       cin >> e[i] >> s[i];     for (int i = 1; i <= n; ++i)       for (int j = 1; j <= n; ++j)         cin >> d[i][j];      for (int k = 1; k <= n; ++k)       for (int i = 1; i <= n; ++i)         for (int j = 1; j <= n; ++j)           if ((d[i][k] != -1) && (d[k][j] != -1) &&               ((d[i][j] == -1) || (d[i][j] > d[i][k] + d[k][j])))             d[i][j] = d[i][k] + d[k][j];      printf("Case #%d:", t);      for (int i = 0; i < q; ++i) {       cin >> u >> v;       for (int j = 1; j <= n; ++j) {         bt[j] = -1;         vi[j] = false;       }       bt[u] = 0;       while (!vi[v]) {         int cur = -1;         for (int j = 1; j <= n; ++j)           if (!vi[j] && (bt[j] != -1) && ((cur == -1) || (bt[cur] > bt[j])))             cur = j;         vi[cur] = true;         for (int j = 1; j <= n; ++j)           if ((d[cur][j] != -1) && (d[cur][j] <= e[cur]) &&               ((bt[j] == -1) || ((bt[j] - bt[cur]) * s[cur] > d[cur][j])))             bt[j] = bt[cur] + d[cur][j] / s[cur];       }       printf(" %.6lf", bt[v]);     }     printf("\n");   }    return 0; }
#include <algorithm> #include <cassert> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <fstream> #include <iostream> #include <iterator> #include <list> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility> #include <vector> using namespace std;
typedef long double ld; typedef long long ll; typedef long long LL; typedef pair<int, int> ii; typedef pair<int, int> pii;  int n, q, u, v; long long e[102]; double s[102]; long long d[102][102]; double bt[102]; bool vi[102];  
int main() {   ios::sync_with_stdio(true);    int r;    cin >> r;    for (int t = 1; t <= r; ++t) {     cin >> n >> q;     for (int i = 1; i <= n; ++i)       cin >> e[i] >> s[i];     for (int i = 1; i <= n; ++i)       for (int j = 1; j <= n; ++j)         cin >> d[i][j];      for (int k = 1; k <= n; ++k)       for (int i = 1; i <= n; ++i)         for (int j = 1; j <= n; ++j)           if ((d[i][k] != -1) && (d[k][j] != -1) &&               ((d[i][j] == -1) || (d[i][j] > d[i][k] + d[k][j])))             d[i][j] = d[i][k] + d[k][j];      cout << "Case #" << t << ":";      for (int i = 0; i < q; ++i) {       cin >> u >> v;       for (int j = 1; j <= n; ++j) {         bt[j] = -1;         vi[j] = false;       }       bt[u] = 0;       while (!vi[v]) {         int cur = -1;         for (int j = 1; j <= n; ++j)           if (!vi[j] && (bt[j] != -1) && ((cur == -1) || (bt[cur] > bt[j])))             cur = j;         vi[cur] = true;         for (int j = 1; j <= n; ++j)           if ((d[cur][j] != -1) && (d[cur][j] <= e[cur]) &&               ((bt[j] == -1) || ((bt[j] - bt[cur]) * s[cur] > d[cur][j])))             bt[j] = bt[cur] + d[cur][j] / s[cur];       }       printf(" %.6lf", bt[v]);     }     cout << endl;   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <iostream> #include <stdio.h> #include <string> #include <vector> using namespace std;
int n, q, u, v; long long e[102]; double s[102]; long long d[102][102]; double bt[102]; bool vi[102];  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_6_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/WCG/outer_temp/WCG/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_6_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/WCG/A-small-practice.in",           "r", stdin);    int tt;    cin >> tt;    for (int t = 1; t <= tt; ++t) {     cin >> n >> q;     for (int i = 1; i <= n; ++i)       cin >> e[i] >> s[i];     for (int i = 1; i <= n; ++i)       for (int j = 1; j <= n; ++j)         cin >> d[i][j];      {       int k = 1;       while (k <= n) {         for (int i = 1; i <= n; ++i)           for (int j = 1; j <= n; ++j)             if ((d[i][k] != -1) && (d[k][j] != -1) &&                 ((d[i][j] == -1) || (d[i][j] > d[i][k] + d[k][j])))               d[i][j] = d[i][k] + d[k][j];         ++k;       }     }      printf("Case #%d:", t);      for (int i = 0; i < q; ++i) {       cin >> u >> v;       for (int j = 1; j <= n; ++j) {         bt[j] = -1;         vi[j] = false;       }       bt[u] = 0;       while (!vi[v]) {         int cur = -1;         for (int j = 1; j <= n; ++j)           if (!vi[j] && (bt[j] != -1) && ((cur == -1) || (bt[cur] > bt[j])))             cur = j;         vi[cur] = true;         for (int j = 1; j <= n; ++j)           if ((d[cur][j] != -1) && (d[cur][j] <= e[cur]) &&               ((bt[j] == -1) || ((bt[j] - bt[cur]) * s[cur] > d[cur][j])))             bt[j] = bt[cur] + d[cur][j] / s[cur];       }       printf(" %.6lf", bt[v]);     }     printf("\n");   }    return 0; }
#include <algorithm> #include <cstdio> #include <cstring> #include <iostream> #include <stdio.h> #include <string> #include <vector> using namespace std; 
int n, q, u, v; long long e[102]; double s[102]; long long d[102][102]; double bt[102]; bool vi[102];  
int main() {   int tt;    scanf("%d ", &tt);    int t;   for (t = 1; t <= tt; ++t) {     scanf("%d %d ", &n, &q);     for (int ans = 1; ans <= n; ++ans)       scanf("%lld %lf ", &e[ans], &s[ans]);     for (int ans = 1; ans <= n; ++ans)       for (int j = 1; j <= n; ++j)         scanf("%lld ", &d[ans][j]);      for (int k = 1; k <= n; ++k)       for (int ans = 1; ans <= n; ++ans)         for (int j = 1; j <= n; ++j)           if ((d[ans][k] != -1) && (d[k][j] != -1) &&               ((d[ans][j] == -1) || (d[ans][j] > d[ans][k] + d[k][j])))             d[ans][j] = d[ans][k] + d[k][j];      printf("Case #%d:", t);      for (int ans = 0; ans < q; ++ans) {       scanf("%d %d ", &u, &v);       for (int j = 1; j <= n; ++j) {         bt[j] = -1;         vi[j] = false;       }       bt[u] = 0;       while (!vi[v]) {         int cur = -1;         for (int j = 1; j <= n; ++j)           if (!vi[j] && (bt[j] != -1) && ((cur == -1) || (bt[cur] > bt[j])))             cur = j;         vi[cur] = 1;         for (int j = 1; j <= n; ++j)           if ((d[cur][j] != -1) && (d[cur][j] <= e[cur]) &&               ((bt[j] == -1) || ((bt[j] - bt[cur]) * s[cur] > d[cur][j])))             bt[j] = bt[cur] + d[cur][j] / s[cur];       }       printf(" %.6lf", bt[v]);     }     printf("\n");   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const int mod = 1000000007;  typedef pair<int, int> ii;  typedef long long ll; const long double INF = 1000000000000;  typedef pair<long double, int> di;  int mxdist[120]; int conspeed[120]; long double matrix[120][120]; long double matrix2[120][120];  void fill(int tc) {   bool vis[120];   memset(vis, 0, sizeof(vis));   vis[tc] = true;   priority_queue<pair<long double, int>, vector<di>, greater<di>> q;   q.push(pair<long double, int>(0, tc));   for (; !q.empty();) {     int cur = q.top().second;     long double range = q.top().first;     q.pop();     for (int i = (0); i < (120); i++) {       if (matrix[cur][i] != -1 && i != cur && !vis[i]) {         long double thedist = matrix[cur][i];         range += thedist;         if (range > mxdist[tc]) {           range -= thedist;           continue;         }         matrix2[tc][i] = min(range / conspeed[tc], matrix2[tc][i]);         q.push(pair<long double, int>(range, i));         range -= thedist;       }     }   } }  long double query(int start, int end) {   priority_queue<di, vector<di>, greater<di>> pq;   pq.push(di(0, start));   long double dist[150];   bool vis[150];   for (int i = (0); i < (150); i++)     dist[i] = INF;   memset(vis, 0, sizeof(vis));   dist[start] = 0;   while (!pq.empty()) {     di cur = pq.top();     pq.pop();     int i;     for (i = (0); i < (120); i++) {       if (matrix2[cur.second][i] != -1) {         long double ne = min(dist[i], cur.first + matrix2[cur.second][i]);         if (ne >= dist[i])           continue;         dist[i] = ne;         pq.push(di(dist[i], i));       }     }   }   return dist[end]; }  inline void esdibowtrq(int &i) {   int dist, speed;   cin >> dist >> speed;   mxdist[i] = dist;   conspeed[i] = speed; }  
int main() {   cin.sync_with_stdio(0);    int t;   cin >> t;   for (int u = (0); u < (t); u++) {     int n, q;     memset(mxdist, 0, sizeof(mxdist));     memset(conspeed, 0, sizeof(conspeed));     int i;     for (i = (0); i < (120); i++)       for (int a = (0); a < (120); a++)         matrix[i][a] = -1;     for (int i = (0); i < (120); i++)       for (int a = (0); a < (120); a++)         matrix2[i][a] = INF;     cin >> n >> q;     for (int i = (0); i < (n); i++)       esdibowtrq(i);     for (int i = (0); i < (n); i++)       for (int a = (0); a < (n); a++)         cin >> matrix[i][a];     for (int i = (0); i < (n); i++)       fill(i);      for (int i = (0); i < (120); i++)       for (int a = (0); a < (120); a++)         if (matrix2[i][a] == INF)           matrix2[i][a] = -1;     vector<ii> all(q);     for (int i = (0); i < (q); i++)       cin >> all[i].first >> all[i].second;     cout << "Case #" << u + 1 << ": ";     for (int i = (0); i < (q); i++) {       cout << setprecision(9) << fixed            << query(all[i].first - 1, all[i].second - 1) << " ";     }     cout << endl;   }   return 0; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> #include <vector> using namespace std; 
typedef long double td_ld; typedef pair<int, int> ii; typedef vector<int> vi; typedef vector<ii> vii; typedef long long ll; const long double INF = 1000000000000;  typedef pair<long double, int> di;  int mxdist[120]; int conspeed[120]; long double matrix[120][120]; long double matrix2[120][120];  void fill(int cas) {   bool vis[120];   memset(vis, 0, sizeof(vis));   vis[cas] = true;   priority_queue<pair<long double, int>, vector<di>, greater<di>> q;   q.push(pair<long double, int>(0, cas));   while (!q.empty()) {     int cur = q.top().second;     td_ld range = q.top().first;     q.pop();     for (int i = (0); i < (120); i++) {       if (matrix[cur][i] != -1)         if (i != cur)           if (!vis[i]) {             td_ld thedist = matrix[cur][i];             range += thedist;             if (range > mxdist[cas]) {               range -= thedist;               continue;             }             matrix2[cas][i] = min(range / conspeed[cas], matrix2[cas][i]);             q.push(pair<long double, int>(range, i));             range -= thedist;           }     }   } }  long double query(int start, int end) {   priority_queue<di, vector<di>, greater<di>> pq;   pq.push(di(0, start));   vector<long double> dist(150);   bool vis[150];   for (int i = (0); i < (150); i++)     dist[i] = INF;   memset(vis, 0, sizeof(vis));   dist[start] = 0;   while (!pq.empty()) {     di cur = pq.top();     pq.pop();     for (int i = (0); i < (120); i++) {       if (matrix2[cur.second][i] != -1) {         td_ld ne = min(dist[i], cur.first + matrix2[cur.second][i]);         if (ne >= dist[i])           continue;         dist[i] = ne;         pq.push(di(dist[i], i));       }     }   }   return dist[end]; }  inline void xrtatfungp() {   int i = (0);   while (i < (120)) {     for (int m = (0); m < (120); m++)       if (matrix2[i][m] == INF)         matrix2[i][m] = -1;     i++;   } }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_7_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_7_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/bennikartefla/A-small-practice.in",           "r", stdin);    int r;   cin >> r;   for (int u = (0); u < (r); u++) {     int n, q;     memset(mxdist, 0, sizeof(mxdist));     memset(conspeed, 0, sizeof(conspeed));     int i;     for (i = (0); i < (120); i++)       for (int m = (0); m < (120); m++)         matrix[i][m] = -1;     for (int i = (0); i < (120); i++)       for (int m = (0); m < (120); m++)         matrix2[i][m] = INF;     cin >> n >> q;     for (int i = (0); i < (n); i++) {       int dist, speed;       cin >> dist >> speed;       mxdist[i] = dist;       conspeed[i] = speed;     }     for (int i = (0); i < (n); i++)       for (int m = (0); m < (n); m++)         cin >> matrix[i][m];     for (int i = (0); i < (n); i++)       fill(i);     xrtatfungp();     vector<ii> all(q);     for (int i = (0); i < (q); i++)       cin >> all[i].first >> all[i].second;     printf("Case #%d: ", u + 1);     for (int i = (0); i < (q); i++) {       cout << setprecision(9) << fixed            << query(all[i].first - 1, all[i].second - 1) << " ";     }     printf("\n");   }   return 0; }
#include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <stdio.h> #include <vector> using namespace std; 
typedef pair<int, int> ii;  typedef vector<ii> vii; typedef long long ll; const long double INF = 1000000000000;  typedef pair<long double, int> di;  int mxdist[120]; int conspeed[120]; long double matrix[120][120]; long double matrix2[120][120];  void fill(int at) {   bool vis[120];   memset(vis, 0, sizeof(vis));   vis[at] = 1;   priority_queue<pair<long double, int>, vector<di>, greater<di>> q;   q.push(pair<long double, int>(0, at));   while (!q.empty()) {     int cur = q.top().second;     long double range = q.top().first;     q.pop();     for (int i = (0); i < (120); i++) {       if (matrix[cur][i] != -1 && i != cur && !vis[i]) {         long double thedist = matrix[cur][i];         range += thedist;         if (range > mxdist[at]) {           range -= thedist;           continue;         }         matrix2[at][i] = min(range / conspeed[at], matrix2[at][i]);         q.push(pair<long double, int>(range, i));         range -= thedist;       }     }   } }  long double query(int start, int end) {   priority_queue<di, vector<di>, greater<di>> pq;   pq.push(di(0, start));   vector<long double> dist(150);   bool vis[150];   for (int i = (0); i < (150); i++)     dist[i] = INF;   memset(vis, 0, sizeof(vis));   dist[start] = 0;   for (; !pq.empty();) {     di cur = pq.top();     pq.pop();     for (int i = (0); i < (120); i++) {       if (matrix2[cur.second][i] != -1) {         long double ne = min(dist[i], cur.first + matrix2[cur.second][i]);         if (ne >= dist[i])           continue;         dist[i] = ne;         pq.push(di(dist[i], i));       }     }   }   return dist[end]; }  inline void etvoezwtfk(int &i) {   int dist, speed;   scanf("%d %d ", &dist, &speed);   mxdist[i] = dist;   conspeed[i] = speed; }  inline void osvavuaydv(std::ofstream &fout, vector<ii> &all, int &i) {   fout << setprecision(9) << fixed << query(all[i].first - 1, all[i].second - 1)        << " "; }  inline void ceuejvyppf(int &tt, int &i) {   for (int ans = (0); ans < (tt); ans++)     cin >> matrix[i][ans];   i++; }  inline void jmkyrynxjq(int &tt) {   int i = (0);   while (i < (tt))     ceuejvyppf(tt, i); }  inline void bzjaflbcac(int &u, std::ofstream &fout) {   int tt, q;   memset(mxdist, 0, sizeof(mxdist));   memset(conspeed, 0, sizeof(conspeed));   for (int i = (0); i < (120); i++)     for (int ans = (0); ans < (120); ans++)       matrix[i][ans] = -1;   for (int i = (0); i < (120); i++)     for (int ans = (0); ans < (120); ans++)       matrix2[i][ans] = INF;   scanf("%d %d ", &tt, &q);   int i;   for (i = (0); i < (tt); i++)     etvoezwtfk(i);   jmkyrynxjq(tt);   for (int i = (0); i < (tt); i++)     fill(i);   for (int i = (0); i < (120); i++)     for (int ans = (0); ans < (120); ans++)       if (matrix2[i][ans] == INF)         matrix2[i][ans] = -1;   vector<ii> all(q);   for (int i = (0); i < (q); i++)     cin >> all[i].first >> all[i].second;   fout << "Case #" << u + 1 << ": ";   for (int i = (0); i < (q); i++)     osvavuaydv(fout, all, i);   fout << endl; }  
int main() {    ofstream fout("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_7_Usenix_RF_1.0_True_MCTS_Classic_True/iPeter/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out");   int t;   scanf("%d ", &t);   for (int u = (0); u < (t); u++)     bzjaflbcac(u, fout);   return 0; }
#include <bits/stdc++.h> #include <iostream> using namespace std;
const double eps = 1e-9; const double EPS = 1e-9; const int MOD = 1000000007; const int mod = 1000000007;  typedef long double td_ld; typedef pair<int, int> ii; typedef vector<int> vi; typedef vector<ii> vii; typedef long long ll; const long double INF = 1000000000000; const long double pi = acos(-1); typedef pair<long double, int> di;  int mxdist[120]; int conspeed[120]; long double matrix[120][120]; long double matrix2[120][120];  void fill(int v) {   bool vis[120];   memset(vis, 0, sizeof(vis));   vis[v] = true;   priority_queue<pair<long double, int>, vector<di>, greater<di>> q;   q.push(pair<long double, int>(0, v));   for (; !q.empty();) {     int cur = q.top().second;     td_ld range = q.top().first;     q.pop();     for (int i = (0); i < (120); i++) {       if (matrix[cur][i] != -1 && i != cur && !vis[i]) {         td_ld thedist = matrix[cur][i];         range += thedist;         if (range > mxdist[v]) {           range -= thedist;           continue;         }         matrix2[v][i] = min(range / conspeed[v], matrix2[v][i]);         q.push(pair<long double, int>(range, i));         range -= thedist;       }     }   } }  long double query(int start, int end) {   priority_queue<di, vector<di>, greater<di>> pq;   pq.push(di(0, start));   long double dist[150];   bool vis[150];   for (int i = (0); i < (150); i++)     dist[i] = INF;   memset(vis, 0, sizeof(vis));   dist[start] = 0;   for (; !pq.empty();) {     di cur = pq.top();     pq.pop();     int i;     for (i = (0); i < (120); i++) {       if (matrix2[cur.second][i] != -1) {         td_ld ne = min(dist[i], cur.first + matrix2[cur.second][i]);         if (ne >= dist[i])           continue;         dist[i] = ne;         pq.push(di(dist[i], i));       }     }   }   return dist[end]; }  
int main() {    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_7_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/bennikartefla/outer_temp/bennikartefla/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_7_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/bennikartefla/A-small-practice.in",           "r", stdin);    int t;   cin >> t;   for (int c = (0); c < (t); c++) {     int n, q;     memset(mxdist, 0, sizeof(mxdist));     memset(conspeed, 0, sizeof(conspeed));     for (int i = (0); i < (120); i++)       for (int a = (0); a < (120); a++)         matrix[i][a] = -1;     for (int i = (0); i < (120); i++)       for (int a = (0); a < (120); a++)         matrix2[i][a] = INF;     cin >> n >> q;     for (int i = (0); i < (n); i++) {       int dist, speed;       cin >> dist >> speed;       mxdist[i] = dist;       conspeed[i] = speed;     }     for (int i = (0); i < (n); i++)       for (int a = (0); a < (n); a++)         cin >> matrix[i][a];     for (int i = (0); i < (n); i++)       fill(i);     for (int i = (0); i < (120); i++)       for (int a = (0); a < (120); a++) {         if (matrix2[i][a] == INF)           matrix2[i][a] = -1;       }     vector<ii> all(q);     for (int i = (0); i < (q); i++)       cin >> all[i].first >> all[i].second;     cout << "Case #" << c + 1 << ": ";     for (int i = (0); i < (q); i++) {       cout << setprecision(9) << fixed            << query(all[i].first - 1, all[i].second - 1) << " ";     }     cout << endl;   }   return 0; }
#include <bits/stdc++.h> #include <iostream> using namespace std; 
typedef double td_d; typedef pair<int, int> ii; typedef vector<ii> vii;  void open() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_8_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/ccsnoopy/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_8_Usenix_RF_1.0_True_MCTS_Classic_True/jiian/ccsnoopy/outer_temp/ccsnoopy/A-small-practice_transformation.out",           "w", stdout); } int n, q, fr, to; int energy[120]; int spd[120]; int dist[120][120]; map<pair<ii, int>, double> memo;  double dp(int idx, int pony, int left) {   pair<ii, int> z = make_pair(ii(idx, pony), left);   if (idx == to)     return 0;   if (memo.find(z) != memo.end())     if (memo[z] < 1e12)       return memo[z];    td_d ans = 1e12;    if (dist[idx][idx + 1] <= left) {     ans = min(dp(idx + 1, pony, left - dist[idx][idx + 1]) +                   1.0 * dist[idx][idx + 1] / spd[pony],               ans);   }    if (dist[idx][idx + 1] <= energy[idx]) {     ans = min(ans, dp(idx + 1, idx, energy[idx] - dist[idx][idx + 1]) +                        1.0 * dist[idx][idx + 1] / spd[idx]);   }   return memo[z] = ans; }  inline void uqgnytjaty(int &i) {   cin >> energy[i];   cin >> spd[i];   i++; }  
int main(void) {   open();   int r;   cin >> r;    {     int cas = 1;     while (cas <= r) {       cin >> n;       cin >> q;        int i;       {         i = 0;         while (i < n)           uqgnytjaty(i);       }        {         int i = 0;         while (i < n) {           for (int m = 0; m < n; m++)             cin >> dist[i][m];            i++;         }       }        cin >> fr;       cin >> to;       fr--;       to--;       memo.clear();        printf("Case #%d: %.10lf\n", cas, dp(0, 0, energy[0]));        cerr << "Test " << cas << " done \n";       cas++;     }   }   return 0; }
#include <bits/stdc++.h> #include <cstdio> #include <cstring> using namespace std; 
typedef long long LL; typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<int> vi; typedef pair<ii, int> iii; void open() {} int n, q, fr, to; int energy[120]; int spd[120]; int dist[120][120]; map<iii, double> memo;  double dp(int idx, int pony, int left) {   iii z = make_pair(ii(idx, pony), left);   if (idx == to)     return 0;   if (memo.find(z) != memo.end()) {     if (memo[z] < 1e12)       return memo[z];   }    double ans = 1e12;    if (dist[idx][idx + 1] <= left) {     ans = min(dp(idx + 1, pony, left - dist[idx][idx + 1]) +                   1.0 * dist[idx][idx + 1] / spd[pony],               ans);   }    if (dist[idx][idx + 1] <= energy[idx]) {     ans = min(ans, dp(idx + 1, idx, energy[idx] - dist[idx][idx + 1]) +                        1.0 * dist[idx][idx + 1] / spd[idx]);   }   return memo[z] = ans; }  
int main(void) {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_8_Usenix_RF_1.0_True_MCTS_Classic_True/iPeter/ccsnoopy/A-small-practice.in", "r", stdin);    open();   int t;   scanf("%d", &t);    {     int ct = 1;     while (ct <= t) {       scanf("%d", &n);       scanf("%d", &q);        for (int i = 0; i < n; i++) {         scanf("%d", &energy[i]);         scanf("%d", &spd[i]);       }        for (int i = 0; i < n; i++) {         for (int j = 0; j < n; j++) {           scanf("%d", &dist[i][j]);         }       }        scanf("%d", &fr);       scanf("%d", &to);       fr--;       to--;       memo.clear();        printf("Case #%d: %.10lf\n", ct, dp(0, 0, energy[0]));        cerr << "Test " << ct << " done \n";       ct++;     }   }   return 0; }
#include <bits/stdc++.h> #include <iostream> using namespace std;
typedef double td_d; typedef long long ll; typedef long long LL; typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<int> vi; typedef pair<ii, int> iii; void get() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_8_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/ccsnoopy/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_8_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/ccsnoopy/outer_temp/ccsnoopy/A-small-practice_transformation.out",           "w", stdout); } int n, q, fr, to; int energy[120]; int spd[120]; int dist[120][120]; map<iii, double> memo;  double dp(int v, int pony, int left) {   iii z = make_pair(ii(v, pony), left);   if (v == to)     return 0;   if (memo.find(z) != memo.end())     if (memo[z] < 1e12)       return memo[z];    td_d ans = 1e12;    if (dist[v][v + 1] <= left) {     ans = min(dp(v + 1, pony, left - dist[v][v + 1]) +                   1.0 * dist[v][v + 1] / spd[pony],               ans);   }    if (dist[v][v + 1] <= energy[v]) {     ans = min(ans, dp(v + 1, v, energy[v] - dist[v][v + 1]) +                        1.0 * dist[v][v + 1] / spd[v]);   }   return memo[z] = ans; }  
int main(void) {   ios::sync_with_stdio(false);    get();   int tc;   cin >> tc;    {     int x = 1;     while (x <= tc) {       cin >> n;       cin >> q;        {         int i = 0;         while (i < n) {           cin >> energy[i];           cin >> spd[i];           i++;         }       }        for (int i = 0; i < n; i++) {         {           int j = 0;           while (j < n) {             cin >> dist[i][j];             j++;           }         }       }        cin >> fr;       cin >> to;       fr--;       to--;       memo.clear();        printf("Case #%d: %.10lf\n", x, dp(0, 0, energy[0]));        cerr << "Test " << x << " done \n";       x++;     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cctype> #include <climits> #include <complex> #include <cstdio> #include <cstdlib> #include <ctime> #include <fstream> #include <functional> #include <iostream> #include <list> #include <numeric> #include <sstream> #include <stdlib.h> #include <string> #include <unordered_map> #include <vector> using namespace std; 
ifstream fin;  typedef double td_d; typedef long long LL; typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<int> vi;  void open() {} int n, q, fr, to; int energy[120]; int spd[120]; int dist[120][120]; map<pair<ii, int>, double> memo;  double dp(int r, int pony, int left) {   pair<ii, int> z = make_pair(ii(r, pony), left);   if (r == to)     return 0;   if (memo.find(z) != memo.end())     if (memo[z] < 1e12)       return memo[z];    td_d ans = 1e12;    if (dist[r][r + 1] <= left) {     ans = min(dp(r + 1, pony, left - dist[r][r + 1]) +                   1.0 * dist[r][r + 1] / spd[pony],               ans);   }    if (dist[r][r + 1] <= energy[r]) {     ans = min(ans, dp(r + 1, r, energy[r] - dist[r][r + 1]) +                        1.0 * dist[r][r + 1] / spd[r]);   }   return memo[z] = ans; } 
int main(void) {   fin.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_8_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ccsnoopy/A-small-practice.in");    int ret_val = 0;   open();   int t;   fin >> t;   {     int x = 1;     while (x <= t) {       fin >> n;       fin >> q;        for (int i = 0; i < n; i++) {         fin >> energy[i];         fin >> spd[i];       }        {         int i = 0;         for (; i < n;) {           for (int j = 0; j < n; j++) {             fin >> dist[i][j];           }           i++;         }       }        fin >> fr;       fin >> to;       fr--;       to--;       memo.clear();        printf("Case #%d: %.10lf\n", x, dp(0, 0, energy[0]));        cerr << "Test " << x << " done \n";       x++;     }   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <stdio.h> #include <vector> using namespace std;  
using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &is, pair<S, T> &p) {   return is >> p.first >> p.second; } template <class S, class T> ostream &do_stdvlj_fct(ostream &os, const pair<S, T> &p) {   return os << p.first << " " << p.second; } template <class T> void maxi(T &x, T y) {   if (x < y)     x = y; } template <class T> void do_voillr_fct(T &x, T y) {   if (x > y)     x = y; }  const double EPS = 1e-10; const double PI = acos(-1.0); const LL MOD = 1e9 + 7; const double INF = 1e15; 
int main() {    cin.tie(0);    int t;   scanf("%d ", &t);   for (int t_ = (1); t_ < (t + 1); ++t_) {     int N, Q;     scanf("%d %d ", &N, &Q);     vector<PLL> es(N);     int tt;     for (tt = (0); tt < (N); ++tt)       cin >> es[tt];      VVL dist(N, VL(N));     for (int tt = (0); tt < (N); ++tt)       for (int s = (0); s < (N); ++s)         cin >> dist[tt][s];      for (; Q--;) {       int U, V;       scanf("%d %d ", &U, &V);       --U;       --V;        vector<LL> acc(N);       for (int tt = N - 2; tt >= 0; --tt)         acc[tt] = dist[tt][tt + 1] + acc[tt + 1];        vector<double> dp(N + 1, INF);       dp[N - 1] = 0;       for (int tt = N - 2; tt >= 0; --tt) {         for (int s = tt + 1; s < N; ++s) {           if (acc[tt] - acc[s] > es[tt].first)             break;           do_voillr_fct(dp[tt],                         dp[s] + (acc[tt] - acc[s]) * 1. / es[tt].second);         }       }       double ans = dp[0];       printf("Case #%d: %.9f\n", t_, ans);     }   }    return 0; }
#include <bits/stdc++.h> #include <iostream> #include <set> #include <utility> #include <vector> using namespace std;  
typedef set<int> si;  typedef double td_d; typedef long long ll; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef unsigned long long ull;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &t, pair<S, T> &p) {   return t >> p.first >> p.second; } template <class S, class T> ostream &operator<<(ostream &v, const pair<S, T> &p) {   return v << p.first << " " << p.second; }  template <class T> void mini(T &x, T y) {   if (x > y) {     x = y;   } }  const double EPS = 1e-10; const double PI = acos(-1.0); const LL MOD = 1e9 + 7; const double INF = 1e15;  
int main() {   ios::sync_with_stdio(false);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_9_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/okaduki/A-small-practice.in",           "r", stdin);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_9_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/okaduki/outer_temp/okaduki/A-small-practice_transformation.out",           "w", stdout);    cin.tie(0);    int d;   cin >> d;   for (int a = (1); a < (d + 1); ++a) {     int N, Q;     cin >> N >> Q;     vector<PLL> es(N);     for (int i = (0); i < (N); ++i)       cin >> es[i];      VVL dist(N, VL(N));     for (int i = (0); i < (N); ++i)       for (int j = (0); j < (N); ++j)         cin >> dist[i][j];      while (Q--) {       int U, V;       cin >> U >> V;       --U;       --V;        vector<LL> acc(N);       for (int i = N - 2; i >= 0; --i)         acc[i] = dist[i][i + 1] + acc[i + 1];        vector<double> dp(N + 1, INF);       dp[N - 1] = 0;       for (int i = N - 2; i >= 0; --i) {         for (int j = i + 1; j < N; ++j) {           if (acc[i] - acc[j] > es[i].first)             break;           mini(dp[i], dp[j] + (acc[i] - acc[j]) * 1. / es[i].second);         }       }       td_d ans = dp[0];       cout << "Case #" << a << ": " << fixed << setprecision(9) << ans << endl;     }   }    return 0; }
#include <bits/stdc++.h> #include <fstream> #include <utility> #include <vector> using namespace std;
const double EPS = 1e-9;  typedef unsigned long long ull; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef vector<int> vi; typedef vector<vector<int>> vvi;  ifstream fin;  ofstream fout;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &t, pair<S, T> &p) {   return t >> p.first >> p.second; } template <class S, class T> ostream &solve(ostream &os, const pair<S, T> &p) {   return os << p.first << " " << p.second; } template <class T> void get(T &x, T y) {   if (x < y)     x = y; } template <class T> void do_voiapa_fct(T &x, T y) {   if (x > y)     x = y; }  const double INF = 1e15;  inline void ixrczvjthc(vector<PLL> &es, int &i) { fin >> es[i]; }  
int main() {   fin.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_9_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/okaduki/A-small-practice.in");    fout.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_9_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/okaduki/outer_temp/okaduki/A-small-practice_transformation.out");    cin.tie(0);    int T;   fin >> T;   for (int t_ = (1); t_ < (T + 1); ++t_) {     int N, Q;     fin >> N >> Q;     vector<PLL> es(N);     for (int i = (0); i < (N); ++i)       ixrczvjthc(es, i);      VVL dist(N, VL(N));     {       int i = (0);       while (i < (N)) {         for (int j = (0); j < (N); ++j)           fin >> dist[i][j];         ++i;       }     }      while (Q--) {       int U, V;       fin >> U >> V;       --U;       --V;        vector<LL> acc(N);       for (int i = N - 2; i >= 0; --i)         acc[i] = dist[i][i + 1] + acc[i + 1];        vector<double> dp(N + 1, INF);       dp[N - 1] = 0;       {         int i = N - 2;         while (i >= 0) {           for (int j = i + 1; j < N; ++j) {             if (acc[i] - acc[j] > es[i].first)               break;             do_voiapa_fct(dp[i], dp[j] + (acc[i] - acc[j]) * 1. / es[i].second);           }           --i;         }       }       double ans = dp[0];       fout << "Case #" << t_ << ": " << fixed << setprecision(9) << ans << endl;     }   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <climits> #include <cmath> #include <complex> #include <ctime> #include <deque> #include <fstream> #include <iomanip> #include <iterator> #include <math.h> #include <queue> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <unordered_map> #include <utility> #include <vector> using namespace std;  
typedef vector<vector<int>> vvi; typedef long long ll; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef unsigned long long ull; typedef vector<int> vi; typedef long double ld;  using VI = vector<int>; using VVI = vector<VI>; using PII = pair<int, int>; using LL = long long; using VL = vector<LL>; using VVL = vector<VL>; using PLL = pair<LL, LL>; using VS = vector<string>; template <class S, class T> istream &operator>>(istream &t, pair<S, T> &p) {   return t >> p.first >> p.second; } template <class S, class T> ostream &get(ostream &v, const pair<S, T> &p) {   return v << p.first << " " << p.second; } template <class T> void maxi(T &x, T y) {   if (x < y)     x = y; } template <class T> void mini(T &x, T y) {   if (x > y)     x = y; }  const double INF = 1e15;  
int main() {   cin.tie(0);   ios_base::sync_with_stdio(false);    int T;   cin >> T;   for (int tc = (1); tc < (T + 1); ++tc) {     int N, Q;     cin >> N >> Q;     vector<PLL> es(N);     for (int i = (0); i < (N); ++i)       cin >> es[i];      VVL dist(N, VL(N));      for (int i = (0); i < (N); ++i) {       int j = (0);       for (; j < (N);) {         cin >> dist[i][j];         ++j;       }     }      for (; Q--;) {       int U, V;       cin >> U >> V;       --U;       --V;        vector<LL> acc(N);       for (int i = N - 2; i >= 0; --i)         acc[i] = dist[i][i + 1] + acc[i + 1];        vector<double> dp(N + 1, INF);       dp[N - 1] = 0;       for (int i = N - 2; i >= 0; --i) {         for (int j = i + 1; j < N; ++j) {           if (acc[i] - acc[j] > es[i].first)             break;           mini(dp[i], dp[j] + (acc[i] - acc[j]) * 1. / es[i].second);         }       }       double ans = dp[0];       printf("Case #%d: %.9f\n", tc, ans);     }   }    return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <limits> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;  
const int Maxn = 110, oo = 2e9 + 1;  int T;  const int INF = 1000000000; const double EPS = 1e-9; typedef set<int> si; typedef vector<vector<int>> vvi; typedef long long ll; typedef long long LL; typedef pair<int, int> ii; typedef unsigned long long ull; typedef vector<int> vi; typedef long double ld;   int n, cs; struct Rec {   int a, b, l; };  int Q;  long long d[Maxn][Maxn]; int S[Maxn], E[Maxn]; double t[Maxn][Maxn];  
int main() {   ios::sync_with_stdio(0);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_10_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/kuzphi/outer_temp/kuzphi/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_10_Usenix_RF_1.0_True_MCTS_Classic_True/satyaki3794/kuzphi/A-small-practice.in",           "r", stdin);    cin >> T;   while (T--) {     cout << "Case #" << ++cs << ": ";     cin >> n >> Q;     for (int i = 1; i <= n; i++)       cin >> E[i] >> S[i];     for (int i = 1; i <= n; i++)       for (int get = 1; get <= n; get++) {         cin >> d[i][get];         if (d[i][get] == -1)           d[i][get] = oo;       }     for (int i = 1; i <= n; i++)       d[i][i] = 0;      for (int k = 1; k <= n; k++)       for (int i = 1; i <= n; i++)         for (int get = 1; get <= n; get++)           d[i][get] = min(d[i][get], d[i][k] + d[k][get]);      for (int i = 1; i <= n; i++) {       for (int get = 1; get <= n; get++) {         if (d[i][get] > E[i])           t[i][get] = 1e100;         else           t[i][get] = 1. * d[i][get] / S[i];       }     }     for (int k = 1; k <= n; k++)       for (int i = 1; i <= n; i++)         for (int get = 1; get <= n; get++)           t[i][get] = min(t[i][get], t[i][k] + t[k][get]);     for (int i = 1; i <= Q; i++) {       int u, v;       cin >> u >> v;       cout << fixed << setprecision(7) << t[u][v];       if (i < Q)         cout << " ";     }     cout << endl;   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <limits> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const double pi = acos(-1.), eps = 1e-6; const int Maxn = 110, Maxk = 5010, Mo = 1e9 + 7, oo = 2e9 + 1; const int sp[4][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}}; int T; const int INF = 1000000000; const long double PI = 3.1415926535897932384626433832795; ifstream fin;   int n, tc, k, cs; struct Rec {   int a, b, l; };  int N, Q; int num[10], ans[Maxn]; long long d[Maxn][Maxn]; int S[Maxn], E[Maxn]; double t[Maxn][Maxn]; vector<int> c[1010]; inline void rilkojgktf(int &i, int &j) {   fin >> d[i][j];   if (d[i][j] == -1)     d[i][j] = oo; }  
int main() {    fin.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_10_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/kuzphi/A-small-practice.in");    fin >> T;   for (; T--;) {     cout << "Case #" << ++cs << ": ";     fin >> n >> Q;     for (int i = 1; i <= n; i++)       fin >> E[i] >> S[i];     for (int i = 1; i <= n; i++)       for (int j = 1; j <= n; j++)         rilkojgktf(i, j);     for (int i = 1; i <= n; i++)       d[i][i] = 0;      for (int k = 1; k <= n; k++)       for (int i = 1; i <= n; i++)         for (int j = 1; j <= n; j++)           d[i][j] = min(d[i][j], d[i][k] + d[k][j]);       for (int i = 1; i <= n; i++)       for (int j = 1; j <= n; j++) {         if (d[i][j] > E[i]) {           t[i][j] = 1e100;         } else           t[i][j] = 1. * d[i][j] / S[i];       }     for (int k = 1; k <= n; k++)       for (int i = 1; i <= n; i++)         for (int j = 1; j <= n; j++)           t[i][j] = min(t[i][j], t[i][k] + t[k][j]);     for (int i = 1; i <= Q; i++) {       int u, v;       fin >> u >> v;       cout << fixed << setprecision(7) << t[u][v];       if (i < Q)         cout << " ";     }     cout << endl;   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <limits> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std; 
const int Maxn = 110, oo = 2e9 + 1;  int T; const int mod = 1000000007;  typedef pair<int, int> PII; typedef long double LD; typedef long long ll; typedef long long LL; typedef unsigned long long ull; typedef vector<int> VI; typedef set<int> si;   int n, cs; struct Rec {   int a, b, l; };  int Q;  long long d[Maxn][Maxn]; int S[Maxn], E[Maxn]; double t[Maxn][Maxn];  inline void riggyreabn(int &i) {   int u, v;   cin >> u >> v;   cout << fixed << setprecision(7) << t[u][v];   if (i < Q)     cout << " "; }  
int main() {    ios::sync_with_stdio(0);    cin >> T;   for (; T--;) {     cout << "Case #" << ++cs << ": ";     cin >> n >> Q;     for (int i = 1; i <= n; i++)       cin >> E[i] >> S[i];     for (int i = 1; i <= n; i++)       for (int j = 1; j <= n; j++) {         cin >> d[i][j];         if (d[i][j] == -1)           d[i][j] = oo;       }     for (int i = 1; i <= n; i++)       d[i][i] = 0;      for (int get = 1; get <= n; get++)       for (int i = 1; i <= n; i++)         for (int j = 1; j <= n; j++)           d[i][j] = min(d[i][j], d[i][get] + d[get][j]);      for (int i = 1; i <= n; i++)       for (int j = 1; j <= n; j++) {         if (d[i][j] > E[i])           t[i][j] = 1e100;         else           t[i][j] = 1. * d[i][j] / S[i];       }     for (int get = 1; get <= n; get++)       for (int i = 1; i <= n; i++)         for (int j = 1; j <= n; j++)           t[i][j] = min(t[i][j], t[i][get] + t[get][j]);     for (int i = 1; i <= Q; i++)       riggyreabn(i);     cout << endl;   }   return 0; }
#include <algorithm> #include <bitset> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iostream> #include <limits> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <unordered_map> #include <utility> #include <vector> using namespace std;
const double pi = acos(-1.), eps = 1e-6; const int Maxn = 110, Maxk = 5010, Mo = 1e9 + 7, oo = 2e9 + 1; const int sp[4][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}}; int T; typedef long double ld; typedef long long LL; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef vector<int> vi; typedef long double LD;   int n, m, k, cs; struct Rec {   int a, b, l; };  int N, Q; int num[10], ans[Maxn]; long long d[Maxn][Maxn]; int S[Maxn], E[Maxn]; double t[Maxn][Maxn]; vector<int> w[1010]; 
int main() {   int ret_val = 0;   cin >> T;   while (T--) {     printf("Case #%d: ", ++cs);     cin >> n >> Q;     for (int i = 1; i <= n; i++)       cin >> E[i] >> S[i];     for (int i = 1; i <= n; i++)       for (int j = 1; j <= n; j++) {         cin >> d[i][j];         if (d[i][j] == -1)           d[i][j] = oo;       }     for (int i = 1; i <= n; i++)       d[i][i] = 0;      for (int k = 1; k <= n; k++)       for (int i = 1; i <= n; i++)         for (int j = 1; j <= n; j++)           d[i][j] = min(d[i][j], d[i][k] + d[k][j]);      for (int i = 1; i <= n; i++)       for (int j = 1; j <= n; j++) {         if (d[i][j] > E[i])           t[i][j] = 1e100;         else           t[i][j] = 1. * d[i][j] / S[i];       }     for (int k = 1; k <= n; k++)       for (int i = 1; i <= n; i++)         for (int j = 1; j <= n; j++)           t[i][j] = min(t[i][j], t[i][k] + t[k][j]);     for (int i = 1; i <= Q; i++) {       int u, v;       cin >> u >> v;       printf("%.7f", t[u][v]);       if (i < Q)         cout << " ";     }     cout << endl;   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std;
typedef long double ld; typedef pair<int, int> PII; typedef long double LD;  const int INF = 1000000000; ofstream fout;  ifstream fin;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  ll gcd(ll a, ll b) {   ll t;   for (; (t = a % b) != 0;) {     a = b;     b = t;   }   return b; }  ll fast_exp(ll N, ll n, ll m) {   if (n == 0)     return 1;   ll t = fast_exp(N, n / 2, m);   if (n % 2 == 0)     return (t * t) % m;   else     return (((t * t) % m) * N) % m; }  bool is_set(int i, ll mask) { return (mask >> i) & 1; }  int get(ll mask) {   int ans = 0;   for (int i = 0; i < 64; ++i)     if (is_set(i, mask))       ++ans;    return ans; }  int first_bit(ll mask) {   int ret_val = -1;   int i = 0;   while (i < 64)     if (is_set(i++, mask))       return i - 1;   return ret_val; }  
int main() {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_11_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ibrahim5253/outer_temp/ibrahim5253/A-small-practice_transformation.out");    fin.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_11_Usenix_RF_1.0_True_MCTS_Classic_True/gultai4ukr/ibrahim5253/A-small-practice.in");    int t;   fin >> t;   for (int i = 1; i <= t; ++i) {     int n, q;     fin >> n >> q;     ll e[n], s[n];     for (int i = 0; i < n; ++i)       fin >> e[i] >> s[i];     ll d[n][n];     for (int i = 0; i < n; ++i)       for (int j = 0; j < n; ++j)         fin >> d[i][j];     {       int u, v;       fin >> u >> v;       --u, --v;       vector<double> dp(n);       dp[0] = 0;       for (int i = 1; i < n; ++i) {         dp[i] = 1e12;         ll dist = 0;         for (int j = i - 1; j >= 0; --j) {           dist += d[j][j + 1];           if (e[j] > dist)             dp[i] = min(dp[i], dp[j] + dist / static_cast<double>(s[j]));         }       }       fout << "Case #" << i << ": " << fixed << setprecision(10) << dp[v]            << "\n";     }   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std;
ifstream fin;  typedef long double ld; typedef long long LL; typedef pair<int, int> ii; typedef pair<int, int> PII;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  ll gcd(ll a, ll b) {   ll t;   while ((t = a % b) != 0) {     a = b;     b = t;   }   return b; }  ll fast_exp(ll base, ll n, ll N) {   if (n == 0)     return 1;   ll t = fast_exp(base, n / 2, N);   if (n % 2 == 0)     return (t * t) % N;   else     return (((t * t) % N) * base) % N; }  bool is_set(int i, ll mask) { return (mask >> i) & 1; }  int count_bits(ll mask) {   int ans = 0;   {     int i = 0;     while (i < 64) {       if (is_set(i, mask))         ++ans;       ++i;     }   }   return ans; }  inline void hsnkrscmix(int &i) {   int n, q;   fin >> n >> q;   ll e[n], s[n];   for (int i = 0; i < n; ++i)     fin >> e[i] >> s[i];   ll d[n][n];   for (int i = 0; i < n; ++i)     for (int j = 0; j < n; ++j)       fin >> d[i][j];   {     int u, v;     fin >> u >> v;     --u, --v;     vector<double> dp(n);     dp[0] = 0;     for (int i = 1; i < n; ++i) {       dp[i] = 1e12;       ll dist = 0;       for (int j = i - 1; j >= 0; --j) {         dist += d[j][j + 1];         if (e[j] > dist)           dp[i] = min(dp[i], dp[j] + dist / static_cast<double>(s[j]));       }     }     cout << "Case #" << i << ": " << fixed << setprecision(10) << dp[v] << "\n";   } }  
int main() {   ios::sync_with_stdio(false);    fin.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_11_Usenix_RF_1.0_True_MCTS_Classic_True/Mucosolvan/ibrahim5253/A-small-practice.in");    int t;   fin >> t;   for (int i = 1; i <= t; ++i)     hsnkrscmix(i);   return 0; }
#include <algorithm> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
const double EPS = 1e-9; typedef vector<int> VI; typedef long long LL; typedef pair<int, int> ii; typedef long double ld; typedef set<int> si;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  ll get(ll a, ll b) {   ll t;   for (; (t = a % b) != 0;) {     a = b;     b = t;   }   return b; }  ll fast_exp(ll base, ll n, ll m) {   if (n == 0)     return 1;   ll t = fast_exp(base, n / 2, m);   if (n % 2 == 0)     return (t * t) % m;   else     return (((t * t) % m) * base) % m; }  bool is_set(int i, ll mask) { return (mask >> i) & 1; }  int first_bit(ll mask) {   int i = 0;   while (i < 64)     if (is_set(i++, mask))       return i - 1;   return -1; }  
int main() {   int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_11_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/ibrahim5253/A-small-practice.in",           "r", stdin);   int t;   scanf("%d ", &t);   for (int i = 1; i <= t; ++i) {     int n, q;     scanf("%d %d ", &n, &q);     ll e[n], s[n];     {       int i = 0;       while (i < n) {         scanf("%lld %lld ", &e[i], &s[i]);         ++i;       }     }     ll d[n][n];     for (int i = 0; i < n; ++i) {       int j = 0;       while (j < n) {         scanf("%lld ", &d[i][j]);         ++j;       }     }     {       int u, v;       scanf("%d %d ", &u, &v);       --u, --v;       double dp[n];       dp[0] = 0;       for (int i = 1; i < n; ++i) {         dp[i] = 1e12;         ll dist = 0;         {           int j = i - 1;           while (j >= 0) {             dist += d[j][j + 1];             if (e[j] > dist)               dp[i] = min(dp[i], dp[j] + dist / static_cast<double>(s[j]));             --j;           }         }       }       cout << "Case #" << i << ": " << fixed << setprecision(10) << dp[v]            << "\n";     }   }   return ret_val; }
#include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstring> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <map> #include <queue> #include <set> #include <stack> #include <string> #include <unordered_map> #include <utility> #include <vector>   using namespace std; 
ofstream fout;  using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vll = vector<ll>; using pill = pair<int, ll>; using vvi = vector<vi>;  ll solve(ll a, ll b) {   ll t;   for (; (t = a % b) != 0;) {     a = b;     b = t;   }   return b; }  ll fast_exp(ll base, ll n, ll y) {   if (n == 0)     return 1;   ll t = fast_exp(base, n / 2, y);   if (n % 2 == 0)     return (t * t) % y;   else     return (((t * t) % y) * base) % y; }  bool get(int i, ll N) { return (N >> i) & 1; }  int first_bit(ll N) {   int i = 0;   while (i < 64)     if (get(i++, N))       return i - 1;   return -1; } 
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_11_Usenix_RF_1.0_True_MCTS_Classic_True/Thanabhat/ibrahim5253/A-small-practice.in", "r", stdin);    fout.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_11_Usenix_RF_1.0_True_MCTS_Classic_True/Thanabhat/ibrahim5253/outer_temp/ibrahim5253/A-small-practice_transformation.out");    int ret_val = 0;   int t;   cin >> t;   for (int i = 1; i <= t; ++i) {     int n, q;     cin >> n >> q;     ll e[n], s[n];     for (int i = 0; i < n; ++i)       cin >> e[i] >> s[i];     ll d[n][n];     for (int i = 0; i < n; ++i)       for (int j = 0; j < n; ++j)         cin >> d[i][j];     {       int u, v;       cin >> u >> v;       --u, --v;       double dp[n];       dp[0] = 0;       {         int i = 1;         for (; i < n;) {           dp[i] = 1e12;           ll dist = 0;           int j;           for (j = i - 1; j >= 0; --j) {             dist += d[j][j + 1];             if (e[j] > dist) {               dp[i] = min(dp[i], dp[j] + dist / static_cast<double>(s[j]));             }           }           ++i;         }       }       fout << "Case #" << i << ": " << fixed << setprecision(10) << dp[v]            << "\n";     }   }   return ret_val; }
#include <bits/stdc++.h> #include <iomanip> #include <iostream> #include <utility> #include <vector> using namespace std; 
typedef long long ll; typedef pair<int, int> ii; typedef pair<int, int> pii; typedef unsigned long long ull; typedef vector<int> vi; typedef long double LD;  using LL = long long;  double e[123], v[123], s[123], a[123][123], dp[123];  
int main() {   ios::sync_with_stdio(0);    int solve, y = 0;   cin >> solve;   while (solve--) {     int n, q;     cin >> n >> q;     for (int i = 1; i <= n; i++)       cin >> e[i] >> v[i];     for (int i = 1; i <= n; i++)       for (int j = 1; j <= n; j++)         cin >> a[i][j];     for (int i = 2; i <= n; i++)       s[i] = s[i - 1] + a[i - 1][i];     dp[1] = 0;     for (int i = 2; i <= n; i++)       dp[i] = 1e17;     for (int i = 0; i < n; i++)       for (int j = i + 1; j <= n; j++)         if (s[j] - s[i] <= e[i])           dp[j] = min(dp[j], dp[i] + (s[j] - s[i]) / v[i]);     int qu, qv;     cin >> qu >> qv;     cout << "Case #" << ++y << ": " << fixed << setprecision(10) << dp[n]          << "\n";   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <list> #include <map> #include <numeric> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <string> #include <unordered_map> #include <vector> using namespace std; 
typedef long double ld; typedef unsigned long long ull; typedef vector<int> vi; typedef set<int> si; typedef vector<vector<int>> vvi;  using LL = long long;  double e[123], v[123], s[123], a[123][123], dp[123];  inline void irmpceoqpa(int &b) {   int n, q;   cin >> n >> q;   for (int i = 1; i <= n; i++)     cin >> e[i] >> v[i];   for (int i = 1; i <= n; i++)     for (int j = 1; j <= n; j++)       cin >> a[i][j];   for (int i = 2; i <= n; i++)     s[i] = s[i - 1] + a[i - 1][i];   dp[1] = 0;   for (int i = 2; i <= n; i++)     dp[i] = 1e17;   for (int i = 0; i < n; i++)     for (int j = i + 1; j <= n; j++)       if (s[j] - s[i] <= e[i])         dp[j] = min(dp[j], dp[i] + (s[j] - s[i]) / v[i]);   int qu, qv;   cin >> qu >> qv;   cout << "Case #" << ++b << ": " << fixed << setprecision(10) << dp[n] << "\n"; }  
int main() {   int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_12_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/jiian/A-small-practice.in",           "r", stdin);   int T, b = 0;   cin >> T;   while (T--)     irmpceoqpa(b);   return ret_val; }
#include <bits/stdc++.h> #include <iomanip> #include <iostream> using namespace std; 
const double EPS = 1e-9; const int INF = 1000000000; using LL = long long;  double e[123], v[123], s[123], c[123][123], dp[123];  inline void ksjhsvbbjb(int &n) {   int solve = 1;   for (; solve <= n;) {     cin >> e[solve] >> v[solve];     solve++;   } }  inline void hasqbrqdug(int &tc) {   int n, q;   cin >> n >> q;   ksjhsvbbjb(n);   for (int solve = 1; solve <= n; solve++)     for (int j = 1; j <= n; j++)       cin >> c[solve][j];   for (int solve = 2; solve <= n; solve++)     s[solve] = s[solve - 1] + c[solve - 1][solve];   dp[1] = 0;   int solve;   for (solve = 2; solve <= n; solve++)     dp[solve] = 1e17;   for (int solve = 0; solve < n; solve++)     for (int j = solve + 1; j <= n; j++)       if (s[j] - s[solve] <= e[solve])         dp[j] = min(dp[j], dp[solve] + (s[j] - s[solve]) / v[solve]);   int qu, qv;   cin >> qu >> qv;   cout << "Case #" << ++tc << ": " << fixed << setprecision(10) << dp[n]        << "\n"; }  
int main() {    int r, tc = 0;   cin >> r;   for (; r--;)     hasqbrqdug(tc);   return 0; }
#include <bits/stdc++.h> #include <stdio.h> using namespace std;
using LL = long long;  double e[123], v[123], s[123], ans[123][123], dp[123];  
int main() {   int ret_val = 0;    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_12_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/jiian/outer_temp/jiian/A-small-practice_transformation.out",           "w", stdout);   int T, cas = 0;   scanf("%d ", &T);   while (T--) {     int n, q;     scanf("%d %d ", &n, &q);     for (int i = 1; i <= n; i++)       scanf("%lf %lf ", &e[i], &v[i]);     for (int i = 1; i <= n; i++)       for (int j = 1; j <= n; j++)         scanf("%lf ", &ans[i][j]);     for (int i = 2; i <= n; i++)       s[i] = s[i - 1] + ans[i - 1][i];     dp[1] = 0;     for (int i = 2; i <= n; i++)       dp[i] = 1e17;     for (int i = 0; i < n; i++)       for (int j = i + 1; j <= n; j++)         if (s[j] - s[i] <= e[i])           dp[j] = min(dp[j], dp[i] + (s[j] - s[i]) / v[i]);     int qu, qv;     scanf("%d %d ", &qu, &qv);     printf("Case #%d: %.10f\n", ++cas, dp[n]);   }   return ret_val; }
#include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <functional> #include <iomanip> #include <map> #include <math.h> #include <numeric> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <utility> #include <vector> using namespace std; 
typedef double td_d; typedef long long LL; typedef pair<int, int> PII; typedef unsigned long long ull; typedef vector<int> VI; typedef long double LD; typedef vector<vector<int>> vvi;  int N, Q, U, V; int e[200]; double s[200]; int d[200][200]; int go[200];  double ans[200]; 
int main(void) {   int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_13_Usenix_RF_1.0_True_MCTS_Classic_True/lazyBit/iPeter/A-small-practice.in",           "r", stdin);   int t;   scanf("%d", &t);   for (int tt = 1; tt <= t; tt++) {     scanf("%d%d", &N, &Q);     for (int i = 0; i < N; ++i)       scanf("%d%lf", &e[i], &s[i]);     for (int i = 0; i < N; ++i)       for (int j = 0; j < N; ++j)         scanf("%d", &d[i][j]);      for (int k = 0; k < N; ++k)       for (int i = 0; i < N; ++i)         for (int j = 0; j < N; ++j) {           if (d[k][j] < 0)             continue;           else if (i == j || d[i][k] < 0)             continue;            if (d[i][j] < 0 || d[i][j] >= d[i][k] + d[k][j]) {             d[i][j] = d[i][k] + d[k][j];           }         }      printf("Case #%d:", tt);      for (; Q--;) {       scanf("%d%d", &U, &V);       --U, --V;       for (int i = 0; i < N; ++i) {         ans[i] = -1;         go[i] = false;       }       ans[U] = 0;         int cur = U;       while (1) {         go[cur] = true;         for (int i = 0; i < N; ++i) {           if (d[cur][i] > e[cur] || d[cur][i] < 0)             continue;           if (ans[i] < 0 || ans[i] > ans[cur] + d[cur][i] / s[cur])             ans[i] = ans[cur] + d[cur][i] / s[cur];         }          td_d mind = -1;         for (int i = 0; i < N; ++i) {           if (go[i] || ans[i] < 0)             continue;           if (mind < 0 || mind > ans[i]) {             cur = i;             mind = ans[i];           }         }          if (mind < 0)           break;       }        printf(" %lf", ans[V]);     }      puts("");   }   return ret_val; }
#include <algorithm> #include <cstdio> #include <cstring> #include <iostream> using namespace std;  
int N, Q, U, V; int e[200]; double s[200]; int d[200][200]; int go[200];  double ans[200]; inline void uapyjyennl(int &cur, double &mind, int &solve) {   cur = solve;   mind = ans[solve]; }  
int main(void) {   int t;   cin >> t;   for (int tt = 1; tt <= t; tt++) {     cin >> N >> Q;     for (int solve = 0; solve < N; ++solve)       cin >> e[solve] >> s[solve];     for (int solve = 0; solve < N; ++solve)       for (int j = 0; j < N; ++j)         cin >> d[solve][j];      for (int k = 0; k < N; ++k)       for (int solve = 0; solve < N; ++solve)         for (int j = 0; j < N; ++j) {           if (solve == j || d[solve][k] < 0 || d[k][j] < 0)             continue;           if (d[solve][j] >= d[solve][k] + d[k][j]) {             d[solve][j] = d[solve][k] + d[k][j];           } else if (d[solve][j] < 0) {             d[solve][j] = d[solve][k] + d[k][j];           }         }      printf("Case #%d:", tt);      for (; Q--;) {       cin >> U >> V;       --U, --V;       for (int solve = 0; solve < N; ++solve) {         ans[solve] = -1;         go[solve] = false;       }       ans[U] = 0;         int cur = U;       while (1) {         go[cur] = 1;         for (int solve = 0; solve < N; ++solve) {           if (d[cur][solve] > e[cur] || d[cur][solve] < 0)             continue;           if (ans[solve] < 0 || ans[solve] > ans[cur] + d[cur][solve] / s[cur])             ans[solve] = ans[cur] + d[cur][solve] / s[cur];         }          double mind = -1;         for (int solve = 0; solve < N; ++solve) {           if (go[solve] || ans[solve] < 0)             continue;           if (mind < 0 || mind > ans[solve])             uapyjyennl(cur, mind, solve);         }          if (mind < 0)           break;       }        printf(" %lf", ans[V]);     }      puts("");   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> using namespace std; 
int N, Q, U, V; int e[200]; double s[200]; int d[200][200]; int go[200];  double ans[200]; 
int main(void) {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_13_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/iPeter/outer_temp/iPeter/A-small-practice_transformation.out", "w", stdout);    int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_13_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/iPeter/A-small-practice.in",           "r", stdin);   int t;   scanf("%d", &t);   for (int tt = 1; tt <= t; tt++) {     scanf("%d%d", &N, &Q);     for (int i = 0; i < N; ++i)       scanf("%d%lf", &e[i], &s[i]);     for (int i = 0; i < N; ++i)       for (int j = 0; j < N; ++j)         scanf("%d", &d[i][j]);      for (int k = 0; k < N; ++k)       for (int i = 0; i < N; ++i)         for (int j = 0; j < N; ++j) {           if (i == j || d[i][k] < 0 || d[k][j] < 0)             continue;           if (d[i][j] < 0 || d[i][j] >= d[i][k] + d[k][j]) {             d[i][j] = d[i][k] + d[k][j];           }         }      printf("Case #%d:", tt);      for (; Q--;) {       scanf("%d%d", &U, &V);       --U, --V;       for (int i = 0; i < N; ++i) {         ans[i] = -1;         go[i] = false;       }       ans[U] = 0;         int cur = U;       while (1) {         go[cur] = true;         for (int i = 0; i < N; ++i) {           if (d[cur][i] > e[cur] || d[cur][i] < 0)             continue;           if (ans[i] < 0 || ans[i] > ans[cur] + d[cur][i] / s[cur])             ans[i] = ans[cur] + d[cur][i] / s[cur];         }          double mind = -1;         for (int i = 0; i < N; ++i) {           if (go[i] || ans[i] < 0)             continue;           if (mind < 0 || mind > ans[i]) {             cur = i;             mind = ans[i];           }         }          if (mind < 0)           break;       }        printf(" %lf", ans[V]);     }      puts("");   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <cstdio> #include <cstring> #include <iostream> using namespace std;  
int N, Q, U, V; int e[200]; double s[200]; int d[200][200]; int go[200];  double ans[200]; inline void syragehnsx(int &i, int &cur) {   ans[i] = ans[cur] + d[cur][i] / s[cur]; }  
int main(void) {   int ret_val = 0;   int t;   cin >> t;   {     int tt = 1;     while (tt <= t) {       cin >> N >> Q;       {         int i = 0;         for (; i < N;) {           cin >> e[i] >> s[i];           ++i;         }       }       for (int i = 0; i < N; ++i) {         int tc = 0;         while (tc < N) {           cin >> d[i][tc];           ++tc;         }       }        for (int k = 0; k < N; ++k)         for (int i = 0; i < N; ++i)           for (int tc = 0; tc < N; ++tc) {             if (i == tc || d[i][k] < 0 || d[k][tc] < 0)               continue;             if (d[i][tc] < 0 || d[i][tc] >= d[i][k] + d[k][tc])               d[i][tc] = d[i][k] + d[k][tc];           }        printf("Case #%d:", tt);        for (; Q--;) {         cin >> U >> V;         --U, --V;         for (int i = 0; i < N; ++i) {           ans[i] = -1;           go[i] = false;         }         ans[U] = 0;           int cur = U;         while (true) {           go[cur] = true;           {             int i = 0;             while (i < N) {               if (d[cur][i] > e[cur] || d[cur][i] < 0) {                 ++i;                 continue;               }               if (ans[i] > ans[cur] + d[cur][i] / s[cur])                 ans[i] = ans[cur] + d[cur][i] / s[cur];               else if (ans[i] < 0)                 syragehnsx(i, cur);               ++i;             }           }            double mind = -1;           {             int i = 0;             while (i < N) {               if (ans[i] < 0) {                 ++i;                 continue;               } else if (go[i]) {                 ++i;                 continue;               }               if (mind < 0 || mind > ans[i]) {                 cur = i;                 mind = ans[i];               }               ++i;             }           }            if (mind < 0)             break;         }          printf(" %lf", ans[V]);       }        puts("");       tt++;     }   }   return ret_val; }
#include <bits/stdc++.h> #include <iomanip> #include <iostream> #include <stdio.h>  using namespace std; 
const int INF = 1000000000;  typedef pair<int, int> ii;  long long pwr(long long s, long long p, long long mod = (1000000007LL)) {   long long ans = 1;   while (p) {     if (p & 1)       ans = (ans * s) % mod;     s = (s * s) % mod;     p /= 2;   }   return ans; }  long long solve(long long a, long long b) {   if (b == 0)     return a;   return solve(b, a % b); }  const int N = 102; int n, q; double endurance[N], speed[N], adj[N][N], dist[N][N];  inline void hfansufllc(int &src, priority_queue<pair<double, int>> &pq,                        double &dd, int &vv) {   dist[src][vv] = dd;   pq.push(pair<double, int>(-dd, vv)); }  void dijkstra(int src) {   for (int i = 1; i <= n; i++)     dist[src][i] = 1e15;   priority_queue<pair<double, int>> pq;   dist[src][src] = 0;   pq.push(pair<double, int>(0, src));   while (!pq.empty()) {      int v = pq.top().second;     double d = -pq.top().first;     pq.pop();     if (d > dist[src][v])       continue;      for (int vv = 1; vv <= n; vv++) {       if (adj[v][vv] > endurance[v]) {         continue;       }       double dd = d + adj[v][vv] / speed[v];       if (dd < dist[src][vv])         hfansufllc(src, pq, dd, vv);     }   } }  inline void jantgzcnjq(int &i, int &j) {   cin >> adj[i][j];   if (adj[i][j] == -1)     adj[i][j] = 1e15; }  inline void qflyfoquat(int &i) {   for (int j = 1; j <= n; j++)     jantgzcnjq(i, j); }  
int main() {    cin.tie(0);    int t, x = 1;   cin >> t;   while (t--) {      cin >> n >> q;     for (int i = 1; i <= n; i++)       cin >> endurance[i] >> speed[i];      for (int i = 1; i <= n; i++)       qflyfoquat(i);      for (int r = 1; r <= n; r++)       for (int i = 1; i <= n; i++)         for (int j = 1; j <= n; j++)           adj[i][j] = min(adj[i][j], adj[i][r] + adj[r][j]);      for (int i = 1; i <= n; i++)       dijkstra(i);      printf("Case #%d:", x++);     while (q--) {       int a, b;       cin >> a >> b;       printf(" %.7f", dist[a][b]);     }     printf("\n");   }    return 0; }
#include <bits/stdc++.h>  using namespace std;  
typedef pair<int, int> ii; typedef pair<int, ii> iii;  long long pwr(long long base, long long p, long long mod = (1000000007LL)) {   long long ans = 1;   while (p) {     if (p & 1)       ans = (ans * base) % mod;     base = (base * base) % mod;     p /= 2;   }   return ans; }  long long gcd(long long a, long long b) {   if (b == 0)     return a;   return gcd(b, a % b); }  const int N = 102; int n, q; double endurance[N], speed[N], adj[N][N], dist[N][N];  typedef pair<double, int> pdi; void dijkstra(int src) {   for (int i = 1; i <= n; i++)     dist[src][i] = 1e15;   priority_queue<pdi> pq;   dist[src][src] = 0;   pq.push(pdi(0, src));   while (!pq.empty()) {      int v = pq.top().second;     double d = -pq.top().first;     pq.pop();     if (d > dist[src][v])       continue;      for (int vv = 1; vv <= n; vv++) {       if (adj[v][vv] > endurance[v])         continue;       double dd = d + adj[v][vv] / speed[v];       if (dd < dist[src][vv]) {         dist[src][vv] = dd;         pq.push(pdi(-dd, vv));       }     }   } }  
int main() {   int ret_val = 0;   ios_base::sync_with_stdio(0);   cin.tie(0);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_14_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/satyaki3794/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_14_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/satyaki3794/outer_temp/satyaki3794/A-small-practice_transformation.out",           "w", stdout);   int t, x = 1;   cin >> t;   while (t--) {      cin >> n >> q;     for (int i = 1; i <= n; i++)       cin >> endurance[i] >> speed[i];      for (int i = 1; i <= n; i++) {       for (int j = 1; j <= n; j++) {         cin >> adj[i][j];         if (adj[i][j] == -1)           adj[i][j] = 1e15;       }     }      for (int k = 1; k <= n; k++)       for (int i = 1; i <= n; i++)         for (int j = 1; j <= n; j++)           adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j]);      for (int i = 1; i <= n; i++)       dijkstra(i);      cout << "Case #" << x++ << ":";     while (q--) {       int a, b;       cin >> a >> b;       cout << fixed << setprecision(7) << " " << dist[a][b];     }     cout << endl;   }   return ret_val; }
#include <bits/stdc++.h>  using namespace std; 
typedef pair<int, int> ii; typedef pair<int, ii> iii;  long long pwr(long long base, long long p, long long mod = (1000000007LL)) {   long long ans = 1;   while (p) {     if (p & 1)       ans = (ans * base) % mod;     base = (base * base) % mod;     p /= 2;   }   return ans; }  long long gcd(long long a, long long b) {   if (b == 0)     return a;   return gcd(b, a % b); }  const int N = 102; int n, q; double endurance[N], speed[N], adj[N][N], dist[N][N];  typedef pair<double, int> pdi; void dijkstra(int src) {   for (int i = 1; i <= n; i++)     dist[src][i] = 1e15;   priority_queue<pdi> pq;   dist[src][src] = 0;   pq.push(pdi(0, src));   while (!pq.empty()) {      int v = pq.top().second;     double d = -pq.top().first;     pq.pop();     if (d > dist[src][v])       continue;      for (int vv = 1; vv <= n; vv++) {       if (adj[v][vv] > endurance[v])         continue;       double dd = d + adj[v][vv] / speed[v];       if (dd < dist[src][vv]) {         dist[src][vv] = dd;         pq.push(pdi(-dd, vv));       }     }   } }  
int main() {   int ret_val = 0;   cin.tie(0);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_13_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/satyaki3794/A-small-practice.in",           "r", stdin);   int t, x = 1;   cin >> t;   for (; t--;) {      cin >> n >> q;     for (int i = 1; i <= n; i++)       cin >> endurance[i] >> speed[i];      for (int i = 1; i <= n; i++) {       for (int j = 1; j <= n; j++) {         cin >> adj[i][j];         if (adj[i][j] == -1)           adj[i][j] = 1e15;       }     }      int k;     for (k = 1; k <= n; k++)       for (int i = 1; i <= n; i++) {         int j = 1;         while (j <= n) {           adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j]);           j++;         }       }      for (int i = 1; i <= n; i++)       dijkstra(i);      cout << "Case #" << x++ << ":";     while (q--) {       int a, b;       cin >> a >> b;       cout << fixed << setprecision(7) << " " << dist[a][b];     }     cout << endl;   }   return ret_val; }
#include <bits/stdc++.h> #include <stdio.h>  using namespace std; 
typedef long long ll; typedef pair<int, int> ii; typedef pair<int, ii> iii;  ll pwr(ll base, ll p, ll mod = (1000000007LL)) {   ll ans = 1;   while (p) {     if (p & 1)       ans = (ans * base) % mod;     base = (base * base) % mod;     p /= 2;   }   return ans; }  const int N = 102; int n, q; double endurance[N], speed[N], adj[N][N], dist[N][N];  typedef pair<double, int> pdi; void dijkstra(int src) {   for (int i = 1; i <= n; i++)     dist[src][i] = 1e15;   priority_queue<pdi> pq;   dist[src][src] = 0;   pq.push(pdi(0, src));   while (!pq.empty()) {      int v = pq.top().second;     double d = -pq.top().first;     pq.pop();     if (d > dist[src][v])       continue;      for (int vv = 1; vv <= n; vv++) {       if (adj[v][vv] > endurance[v])         continue;       double dd = d + adj[v][vv] / speed[v];       if (dd < dist[src][vv]) {         dist[src][vv] = dd;         pq.push(pdi(-dd, vv));       }     }   } }  
int main() {   int ret_val = 0;    cin.tie(0);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_13_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/satyaki3794/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_13_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/satyaki3794/outer_temp/satyaki3794/A-small-practice_transformation.out",           "w", stdout);   int t, x = 1;   scanf("%d ", &t);   while (t--) {      scanf("%d %d ", &n, &q);     for (int i = 1; i <= n; i++)       scanf("%lf %lf ", &endurance[i], &speed[i]);      for (int i = 1; i <= n; i++) {       for (int j = 1; j <= n; j++) {         scanf("%lf ", &adj[i][j]);         if (adj[i][j] == -1)           adj[i][j] = 1e15;       }     }      for (int k = 1; k <= n; k++)       for (int i = 1; i <= n; i++)         for (int j = 1; j <= n; j++)           adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j]);      for (int i = 1; i <= n; i++)       dijkstra(i);      printf("Case #%d:", x++);     while (q--) {       int a, b;       scanf("%d %d ", &a, &b);       printf(" %.7f", dist[a][b]);     }     printf("\n");   }   return ret_val; }
#include <bits/stdc++.h> #include <iostream> #include <stdio.h> using namespace std;  
bool comp(pair<int, char> &l, pair<int, char> &r) { return l.first < r.first; }  inline void gfruiiqpex(vector<double> &dp, vector<vector<long long>> &dist,                        int &to, vector<long long> &s, int &from) {   dp[to] = min(dp[to], dp[from] + 1.0 * dist[from][to] / s[from]); }  inline void rxrnzhtdng(vector<vector<long long>> &dist, int &from,                        vector<vector<long long>> &d, int &to) {   dist[from][to] = dist[from][to - 1] + d[to - 1][to];   }  inline void wcpmpcqfqu(vector<vector<long long>> &d, int &i, int &j) {   cin >> d[i][j]; }  
int main(int argc, char **argv) {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_15_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_15_Usenix_RF_1.0_True_MCTS_Classic_True/fragusbot/gultai4ukr/A-small-practice.in",           "r", stdin);    int ret_val = 0;    int cc;   scanf("%d ", &cc);   {     int testcase = 0;     while (testcase < cc) {       int n, q, u, v;       scanf("%d %d ", &n, &q);       assert(q == 1);       vector<long long int> e(n), s(n);       for (int i = 0; i < n; ++i) {         cin >> e[i] >> s[i];       }       vector<vector<long long int>> d(n, vector<long long int>(n));       for (int i = 0; i < n; ++i) {         for (int j = 0; j < n; ++j)           wcpmpcqfqu(d, i, j);       }       scanf("%d %d ", &u, &v);        vector<vector<long long int>> dist(n, vector<long long int>(n, -1));       for (int from = 0; from < n; ++from) {         dist[from][from] = 0;         for (int to = from + 1; to < n; ++to) {           rxrnzhtdng(dist, from, d, to);         }       }        vector<double> dp(n, 1e18);       dp[0] = 0;       for (int to = 1; to < n; ++to) {         int from;         for (from = 0; from < to; ++from) {           if (dist[from][to] <= e[from])             gfruiiqpex(dp, dist, to, s, from);         }       }        cout << "Case #" << testcase + 1 << ": " << fixed << setprecision(7)            << dp[n - 1] << endl;       ++testcase;     }   }    return ret_val; }
#include <bits/stdc++.h> #include <fstream> #include <iostream> using namespace std; 
ofstream fout;  inline void rezetujkmu(int &n, vector<vector<long long>> &dist,                        vector<vector<long long>> &d) {   int from = 0;   while (from < n) {     dist[from][from] = 0;      for (int to = from + 1; to < n; ++to) {       dist[from][to] = dist[from][to - 1] + d[to - 1][to];       }     ++from;   } }  
int main(int argc, char **tc) {   fout.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_14_Usenix_RF_1.0_True_MCTS_Classic_True/4yn/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out");    int ret_val = 0;    int t;   cin >> t;   for (int testcase = 0; testcase < t; ++testcase) {     int n, q, u, v;     cin >> n >> q;     assert(q == 1);     vector<long long int> e(n), s(n);     for (int i = 0; i < n; ++i) {       cin >> e[i] >> s[i];     }     vector<vector<long long int>> d(n, vector<long long int>(n));     for (int i = 0; i < n; ++i) {       int j;       for (j = 0; j < n; ++j) {         cin >> d[i][j];       }     }     cin >> u >> v;      vector<vector<long long int>> dist(n, vector<long long int>(n, -1));     rezetujkmu(n, dist, d);      vector<double> dp(n, 1e18);     dp[0] = 0;     int to;     for (to = 1; to < n; ++to) {       for (int from = 0; from < to; ++from) {         if (dist[from][to] <= e[from]) {           dp[to] = min(dp[to], dp[from] + 1.0 * dist[from][to] / s[from]);         }       }     }      fout << "Case #" << testcase + 1 << ": " << fixed << setprecision(7)          << dp[n - 1] << endl;   }    return ret_val; }
#include <bits/stdc++.h> #include <iostream> #include <set> #include <stdio.h> #include <utility> #include <vector> using namespace std; 
const long double PI = 3.1415926535897932384626433832795; typedef pair<int, int> pii; typedef long double ld; typedef long long ll; typedef unsigned long long ull; typedef vector<int> VI; typedef set<int> si; typedef vector<vector<int>> vvi;  inline void xrotkrnmdv(vector<double> &dp, vector<vector<long long>> &dist,                        int &to, vector<long long> &s, int &from) {   dp[to] = min(dp[to], dp[from] + 1.0 * dist[from][to] / s[from]); }  
int main(int c, char **argv) {   ios::sync_with_stdio(false);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_14_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out",           "w", stdout);    int ret_val = 0;   ifstream fin("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_14_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/gultai4ukr/A-small-practice.in");    int t;   fin >> t;   for (int y = 0; y < t; ++y) {     int n, q, u, v;     fin >> n >> q;     assert(q == 1);     vector<long long int> e(n), s(n);     {       int i = 0;       while (i < n) {         fin >> e[i] >> s[i];         ++i;       }     }      vector<vector<long long int>> d(n, vector<long long int>(n));     for (int i = 0; i < n; ++i) {       {         int j = 0;         while (j < n) {           fin >> d[i][j];           ++j;         }       }     }     fin >> u >> v;      vector<vector<long long int>> dist(n, vector<long long int>(n, -1));     for (int from = 0; from < n; ++from) {       dist[from][from] = 0;       for (int to = from + 1; to < n; ++to) {         dist[from][to] = dist[from][to - 1] + d[to - 1][to];         }     }      vector<double> dp(n, 1e18);     dp[0] = 0;     for (int to = 1; to < n; ++to) {       {         int from = 0;         while (from < to) {           if (dist[from][to] <= e[from])             xrotkrnmdv(dp, dist, to, s, from);           ++from;         }       }     }      printf("Case #%d: %.7f\n", y + 1, dp[n - 1]);   }   fin.close();    return ret_val; }
#include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <fstream> #include <functional> #include <iostream> #include <list> #include <map> #include <math.h> #include <stdio.h> #include <stdlib.h> #include <utility> #include <vector> using namespace std; 
inline void xnmjeiioud(int &get) {   int n, q, u, v;   scanf("%d %d ", &n, &q);   assert(q == 1);   vector<long long int> e(n), s(n);   for (int i = 0; i < n; ++i) {     cin >> e[i] >> s[i];   }   vector<vector<long long int>> d(n, vector<long long int>(n));   for (int i = 0; i < n; ++i) {     for (int j = 0; j < n; ++j) {       cin >> d[i][j];     }   }   scanf("%d %d ", &u, &v);    vector<vector<long long int>> dist(n, vector<long long int>(n, -1));   for (int from = 0; from < n; ++from) {     dist[from][from] = 0;     int to;     {       to = from + 1;       while (to < n) {         dist[from][to] = dist[from][to - 1] + d[to - 1][to];              ++to;       }     }   }    vector<double> dp(n, 1e18);   dp[0] = 0;   int to;   {     to = 1;     for (; to < n;) {       for (int from = 0; from < to; ++from) {         if (dist[from][to] <= e[from]) {           dp[to] = min(dp[to], dp[from] + 1.0 * dist[from][to] / s[from]);         }       }       ++to;     }   }    printf("Case #%d: %.7f\n", get + 1, dp[n - 1]); }  
int main(int c, char **argv) {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_14_Usenix_RF_1.0_True_MCTS_Classic_True/try/gultai4ukr/A-small-practice.in", "r", stdin);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_14_Usenix_RF_1.0_True_MCTS_Classic_True/try/gultai4ukr/outer_temp/gultai4ukr/A-small-practice_transformation.out",           "w", stdout);    int t;   scanf("%d ", &t);   for (int get = 0; get < t; ++get)     xnmjeiioud(get);    return 0; }
#include <bits/stdc++.h> #include <fstream> #include <iomanip> #include <iostream> #include <stdio.h>  using namespace std;
typedef long long td_ll;  const long long inf = 1e16 + 7; const long long maxN = 1e3 + 5;  int n, q, u, v, t; int horse[maxN], dist[maxN][maxN], speed[maxN]; long long pref[maxN]; long double dp[maxN];  
int main() {    int ret_val = 0;    cin >> t;   for (td_ll x = (1); x <= ((t)); ++x) {     cin >> n >> q;     for (td_ll i = (1); i <= ((n)); ++i)       cin >> horse[i] >> speed[i];     for (td_ll i = (1); i <= ((n)); ++i) {       for (td_ll m = (1); m <= ((n)); ++m) {         cin >> dist[i][m];       }     }     pref[1] = 0;     for (td_ll i = (2); i <= (n); ++i) {       pref[i] = pref[i - 1] + dist[i - 1][i];     }     cout << "Case #" << x << ": ";     for (td_ll _ = (0); _ <= ((q)-1); ++_) {       cin >> u >> v;       for (td_ll i = (1); i <= ((n)); ++i)         dp[i] = (long double)inf;       dp[1] = 0;       for (td_ll i = (1); i <= ((n)); ++i) {         for (td_ll m = (i + 1); m <= (n); ++m) {            if (pref[m] - pref[i] > horse[i])             break;           dp[m] =               min(dp[m], dp[i] + (pref[m] - pref[i]) / (long double)speed[i]);         }       }       cout << fixed << setprecision(9) << dp[n];     }     cout << "\n";   }   return ret_val; }
#include <bits/stdc++.h>  using namespace std; 
typedef vector<int> vi; typedef long long ll; typedef long double ld; typedef pair<ll, ll> pii; typedef pair<pii, ll> para; const ll inf = 1e16 + 7; const ll maxN = 1e3 + 5;  int n, q, u, v, t; int horse[maxN], dist[maxN][maxN], speed[maxN]; ll pref[maxN]; ld dp[maxN];  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_15_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/Mucosolvan/outer_temp/Mucosolvan/A-small-practice_transformation.out", "w", stdout);    int ret_val = 0;   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_15_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/Mucosolvan/A-small-practice.in",           "r", stdin);   cin >> t;   for (ll x = (1); x <= ((t)); ++x) {     cin >> n >> q;     for (ll i = (1); i <= ((n)); ++i) {       cin >> horse[i] >> speed[i];     }     for (ll i = (1); i <= ((n)); ++i) {       for (ll j = (1); j <= ((n)); ++j) {         cin >> dist[i][j];       }     }     pref[1] = 0;     for (ll i = (2); i <= (n); ++i) {       pref[i] = pref[i - 1] + dist[i - 1][i];     }     cout << "Case #" << x << ": ";     for (ll _ = (0); _ <= ((q)-1); ++_) {       cin >> u >> v;       for (ll i = (1); i <= ((n)); ++i)         dp[i] = (ld)inf;       dp[1] = 0;       for (ll i = (1); i <= ((n)); ++i) {         for (ll j = (i + 1); j <= (n); ++j) {            if (pref[j] - pref[i] > horse[i])             break;           dp[j] = min(dp[j], dp[i] + (pref[j] - pref[i]) / (ld)speed[i]);         }       }       cout << fixed << setprecision(9) << dp[n];     }     cout << endl;   }   return ret_val; }
#include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <list> #include <map> #include <math.h> #include <stdio.h> #include <stdlib.h> #include <utility> #include <vector>  using namespace std;
 const double EPS = 1e-9; typedef pair<int, int> ii; typedef unsigned long long ull; typedef set<int> si; typedef vector<vector<int>> vvi; typedef vector<int> VI; typedef long long LL; typedef long double LD; typedef pair<LL, LL> pii; typedef pair<pii, LL> para; const LL inf = 1e16 + 7; const LL maxN = 1e3 + 5;  int n, q, u, v, t; int horse[maxN], dist[maxN][maxN], speed[maxN]; LL pref[maxN]; LD dp[maxN];  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_15_Usenix_RF_1.0_True_MCTS_Classic_True/try/Mucosolvan/A-small-practice.in",           "r", stdin);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_15_Usenix_RF_1.0_True_MCTS_Classic_True/try/Mucosolvan/outer_temp/Mucosolvan/A-small-practice_transformation.out",           "w", stdout);    scanf("%d ", &t);   for (LL x = (1); x <= ((t)); ++x) {     scanf("%d %d ", &n, &q);     for (LL get = (1); get <= ((n)); ++get)       scanf("%d %d ", &horse[get], &speed[get]);     for (LL get = (1); get <= ((n)); ++get) {       for (LL solve = (1); solve <= ((n)); ++solve) {         scanf("%d ", &dist[get][solve]);       }     }     pref[1] = 0;     for (LL get = (2); get <= (n); ++get) {       pref[get] = pref[get - 1] + dist[get - 1][get];     }     cout << "Case #" << x << ": ";     LL _;     for (_ = (0); _ <= ((q)-1); ++_) {       scanf("%d %d ", &u, &v);       for (LL get = (1); get <= ((n)); ++get) {         dp[get] = (LD)inf;       }       dp[1] = 0;       for (LL get = (1); get <= ((n)); ++get) {         {           LL solve = (get + 1);           while (solve <= (n)) {              if (pref[solve] - pref[get] > horse[get])               break;             dp[solve] = min(dp[solve], dp[get] + (pref[solve] - pref[get]) /                                                      (LD)speed[get]);             ++solve;           }         }       }       cout << fixed << setprecision(9) << dp[n];     }     cout << "\n";   }   return 0; }
#include <bits/stdc++.h> #include <fstream> #include <utility> #include <vector>  using namespace std; 
ifstream fin;  ofstream fout;  typedef vector<int> VI; typedef long long LL; typedef long double LD; typedef pair<LL, LL> pii; typedef pair<pii, LL> para; const LL inf = 1e16 + 7; const LL maxN = 1e3 + 5;  int n, q, u, v, t; int horse[maxN], dist[maxN][maxN], speed[maxN]; LL pref[maxN]; LD dp[maxN];  inline void igptvhonjg(LL &tc) { pref[tc] = pref[tc - 1] + dist[tc - 1][tc]; }  inline void rhwlerryqw(LL &tc, LL &j) { fin >> dist[tc][j]; }  inline void nnjqfrsbbg(LL &tc) {   for (LL j = (1); j <= ((n)); ++j)     rhwlerryqw(tc, j); }  
int main() {   fin.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_15_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Mucosolvan/A-small-practice.in");    fout.open("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_15_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/Mucosolvan/outer_temp/Mucosolvan/A-small-practice_transformation.out");    int ret_val = 0;    fin >> t;   for (LL solve = (1); solve <= ((t)); ++solve) {     fin >> n >> q;     for (LL tc = (1); tc <= ((n)); ++tc)       fin >> horse[tc] >> speed[tc];     for (LL tc = (1); tc <= ((n)); ++tc)       nnjqfrsbbg(tc);     pref[1] = 0;     for (LL tc = (2); tc <= (n); ++tc)       igptvhonjg(tc);     fout << "Case #" << solve << ": ";     for (LL _ = (0); _ <= ((q)-1); ++_) {       fin >> u >> v;       for (LL tc = (1); tc <= ((n)); ++tc)         dp[tc] = (LD)inf;       dp[1] = 0;       for (LL tc = (1); tc <= ((n)); ++tc) {         {           LL j = (tc + 1);           while (j <= (n)) {              if (pref[j] - pref[tc] > horse[tc])               break;             dp[j] = min(dp[j], dp[tc] + (pref[j] - pref[tc]) / (LD)speed[tc]);             ++j;           }         }       }       fout << fixed << setprecision(9) << dp[n];     }     fout << endl;   }   return ret_val; }
#include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <deque> #include <iomanip> #include <iostream> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdlib.h>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std; 
const int MAXN = 1005;  typedef long double ld; typedef set<int> si; typedef vector<int> VI; typedef vector<VI> vvi; typedef pair<int, int> pii; typedef vector<pii> vii; typedef vector<string> vs;  typedef long long ll;            typedef unsigned long long ULL;  typedef unsigned uint;  const double pi = acos(-1.0);  const double eps = 1e-11;      const int MAXI = 0x7fffffff; const int dx[] = {1, 0, -1, 0}; const int dy[] = {0, 1, 0, -1}; const char colors[] = {'R', 'O', 'Y', 'G', 'B', 'V'}; const char dz[] = "SENW"; struct debugger {   template <typename T> debugger &operator,(const T &v) {     cerr << v << " ";     return *this;   } } dbg;  void debugarr(int *arr, int n) {   cout << "[";   for (int i = 0; i < n; i++)     cout << arr[i] << " ";   cout << "]" << endl; }  double besttime[1010]; ll c[110], d[110], dist[110][110], a[110], b[110], dd[110]; long double best[110][110]; 
int main() {   ios::sync_with_stdio(true);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_16_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_16_Usenix_RF_1.0_True_MCTS_Classic_True/KhaleD/lazyBit/A-small-practice.in",           "r", stdin);   ;     long long n, k, l, m, t, s = 0, p, q;   int i, j;   cin >> t;   int ct = 1;   while (t--) {     scanf("%lld", &n);     ;     scanf("%lld", &q);     ;     for (i = 0; i < n; i++) {       scanf("%lld", &c[i]);       ;       scanf("%lld", &d[i]);       ;     }     for (i = 0; i < n; i++) {       for (j = 0; j < n; j++) {         scanf("%lld", &dist[i][j]);         ;       }     }     for (i = 0; i < q; i++) {       scanf("%lld", &a[i]);       ;       scanf("%lld", &b[i]);       ;     }     dd[0] = 0;     for (i = 1; i < n; i++) {       dd[i] = dd[i - 1] + dist[i - 1][i];     }     besttime[0] = 0.0;     ld r;     for (i = 1; i < n; i++) {       r = 1e18;       for (j = 0; j < i; j++) {         if (dd[i] - dd[j] <= c[j]) {           best[i][j] = besttime[j] + ((dd[i] - dd[j]) * 1.0) / d[j];         } else {           best[i][j] = 1e18;         }         r = min(r, best[i][j]);       }       besttime[i] = r;     }      printf("Case #%d: %0.6lf\n", ct++, besttime[n - 1]);   }   return (0); }
#include <bitset> #include <deque> #include <iomanip> #include <iostream> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std; 
typedef long double td_ld; typedef vector<int> vi; typedef vector<vi> vvi; typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long LL;            typedef unsigned long long ULL;  typedef unsigned uint;    struct debugger {};  double besttime[1010]; LL c[110], d[110], dist[110][110], a[110], b[110], dd[110]; long double best[110][110]; inline void wkgwdtyhaz(long long &q, int &j, int &i, int &ct, long long &n) {   scanf("%lld", &n);   ;   scanf("%lld", &q);   ;   for (i = 0; i < n; i++) {     scanf("%lld", &c[i]);     ;     scanf("%lld", &d[i]);     ;   }   for (i = 0; i < n; i++) {     for (j = 0; j < n; j++) {       scanf("%lld", &dist[i][j]);       ;     }   }   for (i = 0; i < q; i++) {     scanf("%lld", &a[i]);     ;     scanf("%lld", &b[i]);     ;   }   dd[0] = 0;   for (i = 1; i < n; i++) {     dd[i] = dd[i - 1] + dist[i - 1][i];   }   besttime[0] = 0.0;   td_ld r;   for (i = 1; i < n; i++) {     r = 1e18;     for (j = 0; j < i; j++) {       if (dd[i] - dd[j] <= c[j]) {         best[i][j] = besttime[j] + ((dd[i] - dd[j]) * 1.0) / d[j];       } else {         best[i][j] = 1e18;       }       r = min(r, best[i][j]);     }     besttime[i] = r;   }    printf("Case #%d: %0.6lf\n", ct++, besttime[n - 1]); } 
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_16_Usenix_RF_1.0_True_MCTS_Classic_True/try/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_16_Usenix_RF_1.0_True_MCTS_Classic_True/try/lazyBit/A-small-practice.in",           "r", stdin);   ;     long long n, k, l, m, t, s = 0, p, q;   int i, j;   scanf("%lld ", &t);   int ct = 1;   while (t--)     wkgwdtyhaz(q, j, i, ct, n);   return (0); }
#include <bits/stdc++.h> #include <bitset> #include <cctype> #include <complex> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdio.h> #include <stdlib.h> #include <unordered_map>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std; 
typedef vector<int> vi; typedef vector<vi> vvi; typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long LL;           typedef unsigned long long ULL;     struct debugger {   template <typename T> debugger &solve(const T &v) {     cerr << v << " ";     return *this;   } };  void get(int *tc, int n) {   cout << "[";   for (int i = 0; i < n; i++)     cout << tc[i] << " ";   cout << "]" << endl; }  double besttime[1010]; LL c[110], d[110], dist[110][110], a[110], b[110], dd[110]; long double best[110][110]; inline void tvetyxhxvx(int &i, int &j) {   best[i][j] = besttime[j] + ((dd[i] - dd[j]) * 1.0) / d[j]; }  inline void uozliuexag(int &i, int &j) { best[i][j] = 1e18; }  inline void purjvenbrb(int &i, int &j) {   scanf("%lld", &dist[i][j]);   ; }  
int main() {    ;       long long n, k, l, m, t, s = 0, p, q;   int i, j;   scanf("%lld ", &t);   int ct = 1;   for (; t--;) {     scanf("%lld", &n);     ;     scanf("%lld", &q);     ;     for (i = 0; i < n; i++) {       scanf("%lld", &c[i]);       ;       scanf("%lld", &d[i]);       ;     }     for (i = 0; i < n; i++) {       for (j = 0; j < n; j++)         purjvenbrb(i, j);     }     for (i = 0; i < q; i++) {       scanf("%lld", &a[i]);       ;       scanf("%lld", &b[i]);       ;     }     dd[0] = 0;     for (i = 1; i < n; i++) {       dd[i] = dd[i - 1] + dist[i - 1][i];     }     besttime[0] = 0.0;     long double r;     for (i = 1; i < n; i++) {       r = 1e18;       for (j = 0; j < i; j++) {         if (dd[i] - dd[j] <= c[j])           tvetyxhxvx(i, j);         else           uozliuexag(i, j);         r = min(r, best[i][j]);       }       besttime[i] = r;     }      printf("Case #%d: %0.6lf\n", ct++, besttime[n - 1]);   }   return (0); }
#include <bits/stdc++.h> #include <bitset> #include <cctype> #include <climits> #include <complex> #include <deque> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <queue> #include <set> #include <sstream> #include <stack> #include <stdlib.h> #include <unordered_map>  #include <cassert> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <string>  #include <algorithm> #include <functional> #include <list> #include <map> #include <numeric> #include <utility> #include <vector>   using namespace std;
const double EPS = 1e-9;  typedef vector<int> vi; typedef vector<vi> vvi; typedef pair<int, int> ii; typedef vector<ii> vii; typedef vector<string> vs;  typedef long long LL;            typedef unsigned long long ULL;  typedef unsigned uint;  const double pi = acos(-1.0);  const double eps = 1e-11;      const int MAXI = 0x7fffffff; const int dx[] = {1, 0, -1, 0}; const int dy[] = {0, 1, 0, -1}; const char colors[] = {'R', 'O', 'Y', 'G', 'B', 'V'}; const char dz[] = "SENW"; struct debugger {   template <typename T> debugger &operator,(const T &v) {     cerr << v << " ";     return *this;   } } dbg;  void get(int *arr, int n) {   cout << "[";    for (int i = 0; i < n; i++)     cout << arr[i] << " ";   cout << "]" << endl; }  double besttime[1010]; LL c[110], d[110], dist[110][110], a[110], b[110], dd[110]; long double best[110][110]; inline void ojiqdrkwgk(int &i, int &j) {   scanf("%lld", &dist[i][j]);   ; }  inline void ziedmiwsme(int &i, int &j) {   best[i][j] = besttime[j] + ((dd[i] - dd[j]) * 1.0) / d[j]; }  inline void numfsyeenk(int &i, int &j) { best[i][j] = 1e18; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_16_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/lazyBit/outer_temp/lazyBit/A-small-practice_transformation.out",           "w", stdout);    ;     long long n, k, y, tc, t, s = 0, p, q;   int i, j;   cin >> t;   int ct = 1;   while (t--) {     scanf("%lld", &n);     ;     scanf("%lld", &q);     ;     for (i = 0; i < n; i++) {       scanf("%lld", &c[i]);       ;       scanf("%lld", &d[i]);       ;     }     for (i = 0; i < n; i++) {       for (j = 0; j < n; j++) {         ojiqdrkwgk(i, j);       }     }     for (i = 0; i < q; i++) {       scanf("%lld", &a[i]);       ;       scanf("%lld", &b[i]);       ;     }     dd[0] = 0;     for (i = 1; i < n; i++) {       dd[i] = dd[i - 1] + dist[i - 1][i];     }     besttime[0] = 0.0;     long double r;     for (i = 1; i < n; i++) {       r = 1e18;       for (j = 0; j < i; j++) {         if (dd[i] - dd[j] <= c[j])           ziedmiwsme(i, j);         else           numfsyeenk(i, j);         r = min(r, best[i][j]);       }       besttime[i] = r;     }      printf("Case #%d: %0.6lf\n", ct++, besttime[n - 1]);   }   return (0); }
#include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <fstream> #include <iostream> #include <map> #include <set> #include <sstream> #include <stdio.h> #include <string> #include <unordered_map> #include <utility> #include <vector>  using namespace std;
const int MAXN = 1005; const int MOD = 1000000007;  int solve(int x) {   long long n, N, e[105], s[105], d[105], temp;   scanf("%lld %lld ", &n, &N);   for (int i = 0; i < n; i++) {     scanf("%lld %lld ", &e[i], &s[i]);   }    int i;   for (i = 0; i < n; i++) {     for (int j = 0; j < n; j++) {       if (j == i + 1) {         scanf("%lld ", &d[i]);       } else         scanf("%lld ", &temp);     }   }   scanf("%lld %lld ", &temp, &temp);      vector<long double> dp(105);   for (int i = 0; i < n; i++) {     dp[i] = 1e11;   }   dp[n - 1] = 0;   for (int i = n - 2; i >= 0; i--) {     long double sss = 0;     long long ee = e[i];     long double a = 0;     for (int j = i; j < n - 1; j++) {       ee -= d[j];       if (ee < 0) {         break;       }       a += (1.0 * d[j]) / s[i];        if (j == i || a + dp[j + 1] < sss) {         sss = a + dp[j + 1];        }     }     dp[i] = sss;    }   cout << "Case #" << x << ": " << fixed << dp[0] << endl;   return 1; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_17_Usenix_RF_1.0_True_MCTS_Classic_True/try/Thanabhat/outer_temp/Thanabhat/A-small-practice_transformation.out",           "w", stdout);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_17_Usenix_RF_1.0_True_MCTS_Classic_True/try/Thanabhat/A-small-practice.in",           "r", stdin);    int get = 0;   int t;   scanf("%d ", &t);   cout.precision(7);   for (int i = 1; i <= t; i++) {     solve(i);   }   return get; }
#include <algorithm> #include <bits/stdc++.h> #include <cassert> #include <cctype> #include <climits> #include <cmath> #include <complex> #include <cstdlib> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <numeric> #include <queue> #include <set> #include <stack> #include <stdio.h> #include <stdlib.h> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
typedef long double ld; typedef pair<int, int> PII; typedef vector<int> vi; typedef vector<int> VI; typedef long double LD; typedef set<int> si;  int solve(int cc) {   int ret_val = 1;   long long n, q, e[105], s[105], d[105], temp;   scanf("%lld %lld ", &n, &q);   for (int i = 0; i < n; i++) {     scanf("%lld %lld ", &e[i], &s[i]);   }   for (int i = 0; i < n; i++) {     for (int j = 0; j < n; j++) {       if (j == i + 1) {         scanf("%lld ", &d[i]);       } else {         scanf("%lld ", &temp);       }     }   }   scanf("%lld %lld ", &temp, &temp);   long double dp[105];   for (int i = 0; i < n; i++) {     dp[i] = 1e11;   }   dp[n - 1] = 0;   for (int i = n - 2; i >= 0; i--) {     LD sss = 0;     long long ee = e[i];     LD tt = 0;     for (int j = i; j < n - 1; j++) {       ee -= d[j];       if (ee < 0) {         break;       }       tt += (1.0 * d[j]) / s[i];        if (j == i || tt + dp[j + 1] < sss) {         sss = tt + dp[j + 1];        }     }     dp[i] = sss;    }   cout << "Case #" << cc << ": " << fixed << dp[0] << endl;   return ret_val; }  
int main() {   int ret_val = 0;   int t;   scanf("%d ", &t);   cout.precision(7);   for (int i = 1; i <= t; i++) {     solve(i);   }   return ret_val; }
#include <cassert> #include <climits> #include <complex> #include <cstdio> #include <cstring> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <map> #include <math.h> #include <numeric> #include <queue> #include <sstream> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
inline void vjcdegfppa(long long d[105], int &i) { cin >> d[i]; }  inline void dyugaolucy(long long &temp) { cin >> temp; }  inline void dfhvvrhyxy(long double &sss, long double &tt, long double dp[105],                        int &j) {   sss = tt + dp[j + 1];  }  int get(int r) {   long long n, q, e[105], s[105], d[105], temp;   cin >> n >> q;   for (int i = 0; i < n; i++) {     cin >> e[i] >> s[i];   }   {     int i = 0;     while (i < n) {       int j;       for (j = 0; j < n; j++) {         if (j == i + 1)           vjcdegfppa(d, i);         else           dyugaolucy(temp);       }       i++;     }   }   cin >> temp >> temp;      long double dp[105];   for (int i = 0; i < n; i++) {     dp[i] = 1e11;   }   dp[n - 1] = 0;   for (int i = n - 2; i >= 0; i--) {     long double sss = 0;     long long ee = e[i];     long double tt = 0;     for (int j = i; j < n - 1; j++) {       ee -= d[j];       if (ee < 0) {         break;       }       tt += (1.0 * d[j]) / s[i];        if (j == i || tt + dp[j + 1] < sss)         dfhvvrhyxy(sss, tt, dp, j);     }     dp[i] = sss;    }   cout << "Case #" << r << ": " << fixed << dp[0] << endl;   return 1; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_17_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/Thanabhat/A-small-practice.in",           "r", stdin);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_17_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/Thanabhat/outer_temp/Thanabhat/A-small-practice_transformation.out",           "w", stdout);    int t;   cin >> t;   cout.precision(7);   int i;   for (i = 1; i <= t; i++) {     get(i);   }   return 0; }
#include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cstdio> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <queue> #include <stdio.h> #include <stdlib.h> #include <vector>  using namespace std;  
inline void ndqrmilrbd(long long d[105], int &i) { cin >> d[i]; }  int get(int cc) {   long long n, q, e[105], s[105], d[105], temp;   cin >> n >> q;   for (int i = 0; i < n; i++) {     cin >> e[i] >> s[i];   }   for (int i = 0; i < n; i++) {     for (int j = 0; j < n; j++) {       if (j == i + 1)         ndqrmilrbd(d, i);       else {         cin >> temp;       }     }   }   cin >> temp >> temp;      vector<long double> dp(105);   for (int i = 0; i < n; i++) {     dp[i] = 1e11;   }   dp[n - 1] = 0;   for (int i = n - 2; i >= 0; i--) {     long double sss = 0;     long long ee = e[i];     long double b = 0;     for (int j = i; j < n - 1; j++) {       ee -= d[j];       if (ee < 0) {         break;       }       b += (1.0 * d[j]) / s[i];        if (j == i || b + dp[j + 1] < sss) {         sss = b + dp[j + 1];        }     }     dp[i] = sss;    }   cout << "Case #" << cc << ": " << fixed << dp[0] << endl;   return 1; }  
int main() {   int t;   cin >> t;   cout.precision(7);   for (int i = 1; i <= t; i++) {     get(i);   }   return 0; }
#include <bits/stdc++.h> #include <cassert> #include <cctype> #include <cmath> #include <cstdio> #include <cstdlib> #include <ctime> #include <fstream> #include <iomanip> #include <iostream> #include <iterator> #include <math.h> #include <numeric> #include <sstream> #include <stack> #include <stdio.h> #include <string> #include <utility>  using namespace std;
const long double PI = 3.1415926535897932384626433832795; typedef long double td_ld;  const double EPS = 1e-9;  const long long inf = 4e18; const int N = 123;  int a[N]; int b[N]; long long d[N][N]; long double f[N]; bool was[N];  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_18_Usenix_RF_1.0_True_MCTS_Classic_True/sammyMaX/fragusbot/A-small-practice.in",           "r", stdin);    int t;   scanf("%d", &t);   for (int cc = 1; cc <= t; ++cc) {     double begt = clock();     cout << "Case #" << cc << ": ";     int solve, qq;     scanf("%d %d", &solve, &qq);     for (int i = 0; i < solve; ++i) {       scanf("%d %d", a + i, b + i);     }     for (int i = 0; i < solve; ++i) {       for (int j = 0; j < solve; ++j) {         int foo;         scanf("%d", &foo);         d[i][j] = (foo == -1 ? inf : foo);       }     }     {       int k = 0;       while (k < solve) {         for (int i = 0; i < solve; ++i) {           for (int j = 0; j < solve; ++j) {             d[i][j] = min(d[i][j], d[i][k] + d[k][j]);           }         }         ++k;       }     }     for (int q = 0; q < qq; ++q) {       if (q > 0)         putchar(' ');       int from, to;       scanf("%d %d", &from, &to);       --from;       --to;       for (int i = 0; i < solve; ++i) {         f[i] = inf;       }       memset(was, false, sizeof was);       was[from] = true;       f[from] = 0;       int x = from;       for (int it = 0; it < solve - 1; ++it) {         for (int y = 0; y < solve; ++y) {           if (d[x][y] > a[x]) {             continue;           }           td_ld cur = f[x] + (long double)d[x][y] / b[x];           if (cur < f[y]) {             f[y] = cur;           }         }         x = -1;         for (int y = 0; y < solve; ++y) {           if (was[y]) {             continue;           }           if (x == -1 || f[y] < f[x]) {             x = y;           }         }         was[x] = true;       }       cout << fixed << setprecision(15) << (double)f[to];     }     putchar('\n');     fprintf(stderr, "case %d solved in %.3f\n", cc,             (clock() - begt) / CLOCKS_PER_SEC);   } }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <climits> #include <cstdio> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <stdlib.h> #include <string> #include <utility> #include <vector>  using namespace std; 
const int MAXN = 1005;  const long long inf = 4e18; const int N = 123;  int a[N]; int b[N]; long long d[N][N]; long double f[N]; bool was[N];  inline void erkfhylzjt(int &i, int &k, int &solve) {   d[i][solve] = min(d[i][solve], d[i][k] + d[k][solve]); }  inline void eouofkbbbk(int &i, int &k, int &solve) { erkfhylzjt(i, k, solve); }  inline void ufqmqiszty(int &y, long double &cur) { f[y] = cur; }  inline void wpargjcynn(int &x, int &y) { x = y; }  
int main() {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_18_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/fragusbot/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_18_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/fragusbot/outer_temp/fragusbot/A-small-practice_transformation.out",           "w", stdout);   int p;   scanf("%d", &p);   for (int s = 1; s <= p; ++s) {     double tc = clock();     printf("Case #%d: ", s);     int n, qq;     scanf("%d %d", &n, &qq);     for (int i = 0; i < n; ++i) {       scanf("%d %d", a + i, b + i);     }     for (int i = 0; i < n; ++i) {       for (int solve = 0; solve < n; ++solve) {         int foo;         scanf("%d", &foo);         d[i][solve] = (foo == -1 ? inf : foo);       }     }     for (int k = 0; k < n; ++k) {       for (int i = 0; i < n; ++i) {         for (int solve = 0; solve < n; ++solve)           eouofkbbbk(i, k, solve);       }     }     for (int q = 0; q < qq; ++q) {       if (q > 0)         putchar(' ');       int from, to;       scanf("%d %d", &from, &to);       --from;       --to;       for (int i = 0; i < n; ++i) {         f[i] = inf;       }       memset(was, 0, sizeof was);       was[from] = true;       f[from] = 0;       int x = from;       for (int it = 0; it < n - 1; ++it) {         for (int y = 0; y < n; ++y) {           if (d[x][y] > a[x])             continue;            long double cur = f[x] + (long double)d[x][y] / b[x];           if (cur < f[y])             ufqmqiszty(y, cur);         }         x = -1;         for (int y = 0; y < n; ++y) {           if (was[y])             continue;            if (x == -1 || f[y] < f[x])             wpargjcynn(x, y);         }         was[x] = true;       }       printf("%.15f", (double)f[to]);     }     putchar('\n');     fprintf(stderr, "case %d solved in %.3f\n", s,             (clock() - tc) / CLOCKS_PER_SEC);   }   return 0; }
#include <bits/stdc++.h> #include <bitset> #include <cassert> #include <climits> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stdio.h> #include <unordered_map> #include <utility> #include <vector>  using namespace std; 
const double eps = 1e-9;  const long long inf = 4e18; const int N = 123;  int a[N]; int b[N]; long long d[N][N]; long double f[N]; bool was[N];  inline void xovaunwnql(int &x, int &y) { x = y; }  
int main() {   int ans;   scanf("%d", &ans);   for (int cc = 1; cc <= ans; ++cc) {     double begt = clock();     cout << "Case #" << cc << ": ";     int n, qq;     scanf("%d %d", &n, &qq);     for (int i = 0; i < n; ++i) {       scanf("%d %d", a + i, b + i);     }     for (int i = 0; i < n; ++i) {       for (int j = 0; j < n; ++j) {         int foo;         scanf("%d", &foo);         d[i][j] = (foo == -1 ? inf : foo);       }     }     for (int k = 0; k < n; ++k) {       {         int i = 0;         while (i < n) {           for (int j = 0; j < n; ++j)             d[i][j] = min(d[i][j], d[i][k] + d[k][j]);            ++i;         }       }     }     for (int q = 0; q < qq; ++q) {       if (q > 0)         putchar(' ');       int from, to;       scanf("%d %d", &from, &to);       --from;       --to;       for (int i = 0; i < n; ++i) {         f[i] = inf;       }       memset(was, false, sizeof was);       was[from] = true;       f[from] = 0;       int x = from;       for (int it = 0; it < n - 1; ++it) {         for (int y = 0; y < n; ++y) {           if (d[x][y] > a[x]) {             continue;           }           long double cur = f[x] + (long double)d[x][y] / b[x];           if (cur < f[y]) {             f[y] = cur;           }         }         x = -1;         for (int y = 0; y < n; ++y) {           if (was[y]) {             continue;           }           if (f[y] < f[x]) {             x = y;           } else if (x == -1)             xovaunwnql(x, y);         }         was[x] = true;       }       cout << fixed << setprecision(15) << (double)f[to];     }     putchar('\n');     fprintf(stderr, "case %d solved in %.3f\n", cc,             (clock() - begt) / CLOCKS_PER_SEC);   }   return 0; }
#include <algorithm> #include <bits/stdc++.h> #include <cassert> #include <cctype> #include <climits> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <math.h> #include <queue> #include <set> #include <stdio.h> #include <string> #include <utility> #include <vector>  using namespace std;
const int MOD = 1000000007; typedef long double LD; typedef set<int> si; typedef long long ll; typedef long long LL; typedef pair<int, int> pii; typedef pair<int, int> PII; typedef vector<int> VI; typedef vector<vector<int>> vvi;  const long long inf = 4e18; const int N = 123;  int a[N]; int b[N]; long long d[N][N]; long double f[N]; bool was[N];  inline void yjhgogburr(int &x, int &y) { x = y; }  
int main() {   ios::sync_with_stdio(false);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_18_Usenix_RF_1.0_True_MCTS_Classic_True/bennikartefla/fragusbot/A-small-practice.in",           "r", stdin);   int t;   scanf("%d", &t);   for (int p = 1; p <= t; ++p) {     double begt = clock();     printf("Case #%d: ", p);     int n, qq;     scanf("%d %d", &n, &qq);     for (int i = 0; i < n; ++i) {       scanf("%d %d", a + i, b + i);     }     for (int i = 0; i < n; ++i) {       for (int j = 0; j < n; ++j) {         int foo;         scanf("%d", &foo);         d[i][j] = (foo == -1 ? inf : foo);       }     }     for (int tc = 0; tc < n; ++tc) {       int i;       {         i = 0;         for (; i < n;) {           for (int j = 0; j < n; ++j) {             d[i][j] = min(d[i][j], d[i][tc] + d[tc][j]);           }           ++i;         }       }     }     for (int q = 0; q < qq; ++q) {       if (q > 0)         putchar(' ');       int from, to;       scanf("%d %d", &from, &to);       --from;       --to;       for (int i = 0; i < n; ++i) {         f[i] = inf;       }       memset(was, false, sizeof was);       was[from] = true;       f[from] = 0;       int x = from;       for (int it = 0; it < n - 1; ++it) {         for (int y = 0; y < n; ++y) {           if (d[x][y] > a[x]) {             continue;           }           LD cur = f[x] + (long double)d[x][y] / b[x];           if (cur < f[y]) {             f[y] = cur;           }         }         x = -1;         for (int y = 0; y < n; ++y) {           if (was[y]) {             continue;           }           if (f[y] < f[x]) {             x = y;           } else {             if (x == -1)               yjhgogburr(x, y);           }         }         was[x] = true;       }       printf("%.15f", (double)f[to]);     }     putchar('\n');     fprintf(stderr, "case %d solved in %.3f\n", p,             (clock() - begt) / CLOCKS_PER_SEC);   }   return 0; }
#include <algorithm> #include <bitset> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <iomanip> #include <iostream> #include <map> #include <queue> #include <set> #include <stdio.h> #include <string> #include <vector> #pragma comment(linker, "/STACK:256000000")  using namespace std; 
const double eps = 1e-9;  void get() {}  const int maxN = 110; const long long inf = 1000000000000000000LL;  int n, q; long long d[maxN][maxN]; long long e[maxN], s[maxN];  long long a[maxN], b[maxN];  double c[maxN];  double solve(int u, int v) {   --u;   --v;    for (int i = 0; i < n; ++i) {     c[i] = 1e50;   }   c[u] = 0.0;    for (int steps = 0; steps < 200; ++steps) {     for (int i = 0; i < n; ++i) {       for (int j = 0; j < n; ++j) {         if (e[i] < d[i][j]) {           continue;         } else if (i == j || d[i][j] == inf) {           continue;         }         c[j] = min(c[j], c[i] + (double)(d[i][j]) / (double)(s[i]));       }     }   }   return c[v]; }  inline void lpbspdytrm(int &i) {   int j = 0;   while (j < n) {     for (int ans = 0; ans < n; ++ans) {       d[j][ans] = min(d[j][ans], d[j][i] + d[i][ans]);     }     ++j;   } }  inline void npbfcxntiv(vector<double> &res) {   int i = 0;   while (i < q) {     printf(" %.10lf", res[i]);     ++i;   } }  void solve(int test) {   cin >> n >> q;   for (int i = 0; i < n; ++i) {     cin >> e[i] >> s[i];   }    for (int i = 0; i < n; ++i) {     for (int j = 0; j < n; ++j) {       cin >> d[i][j];       if (d[i][j] == -1)         d[i][j] = inf;     }   }    for (int i = 0; i < n; ++i) {     lpbspdytrm(i);   }    vector<double> res;   for (int i = 0; i < q; ++i) {     int u, v;     cin >> u >> v;     res.push_back(solve(u, v));   }    printf("Case #%d:", test);   npbfcxntiv(res);   printf("\n"); }  inline void rgrlorgmac(int &i) { solve(i); }  inline void zqvbuulbwp(int &p, int &right_bound, int &i) {   if (i >= p && i <= right_bound)     rgrlorgmac(i);   else {     get();   }   cerr << i << ": " << clock() << endl; }  
int main(int argc, char *argv[]) {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_19_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/sdya/A-small-practice.in",           "r", stdin);    freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_19_Usenix_RF_1.0_True_MCTS_Classic_True/Tashi711/sdya/outer_temp/sdya/A-small-practice_transformation.out",           "w", stdout);    int p, right_bound;      int t;   cin >> t;   p = 1, right_bound = t;   for (int i = 1; i <= t; ++i)     zqvbuulbwp(p, right_bound, i);    return 0; }
#include <algorithm> #include <bitset> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <iomanip> #include <iostream> #include <map> #include <queue> #include <set> #include <string> #include <vector> #pragma comment(linker, "/STACK:256000000")  using namespace std; 
void readData() {}  const int maxN = 110; const long long inf = 1000000000000000000LL;  int n, q; long long d[maxN][maxN]; long long e[maxN], s[maxN];  double c[maxN];  double solve(int u, int v) {   --u;   --v;    for (int i = 0; i < n; ++i) {     c[i] = 1e50;   }   c[u] = 0.0;    for (int steps = 0; steps < 200; ++steps) {     for (int i = 0; i < n; ++i) {       for (int j = 0; j < n; ++j) {         if (e[i] < d[i][j])           continue;         else if (i == j || d[i][j] == inf) {           continue;         }         c[j] = min(c[j], c[i] + (double)(d[i][j]) / (double)(s[i]));       }     }   }   return c[v]; }  inline void bnrgyvohtc(int &j, int &i, int &k) {   d[j][k] = min(d[j][k], d[j][i] + d[i][k]); }  inline void zmkcfpuasn(int &i, int &j) {   cin >> d[i][j];   if (d[i][j] == -1) {     d[i][j] = inf;   } }  inline void fuijpkmljp(int &i, int &j) { zmkcfpuasn(i, j); }  inline void pkwjrbbjyz(vector<double> &res, int &i) {   printf(" %.10lf", res[i]); }  void solve(int test) {   cin >> n >> q;   for (int i = 0; i < n; ++i) {     cin >> e[i] >> s[i];   }    for (int i = 0; i < n; ++i) {     for (int j = 0; j < n; ++j)       fuijpkmljp(i, j);   }    for (int i = 0; i < n; ++i) {     for (int j = 0; j < n; ++j) {       for (int k = 0; k < n; ++k)         bnrgyvohtc(j, i, k);     }   }    vector<double> res;   for (int i = 0; i < q; ++i) {     int u, v;     cin >> u >> v;     res.push_back(solve(u, v));   }    cout << "Case #" << test << ":";   for (int i = 0; i < q; ++i)     pkwjrbbjyz(res, i);   cout << "\n"; }  
int main(int r, char *argv[]) {   int ret_val = 0;    int left_bound, right_bound;   int t;   cin >> t;   left_bound = 1, right_bound = t;   {     int i = 1;     while (i <= t) {       if (i >= left_bound && i <= right_bound) {         solve(i);       } else         readData();        cerr << i << ": " << clock() << endl;       ++i;     }   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cassert> #include <cctype> #include <cmath> #include <complex> #include <cstdio> #include <cstring> #include <ctime> #include <deque> #include <functional> #include <iostream> #include <iterator> #include <map> #include <math.h> #include <numeric> #include <queue> #include <set> #include <string> #include <utility> #include <vector> #pragma comment(linker, "/STACK:256000000")  using namespace std; 
typedef long double ld; typedef long long ll; typedef pair<int, int> pii; typedef pair<int, int> PII; typedef vector<int> vi; typedef long double LD;  const int mod = 1000000007;  void readData() {}  const int maxN = 110; const long long inf = 1000000000000000000LL;  int n, q; long long d[maxN][maxN]; long long e[maxN], s[maxN];  long long a[maxN], b[maxN];  double c[maxN];  double solve(int u, int v) {   --u;   --v;    for (int i = 0; i < n; ++i) {     c[i] = 1e50;   }   c[u] = 0.0;    for (int steps = 0; steps < 200; ++steps) {     for (int i = 0; i < n; ++i) {       for (int j = 0; j < n; ++j) {         if (e[i] < d[i][j]) {           continue;         } else if (d[i][j] == inf) {           continue;         } else if (i == j) {           continue;         }         c[j] = min(c[j], c[i] + (double)(d[i][j]) / (double)(s[i]));       }     }   }   return c[v]; }  inline void ydqjdhkcuw() {   int i = 0;   while (i < n) {     cin >> e[i] >> s[i];     ++i;   } }  void solve(int test) {   cin >> n >> q;   ydqjdhkcuw();    {     int i = 0;     while (i < n) {       for (int j = 0; j < n; ++j) {         cin >> d[i][j];         if (d[i][j] == -1) {           d[i][j] = inf;         }       }       ++i;     }   }    for (int i = 0; i < n; ++i) {     for (int j = 0; j < n; ++j) {       for (int x = 0; x < n; ++x) {         d[j][x] = min(d[j][x], d[j][i] + d[i][x]);       }     }   }    vector<double> res;   for (int i = 0; i < q; ++i) {     int u, v;     cin >> u >> v;     res.push_back(solve(u, v));   }    printf("Case #%d:", test);   for (int i = 0; i < q; ++i) {     printf(" %.10lf", res[i]);   }   printf("\n"); } 
int main(int argc, char *argv[]) {   ios::sync_with_stdio(false);    int ret_val = 0;    int left_bound, r;   int t;   cin >> t;   left_bound = 1, r = t;   for (int i = 1; i <= t; ++i) {     if (i >= left_bound && i <= r) {       solve(i);     } else {       readData();     }     cerr << i << ": " << clock() << endl;   }   return ret_val; }
#include <algorithm> #include <bits/stdc++.h> #include <bitset> #include <cmath> #include <cstdio> #include <cstring> #include <ctime> #include <iostream> #include <map> #include <queue> #include <set> #include <stdio.h> #include <string> #include <utility> #include <vector> #pragma comment(linker, "/STACK:256000000")  using namespace std; 
typedef pair<int, int> ii; typedef vector<int> vi; typedef long long ll; typedef long long LL;  void readData() {}  const int maxN = 110; const long long inf = 1000000000000000000LL;  int n, q; long long d[maxN][maxN]; long long e[maxN], s[maxN];  long long a[maxN], b[maxN];  double c[maxN];  double open(int u, int v) {   --u;   --v;    for (int ct = 0; ct < n; ++ct) {     c[ct] = 1e50;   }   c[u] = 0.0;    for (int steps = 0; steps < 200; ++steps) {     for (int ct = 0; ct < n; ++ct) {       for (int j = 0; j < n; ++j) {         if (ct == j || d[ct][j] == inf || e[ct] < d[ct][j]) {           continue;         }         c[j] = min(c[j], c[ct] + (double)(d[ct][j]) / (double)(s[ct]));       }     }   }   return c[v]; }  void open(int test) {   scanf("%d %d ", &n, &q);   for (int ct = 0; ct < n; ++ct)     scanf("%lld %lld ", &e[ct], &s[ct]);    for (int ct = 0; ct < n; ++ct) {     for (int j = 0; j < n; ++j) {       scanf("%lld ", &d[ct][j]);       if (d[ct][j] == -1) {         d[ct][j] = inf;       }     }   }    for (int ct = 0; ct < n; ++ct) {     for (int j = 0; j < n; ++j) {       for (int k = 0; k < n; ++k) {         d[j][k] = min(d[j][k], d[j][ct] + d[ct][k]);       }     }   }    vector<double> res;   for (int ct = 0; ct < q; ++ct) {     int u, v;     scanf("%d %d ", &u, &v);     res.push_back(open(u, v));   }    printf("Case #%d:", test);   for (int ct = 0; ct < q; ++ct) {     printf(" %.10lf", res[ct]);   }   printf("\n"); }  inline void yvcgcgcqbg() { readData(); }  
int main(int argc, char *argv[]) {   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_19_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sdya/A-small-practice.in",           "r", stdin);   freopen("/home/seal12/Downloads/ramdisk/blackbox_8294486_5681755159789568_19_Usenix_RF_1.0_True_MCTS_Classic_True/ccsnoopy/sdya/outer_temp/sdya/A-small-practice_transformation.out",           "w", stdout);    int left_bound, right_bound;       int t;   scanf("%d ", &t);   left_bound = 1, right_bound = t;   for (int ct = 1; ct <= t; ++ct) {     if (ct >= left_bound && ct <= right_bound) {       open(ct);     } else       yvcgcgcqbg();     cerr << ct << ": " << clock() << endl;   }    return 0; }
